/usr/include/features.h<gnu/stubs.h><sys/cdefs.h><stdc-predef.h><features-time64.h>__USE_EXTERN_INLINES1__GLIBC_PREREQ(maj,min)((__GLIBC__ << 16) + __GLIBC_MINOR__ >= ((maj) << 16) + (min))__GLIBC_MINOR__35__GLIBC__2__GNU_LIBRARY__6__GLIBC_USE_DEPRECATED_SCANF0__GLIBC_USE_DEPRECATED_GETS__USE_FORTIFY_LEVEL__USE_GNU__USE_DYNAMIC_STACK_SIZE__USE_ATFILE__USE_MISC__USE_LARGEFILE64__USE_LARGEFILE__USE_ISOC99__USE_ISOC95__USE_XOPEN2KXSI__USE_XOPEN2K__USE_XOPEN2K8XSI__USE_XOPEN2K8_LARGEFILE_SOURCE__USE_UNIX98__USE_XOPEN_EXTENDED__USE_XOPEN_ATFILE_SOURCE__USE_POSIX199506__USE_POSIX199309__USE_POSIX2__USE_POSIX_POSIX_C_SOURCE200809L_POSIX_SOURCE__USE_ISOC11__GLIBC_USE_ISOC2X_DEFAULT_SOURCE_DYNAMIC_STACK_SIZE_SOURCE_LARGEFILE64_SOURCE_XOPEN_SOURCE_EXTENDED_XOPEN_SOURCE700_ISOC2X_SOURCE_ISOC11_SOURCE_ISOC99_SOURCE_ISOC95_SOURCE__GLIBC_USE(F)__GLIBC_USE_ ## F__glibc_clang_prereq(maj,min)__GNUC_PREREQ(maj,min)((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))__KERNEL_STRICT_NAMES__USE_FILE_OFFSET64__USE_ISOCXX11_FEATURES_H_LOOSE_KERNEL_NAMESdefined __GNUC__ && defined __GNUC_MINOR__defined __clang_major__ && defined __clang_minor__(defined _BSD_SOURCE || defined _SVID_SOURCE) \_GNU_SOURCE(defined _DEFAULT_SOURCE					\(defined _ISOC2X_SOURCE \(defined _ISOC11_SOURCE || defined _ISOC2X_SOURCE \(defined _ISOC99_SOURCE || defined _ISOC11_SOURCE			\__cplusplus__cplusplus >= 201703L__cplusplus >= 201103L || defined __GXX_EXPERIMENTAL_CXX0X__!defined _POSIX_SOURCE && !defined _POSIX_C_SOURCE((!defined __STRICT_ANSI__					\defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 500defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 600defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) < 700((!defined _POSIX_C_SOURCE || (_POSIX_C_SOURCE - 0) < 199506L) \(defined _POSIX_SOURCE					\defined _POSIX_C_SOURCE && _POSIX_C_SOURCE >= 2 || defined _XOPEN_SOURCEdefined _POSIX_C_SOURCE && (_POSIX_C_SOURCE - 0) >= 199309Ldefined _POSIX_C_SOURCE && (_POSIX_C_SOURCE - 0) >= 199506Ldefined _POSIX_C_SOURCE && (_POSIX_C_SOURCE - 0) >= 200112Ldefined _POSIX_C_SOURCE && (_POSIX_C_SOURCE - 0) >= 200809L(_XOPEN_SOURCE - 0) >= 500(_XOPEN_SOURCE - 0) >= 600(_XOPEN_SOURCE - 0) >= 700defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64defined _DEFAULT_SOURCEdefined _FORTIFY_SOURCE && _FORTIFY_SOURCE > 0!defined __OPTIMIZE__ || __OPTIMIZE__ <= 0!__GNUC_PREREQ (4, 1)_FORTIFY_SOURCE > 2 && (__glibc_clang_prereq (9, 0)		      \_FORTIFY_SOURCE > 3_FORTIFY_SOURCE > 1_FORTIFY_SOURCE > 2defined __cplusplus ? __cplusplus >= 201402L : defined __USE_ISOC11(defined __USE_GNU							\__ASSEMBLER___SYS_CDEFS_Hdefined __USE_FILE_OFFSET64 && !defined __REDIRECT__GNUC_PREREQ (2, 7) && defined __OPTIMIZE__ \__OPTIMIZE____GNUC_MINOR__7__GNUC__11__STDC_VERSION__201112L_FORTIFY_SOURCE1294_REENTRANT/* features.h  *//* This is here only because every header file already includes this one.
   Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
   <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
   that will always return failure (and set errno to ENOSYS).  *//* Decide whether we can define 'extern inline' functions in headers.  *//* !ASSEMBLER *//* If we don't have __REDIRECT, prototypes will be missing if
   __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64]. *//* This is here only because every header file already includes this one.  *//* Major and minor version number of the GNU C library package.  Use
   these macros to test for features in specific releases.  *//* This macro indicates that the installed library is the GNU C Library.
   For historic reasons the value now is 6 and this will stay from now
   on.  The use of this variable is deprecated.  Use __GLIBC__ and
   __GLIBC_MINOR__ now (see below) when you want to test for a specific
   GNU C library version and use the values in <gnu/lib-names.h> to get
   the sonames of the shared libraries.  *//* Get definitions of __STDC_* predefined macros, if the compiler has
   not preincluded this header automatically.  *//* GNU formerly extended the scanf functions with modified format
   specifiers %as, %aS, and %a[...] that allocate a buffer for the
   input using malloc.  This extension conflicts with ISO C99, which
   defines %a as a standalone format specifier that reads a floating-
   point number; moreover, POSIX.1-2008 provides the same feature
   using the modifier letter 'm' instead (%ms, %mS, %m[...]).

   We now follow C99 unless GNU extensions are active and the compiler
   is specifically in C89 or C++98 mode (strict or not).  For
   instance, with GCC, -std=gnu11 will have C99-compliant scanf with
   or without -D_GNU_SOURCE, but -std=c89 -D_GNU_SOURCE will have the
   old extension.  *//* The function 'gets' existed in C89, but is impossible to use
   safely.  It has been removed from ISO C11 and ISO C++14.  Note: for
   compatibility with various implementations of <cstdio>, this test
   must consider only the value of __cplusplus when compiling C++.  *//* Some C libraries once required _REENTRANT and/or _THREAD_SAFE to be
   defined in all multithreaded code.  GNU libc has not required this
   for many years.  We now treat them as compatibility synonyms for
   _POSIX_C_SOURCE=199506L, which is the earliest level of POSIX with
   comprehensive support for multithreaded code.  Using them never
   lowers the selected level of POSIX conformance, only raises it.  *//* If none of the ANSI/POSIX macros are defined, or if _DEFAULT_SOURCE
   is defined, use POSIX.1-2008 (or another version depending on
   _XOPEN_SOURCE).  *//* This is to enable compatibility for ISO C++11.
   Check the temporary macro for now, too.  *//* This is to enable compatibility for ISO C++17.  *//* This is to enable the ISO C90 Amendment 1:1995 extension.  *//* This is to enable the ISO C99 extension.  *//* This is to enable the ISO C11 extension.  *//* This is to enable the ISO C2X extension.  *//* If nothing (other than _GNU_SOURCE and _DEFAULT_SOURCE) is defined,
   define _DEFAULT_SOURCE.  *//* If _GNU_SOURCE was defined by the user, turn on all the other features.  *//* _BSD_SOURCE and _SVID_SOURCE are deprecated aliases for
   _DEFAULT_SOURCE.  If _DEFAULT_SOURCE is present we do not
   issue a warning; the expectation is that the source is being
   transitioned to use the new macro.  *//* Whether to use feature set F.  *//* Similarly for clang.  Features added to GCC after version 4.2 may
   or may not also be available in clang, and clang's definitions of
   __GNUC(_MINOR)__ are fixed at 4 and 2 respectively.  Not all such
   features can be queried via __has_extension/__has_feature.  *//* Convenience macro to test the version of gcc.
   Use like this:
   #if __GNUC_PREREQ (2,8)
   ... code requiring gcc 2.8 or later ...
   #endif
   Note: only works for GCC 2.0 and later, because __GNUC_MINOR__ was
   added in 2.0.  *//* Suppress kernel-name space pollution unless user expressedly asks
   for it.  *//* Undefine everything, so we get a clean slate.  *//* These are defined by the user (or the compiler)
   to specify the desired environment:

   __STRICT_ANSI__	ISO Standard C.
   _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
   _ISOC11_SOURCE	Extensions to ISO C99 from ISO C11.
   _ISOC2X_SOURCE	Extensions to ISO C99 from ISO C2X.
   __STDC_WANT_LIB_EXT2__
			Extensions to ISO C99 from TR 27431-2:2010.
   __STDC_WANT_IEC_60559_BFP_EXT__
			Extensions to ISO C11 from TS 18661-1:2014.
   __STDC_WANT_IEC_60559_FUNCS_EXT__
			Extensions to ISO C11 from TS 18661-4:2015.
   __STDC_WANT_IEC_60559_TYPES_EXT__
			Extensions to ISO C11 from TS 18661-3:2015.
   __STDC_WANT_IEC_60559_EXT__
			ISO C2X interfaces defined only in Annex F.

   _POSIX_SOURCE	IEEE Std 1003.1.
   _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
			if >=199309L, add IEEE Std 1003.1b-1993;
			if >=199506L, add IEEE Std 1003.1c-1995;
			if >=200112L, all of IEEE 1003.1-2004
			if >=200809L, all of IEEE 1003.1-2008
   _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
			Single Unix conformance is wanted, to 600 for the
			sixth revision, to 700 for the seventh revision.
   _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
   _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
   _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
   _FILE_OFFSET_BITS=N	Select default filesystem interface.
   _ATFILE_SOURCE	Additional *at interfaces.
   _DYNAMIC_STACK_SIZE_SOURCE Select correct (but non compile-time constant)
			MINSIGSTKSZ, SIGSTKSZ and PTHREAD_STACK_MIN.
   _GNU_SOURCE		All of the above, plus GNU extensions.
   _DEFAULT_SOURCE	The default set of features (taking precedence over
			__STRICT_ANSI__).

   _FORTIFY_SOURCE	Add security hardening to many library functions.
			Set to 1 or 2; 2 performs stricter checks than 1.

   _REENTRANT, _THREAD_SAFE
			Obsolete; equivalent to _POSIX_C_SOURCE=199506L.

   The `-ansi' switch to the GNU C compiler, and standards conformance
   options such as `-std=c99', define __STRICT_ANSI__.  If none of
   these are defined, or if _DEFAULT_SOURCE is defined, the default is
   to have _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
   200809L, as well as enabling miscellaneous functions from BSD and
   SVID.  If more than one of these are defined, they accumulate.  For
   example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE together
   give you ISO C, 1003.1, and 1003.2, but nothing else.

   These are defined by this file and are used by the
   header files to decide what to declare or define:

   __GLIBC_USE (F)	Define things from feature set F.  This is defined
			to 1 or 0; the subsequent macros are either defined
			or undefined, and those tests should be moved to
			__GLIBC_USE.
   __USE_ISOC11		Define ISO C11 things.
   __USE_ISOC99		Define ISO C99 things.
   __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
   __USE_ISOCXX11	Define ISO C++11 things.
   __USE_POSIX		Define IEEE Std 1003.1 things.
   __USE_POSIX2		Define IEEE Std 1003.2 things.
   __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
   __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
   __USE_XOPEN		Define XPG things.
   __USE_XOPEN_EXTENDED	Define X/Open Unix things.
   __USE_UNIX98		Define Single Unix V2 things.
   __USE_XOPEN2K        Define XPG6 things.
   __USE_XOPEN2KXSI     Define XPG6 XSI things.
   __USE_XOPEN2K8       Define XPG7 things.
   __USE_XOPEN2K8XSI    Define XPG7 XSI things.
   __USE_LARGEFILE	Define correct standard I/O things.
   __USE_LARGEFILE64	Define LFS things with separate names.
   __USE_FILE_OFFSET64	Define 64bit interface as default.
   __USE_MISC		Define things from 4.3BSD or System V Unix.
   __USE_ATFILE		Define *at interfaces and AT_* constants for them.
   __USE_DYNAMIC_STACK_SIZE Define correct (but non compile-time constant)
			MINSIGSTKSZ, SIGSTKSZ and PTHREAD_STACK_MIN.
   __USE_GNU		Define GNU extensions.
   __USE_FORTIFY_LEVEL	Additional security measures used, according to level.

   The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
   defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
   only for compatibility.  All new code should use the other symbols
   to test for features.

   All macros listed above as possibly being defined by this file are
   explicitly undefined if they are not explicitly defined.
   Feature-test macros that are not defined by the user or compiler
   but are implied by the other feature-test macros defined (or by the
   lack of any definitions) are defined by the file.

   ISO C feature test macros depend on the definition of the macro
   when an affected header is included, not when the first system
   header is included, and so they are handled in
   <bits/libc-header-start.h>, which does not have a multiple include
   guard.  Feature test macros that can be handled from the first
   system header included are handled here.  *//* Copyright (C) 1991-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/usr//usr/include/x86_64-linux-gnu/sys/wait.h<bits/types/siginfo_t.h><bits/waitstatus.h><bits/waitflags.h><signal.h><bits/types.h><features.h>wait4int *rusage *wait3waitidsiginfo_t *struct <unnamed> *waitpidwaitidtype_t(unnamed enum)P_ALLP_PIDP_PGIDWAIT_MYPGRPWAIT_ANY(-1)W_STOPCODE(sig)__W_STOPCODE (sig)W_EXITCODE(ret,sig)__W_EXITCODE (ret, sig)WCOREDUMP(status)__WCOREDUMP (status)WCOREFLAG__WCOREFLAGWIFCONTINUED(status)__WIFCONTINUED (status)WIFSTOPPED(status)__WIFSTOPPED (status)WIFSIGNALED(status)__WIFSIGNALED (status)WIFEXITED(status)__WIFEXITED (status)WSTOPSIG(status)__WSTOPSIG (status)WTERMSIG(status)__WTERMSIG (status)WEXITSTATUS(status)__WEXITSTATUS (status)_SYS_WAIT_H__pid_t_defineddefined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8!defined _STDLIB_H || (!defined __USE_XOPEN && !defined __USE_XOPEN2K8)__WIFCONTINUED__id_t_defineddefined __USE_MISC \__USE_TIME_BITS64__REDIRECT_NTHNLexternc_linkagenothrowrusage/* sys/wait.h  *//* Use misc.  *//* PID is like waitpid.  Other args are like wait3.  *//* Wait for a child to exit.  When one does, put its status in *STAT_LOC and
   return its process ID.  For errors return (pid_t) -1.  If USAGE is not
   nil, store information about the child's resource usage there.  If the
   WUNTRACED bit is set in OPTIONS, return status for stopped children;
   otherwise don't.  *//* This being here makes the prototypes valid whether or not
   we have already included <sys/resource.h> to define `struct rusage'.  *//* Wait for a childing matching IDTYPE and ID to change the status and
   place appropriate information in *INFOP.
   If IDTYPE is P_PID, match any process whose process ID is ID.
   If IDTYPE is P_PGID, match any process whose process group is ID.
   If IDTYPE is P_ALL, match any process.
   If the WNOHANG bit is set in OPTIONS, and that child
   is not already dead, clear *INFOP and return 0.  If successful, store
   exit code and status in *INFOP.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Wait for a child matching PID to die.
   If PID is greater than 0, match any process whose process ID is PID.
   If PID is (pid_t) -1, match any process.
   If PID is (pid_t) 0, match any process with the
   same process group as the current process.
   If PID is less than -1, match any process whose
   process group is the absolute value of PID.
   If the WNOHANG bit is set in OPTIONS, and that child
   is not already dead, return (pid_t) 0.  If successful,
   return PID and store the dead child's status in STAT_LOC.
   Return (pid_t) -1 for errors.  If the WUNTRACED bit is
   set in OPTIONS, return status for stopped children; otherwise don't.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Any process in my process group.  *//* Any process.  *//* Special values for the PID argument to `waitpid' and `wait4'.  *//* Wait for a child to die.  When one does, put its status in *STAT_LOC
   and return its process ID.  For errors, return (pid_t) -1.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Wait for members of process group.  *//* Wait for specified process.  *//* Wait for any child.  *//* The following values are used by the `waitid' function.  *//* <stdlib.h> not included.  *//* This will define all the `__W*' macros.  *//* This will define the `W*' macros for the flag
   bits to `waitpid', `wait3', and `wait4'.  *//* These macros could also be defined in <stdlib.h>.  *//* Some older standards require the contents of struct rusage to be
   defined here.  *//*
 *	POSIX Standard: 3.2.1 Wait for Process Termination	<sys/wait.h>
 *//usr/include/x86_64-linux-gnu/sys/usr/include/x86_64-linux-gnu__pid__stat_loc__options__usage__idtype__id__infop/usr/include/x86_64-linux-gnu/bits/types/struct_tm.htmconst charconst char *char *tm_zonetm_gmtofftm_isdsttm_ydaytm_wdaytm_yeartm_montm_mdaytm_hourtm_mintm_sec__struct_tm_defined/* Timezone abbreviation.  *//* Seconds east of UTC.  *//* DST.		[-1/0/1]*//* Days in year.[0-365]	*//* Day of week.	[0-6] *//* Year	- 1900.  *//* Month.	[0-11] *//* Day.		[1-31] *//* Hours.	[0-23] *//* Minutes.	[0-59] *//* Seconds.	[0-60] (1 leap second) *//* ISO C `broken-down time' structure.  *//usr/include/x86_64-linux-gnu/bits/types/usr/include/x86_64-linux-gnu/bits/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/autoopts/project.h"ag-char-map.h""compat/compat.h""config.h"tSuccessparse_durationoption_parse_durationMODEVALUE(s)= sHADGLITCH(p)((p) > SUCCESS)FAILED(p)((p) < SUCCESS)SUCCESSFUL(p)SUCCEEDED(p)((p) == SUCCESS)PROBLEM((tSuccess) 1)FAILURE((tSuccess)-1)SUCCESS((tSuccess) 0)HADGLITCHFAILEDSUCCESSFULSUCCEEDEDAUTOGEN_PROJECT_HSTRDEFINING/* end of project.h *//* AUTOGEN_PROJECT_H *//*
 *  Procedure success codes
 *
 *  USAGE:  define procedures to return "tSuccess".  Test their results
 *          with the SUCCEEDED, FAILED and HADGLITCH macros.
 *
 *  Microsoft sticks its nose into user space here, so for Windows' sake,
 *  make sure all of these are undefined.
 *//**
 * \file project.h
 *
 *  This file is part of AutoOpts, a companion to AutoGen.
 *  AutoOpts is free software.
 *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
 *
 *  AutoOpts is available under any one of two licenses.  The license
 *  in use must be one of these two and the choice is under the control
 *  of the user of the license.
 *
 *   The GNU Lesser General Public License, version 3 or later
 *      See the files "COPYING.lgplv3" and "COPYING.gplv3"
 *
 *   The Modified Berkeley Software Distribution License
 *      See the file "COPYING.mbsd"
 *
 *  These files have the following sha256 sums:
 *
 *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3
 *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3
 *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/autoopts/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/home/dhr33ti/Desktop/courses/hss/home/dhr33ti/Desktop/courses/home/dhr33ti/Desktop/home/dhr33ti/home/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/compat/unlocked-io.h<stdio.h>funlockfile(x)((void) 0)funlockfileftrylockfile(x)ftrylockfileflockfile(x)flockfileputchar(x)putchar_unlocked (x)putcharputc(x,y)putc_unlocked (x,y)putcgetchar()getchar_unlocked ()getchargetc(x)getc_unlocked (x)getcfwrite(w,x,y,z)fwrite_unlocked (w,x,y,z)fwritefread(w,x,y,z)fread_unlocked (w,x,y,z)freadfputs(x,y)fputs_unlocked (x,y)fputsfputc(x,y)fputc_unlocked (x,y)fputcfgets(x,y,z)fgets_unlocked (x,y,z)fgetsfflush(x)fflush_unlocked (x)fflushferror(x)ferror_unlocked (x)ferrorfeof(x)feof_unlocked (x)feofclearerr(x)clearerr_unlocked (x)clearerrUNLOCKED_IO_HHAVE_DECL_CLEARERR_UNLOCKEDHAVE_DECL_FEOF_UNLOCKEDHAVE_DECL_FERROR_UNLOCKEDHAVE_DECL_FFLUSH_UNLOCKEDHAVE_DECL_FGETS_UNLOCKEDHAVE_DECL_FPUTC_UNLOCKEDHAVE_DECL_FPUTS_UNLOCKEDHAVE_DECL_FREAD_UNLOCKEDHAVE_DECL_FWRITE_UNLOCKEDHAVE_DECL_GETC_UNLOCKEDHAVE_DECL_GETCHAR_UNLOCKEDHAVE_DECL_PUTC_UNLOCKEDHAVE_DECL_PUTCHAR_UNLOCKED/* UNLOCKED_IO_H *//* These are wrappers for functions/macros from the GNU C library, and
   from other C libraries supporting POSIX's optional thread-safe functions.

   The standard I/O functions are thread-safe.  These *_unlocked ones are
   more efficient but not thread-safe.  That they're not thread-safe is
   fine since all of the applications in this package are single threaded.

   Also, some code that is shared with the GNU C library may invoke
   the *_unlocked functions directly.  On hosts that lack those
   functions, invoke the non-thread-safe versions instead.  *//* Written by Jim Meyering.  *//* Prefer faster, non-thread-safe stdio functions if available.

   Copyright (C) 2001-2004, 2009-2012, 2014-2015 Free Software Foundation, Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/compat/usr/include/x86_64-linux-gnu/sys/time.h<sys/select.h><bits/types/struct_timeval.h><bits/types/time_t.h>futimesatconst timevalconst timeval[2]timeval[2]futimeslutimesutimessetitimerconst itimervalconst itimerval *itimerval *const itimerval *__restrict__itimerval *__restrict__getitimeradjtimeconst timeval *timeval *settimeofdayconst timezoneconst timezone *timezone *gettimeofdaytimeval *__restrict__void *void *__restrict____itimer_which_titimerval__itimer_whichITIMER_REALITIMER_VIRTUALITIMER_PROFtimezoneit_valueit_intervaltz_dsttimetz_minuteswesttimersub(a,b,result)do { (result)->tv_sec = (a)->tv_sec - (b)->tv_sec; (result)->tv_usec = (a)->tv_usec - (b)->tv_usec; if ((result)->tv_usec < 0) { --(result)->tv_sec; (result)->tv_usec += 1000000; } } while (0)timeradd(a,b,result)do { (result)->tv_sec = (a)->tv_sec + (b)->tv_sec; (result)->tv_usec = (a)->tv_usec + (b)->tv_usec; if ((result)->tv_usec >= 1000000) { ++(result)->tv_sec; (result)->tv_usec -= 1000000; } } while (0)timercmp(a,b,CMP)(((a)->tv_sec == (b)->tv_sec) ? ((a)->tv_usec CMP (b)->tv_usec) : ((a)->tv_sec CMP (b)->tv_sec))timerclear(tvp)((tvp)->tv_sec = (tvp)->tv_usec = 0)timerisset(tvp)((tvp)->tv_sec || (tvp)->tv_usec)TIMESPEC_TO_TIMEVAL(tv,ts){ (tv)->tv_sec = (ts)->tv_sec; (tv)->tv_usec = (ts)->tv_nsec / 1000; }TIMEVAL_TO_TIMESPEC(tv,ts){ (ts)->tv_sec = (tv)->tv_sec; (ts)->tv_nsec = (tv)->tv_usec * 1000; }_SYS_TIME_H__suseconds_t_defined__REDIRECT_NTHdefined __USE_GNU && !defined __cplusplusleaf(1)nonnull/* sys/time.h *//* Misc.  *//* Convenience macros for operations on timevals.
   NOTE: `timercmp' does not work for >= or <=.  *//* Change the access time of FILE relative to FD to TVP[0] and the
   modification time of FILE to TVP[1].  If TVP is a null pointer, use
   the current time instead.  Returns 0 on success, -1 on errors.  *//* Same as `utimes', but takes an open file descriptor instead of a name.  *//* Same as `utimes', but does not follow symbolic links.  *//* Change the access time of FILE to TVP[0] and the modification time of
   FILE to TVP[1].  If TVP is a null pointer, use the current time instead.
   Returns 0 on success, -1 on errors.  *//* Set the timer WHICH to *NEW.  If OLD is not NULL,
   set *OLD to the old value of timer WHICH.
   Returns 0 on success, -1 on errors.  *//* Set *VALUE to the current setting of timer WHICH.
   Return 0 on success, -1 on errors.  *//* Use the nicer parameter type only in GNU mode and not for C++ since the
   strict C++ rules prevent the automatic promotion.  *//* Time to the next timer expiration.  *//* Value to put into `it_value' when the timer expires.  *//* Type of the second argument to `getitimer' and
   the second and third arguments `setitimer'.  *//* Timers run when the process is executing and when
       the system is executing on behalf of the process.  *//* Timers run only when the process is executing.  *//* Timers run in real time.  *//* Values for the first argument to `getitimer' and `setitimer'.  *//* Adjust the current time of day by the amount in DELTA.
   If OLDDELTA is not NULL, it is filled in with the amount
   of time adjustment remaining to be done from the last `adjtime' call.
   This call is restricted to the super-user.  *//* Set the current time of day and timezone information.
   This call is restricted to the super-user.
   Setting the timezone in this way is obsolete, but we don't yet
   warn about it because it still has some uses for which there is
   no alternative.  *//* Get the current time of day, putting it into *TV.
   If TZ is not null, *TZ must be a struct timezone, and both fields
   will be set to zero.
   Calling this function with a non-null TZ is obsolete;
   use localtime etc. instead.
   This function itself is semi-obsolete;
   most callers should use time or clock_gettime instead. *//* Nonzero if DST is ever in effect.  *//* Minutes west of GMT.  *//* Structure crudely representing a timezone.
   This is obsolete and should never be used.  *//* Macros for converting between `struct timeval' and `struct timespec'.  */__fd__file__tvp__which__new__old__value__delta__olddelta__tv__tz/usr/include/guile/2.0/libguile/scmconfig.h<stddef.h><sys/types.h><stdlib.h><time.h><sys/time.h><limits.h><stdint.h>scm_t_offscm_t_timespecscm_t_ptrdiffscm_t_uint64scm_t_int64scm_t_uintptrscm_t_intptrscm_t_uintmaxscm_t_intmaxscm_t_uint32scm_t_int32scm_t_uint16scm_t_int16scm_t_uint8scm_t_int8SCM_ICONVEH_ESCAPE_SEQUENCESCM_ICONVEH_QUESTION_MARKSCM_ICONVEH_ERRORSCM_HAVE_ARRAYSDYNAMIC_LINKINGDEBUG_EXTENSIONSREADER_EXTENSIONSGUILE_ISELECTUSE_THREADSSCM_HAVE_THREAD_STORAGE_CLASSSCM_T_OFF_MINSCM_T_INT64_MINSCM_T_OFF_MAXSCM_T_INT64_MAXSCM_HAVE_READDIR64_RSCM_HAVE_STRUCT_DIRENT64SCM_HAVE_GC_PTHREAD_SIGMASKSCM_HAVE_GC_PTHREAD_EXITSCM_HAVE_GC_PTHREAD_CANCELSCM_NEED_BRACES_ON_PTHREAD_MUTEX_INITIALIZERSCM_NEED_BRACES_ON_PTHREAD_ONCE_INITSCM_USE_NULL_THREADSSCM_USE_PTHREAD_THREADSSCM_SIZEOF_UINTPTR_T8SCM_SIZEOF_INTPTR_TSCM_SIZEOF_SCM_T_PTRDIFFSCM_HAVE_T_UINT64SCM_HAVE_T_INT64SCM_SIZEOF_INTMAXSCM_SIZEOF_UNSIGNED_LONG_LONGSCM_SIZEOF_LONG_LONGSCM_SIZEOF_SIZE_TSCM_SIZEOF_UNSIGNED_INTSCM_SIZEOF_INTSCM_SIZEOF_UNSIGNED_LONGSCM_SIZEOF_LONGSCM_SIZEOF_UNSIGNED_SHORTSCM_SIZEOF_SHORTSCM_SIZEOF_UNSIGNED_CHARSCM_SIZEOF_CHARSCM_C_INLINEinlineSCM_STACK_GROWS_UPSCM_ENABLE_DEPRECATEDSCM_HAVE_WINSOCK2_HSCM_HAVE_SYS_SELECT_HSCM_HAVE_STDC_HEADERSSCM_SCMCONFIG_HSCM_ENABLE_DEPRECATED == 1/* Constants from uniconv.h.  *//* always true now *//* Define to 1 if the compiler supports the `__thread' storage class.  *//* 0 or 1 *//* Define to 1 if `readdir64_r ()' is available.  *//* Define to 1 if `struct dirent64' is available.  *//*** File system access ***//* Define to 1 if need braces around PTHREAD_MUTEX_INITIALIZER
   (for IRIX with GCC)  *//* Define to 1 if need braces around PTHREAD_ONCE_INIT (for Solaris). *//* Define to 1 if using one-thread 'multi'threading. *//* Define to 1 if using pthread multithreading. *//*** Threading model (scmconfig.h support not finished) ***//* same as POSIX "struct timespec" -- always defined *//* Size of uintptr_t or 0 if not available *//* Size of intptr_t or 0 if not available *//* scm_t_ptrdiff and size, always defined -- defined to long if
   platform doesn't have ptrdiff_t. *//* These are always defined. *//* Size of (unsigned) long long or 0 if not available (scm_t_*64 may
   be more likely to be what you want *//* These are always defined *//* Standard types. *//* C compiler's syntax for inline functions if any,
   otherwise undefined. *//* Set to 1 if the stack grows up, 0 otherwise. *//* (value will be 0 or 1). *//* Set to 1 if you want to enable deprecated features. *//* #undef GUILE_DEBUG *//* Define to include various undocumented debugging functions. *//* Important headers *//* This file is automatically generated -- see configure.in for details *//* Copyright (C) 2003, 2006 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/usr/include/guile/2.0/usr/include/guile/usr/include/x86_64-linux-gnu/gmp.h__gmpn_neggnu_inlinenegmp_limb_t18446744073709551615GMP_NUMB_MASKcom..(*)(..)__gmpn_sub_1sub_1__gmp_c__gmp_dst__gmp_src__gmp_size__gmp_n-__GMPN_SUBCB__gmp_r__gmp_x(__gmp_n)__gmp_i"_CRI ivdep"const mp_limb_tconst mp_limb_t *unsigned long *__gmp_j__gmpn_subsub__gmp_wp__gmp_xp__gmp_xsize__gmp_yp__gmp_ysizempn_sub_n__gmpn_sub_n(((__gmp_wp)[__gmp_i++] = (__gmp_x - 1) & GMP_NUMB_MASK), __gmp_x == 0)(((__gmp_wp)[__gmp_i++] = (__gmp_x - 1) & ((~ ((mp_limb_t) (0))) >> 0)), __gmp_x == 0)sub_n__gmp_done__gmpn_zero_pzero_p__gmpn_cmpcmp__gmp_result__gmp_y-1__gmpn_add_1add_1+__GMPN_ADDCB__gmpn_addaddmpn_add_n__gmpn_add_n(((__gmp_wp)[__gmp_i++] = (__gmp_x + 1) & GMP_NUMB_MASK) == 0)(((__gmp_wp)[__gmp_i++] = (__gmp_x + 1) & ((~ ((mp_limb_t) (0))) >> 0)) == 0)add_n__gmpq_negconst __mpq_structconst __mpq_struct *__gmpq_abs__gmp_w->_mp_num._mp_size__gmpz_size__gmp_z->_mp_size__gmpz_set_q__gmp_rp__gmp_up__gmp_p__gmp_w__gmp_u__gmp_zconst __mpz_structconst __mpz_struct *__gmpz_popcount__gmp_usizemp_bitcnt_t__GMP_CAST (mp_bitcnt_t, 0)~ __GMP_CAST (mp_bitcnt_t, 0)__gmp_usize > 0popcount__builtin_expectmp_limb_t *__gmpz_perfect_square_p__gmp_asize__gmp_asize > 0perfect_square_p__gmpz_neg__gmpz_getlimbn__gmp_n >= 0 && __gmp_n < __GMP_ABS (__gmp_z->_mp_size)__gmp_n >= 0 && __gmp_n < ((__gmp_z->_mp_size) >= 0 ? (__gmp_z->_mp_size) : -(__gmp_z->_mp_size))__gmpz_get_ui__gmp_l__gmpz_fits_ushort_pUSHRT_MAX(0x7fff * 2 + 1)327676553465535__gmpz_fits_ulong_pULONG_MAX(0x7fffffffffffffffL * 2UL + 1UL)922337203685477580718446744073709551614__gmpz_fits_uint_pUINT_MAX(0x7fffffff * 2U + 1U)214748364742949672944294967295__gmpz_abs__gmp_w->_mp_size__gmpn_sec_invert_itch__gmpn_sec_invert__gmpn_sec_div_r_itch__gmpn_sec_div_r__gmpn_sec_div_qr_itch__gmpn_sec_div_qr__gmpn_sec_tabselectvolatile mp_limb_tvolatile mp_limb_t *const volatile mp_limb_tconst volatile mp_limb_t *__gmpn_sec_powm_itch__gmpn_sec_powm__gmpn_sec_sqr_itch__gmpn_sec_sqr__gmpn_sec_mul_itch__gmpn_sec_mul__gmpn_cnd_swap__gmpn_sec_sub_1_itch__gmpn_sec_sub_1__gmpn_sec_add_1_itch__gmpn_sec_add_1__gmpn_cnd_sub_n__gmpn_cnd_add_n__gmpn_zero__gmpn_copyd__gmpn_copyi__gmpn_xnor_n__gmpn_xor_n__gmpn_nior_n__gmpn_iorn_n__gmpn_ior_n__gmpn_nand_n__gmpn_andn_n__gmpn_and_n__gmpn_tdiv_qr__gmpn_submul_1__gmpn_sqrtrem__gmpn_sizeinbase__gmpn_set_strconst unsigned charconst unsigned char *unsigned char *__gmpn_scan1__gmpn_scan0__gmpn_rshift__gmpn_random2__gmpn_random__gmpn_preinv_mod_1__gmpn_pow_1__gmpn_popcount__gmpn_perfect_power_p__gmpn_perfect_square_p__gmpn_com__gmpn_sqr__gmpn_mul_n__gmpn_mul_1__gmpn_mul__gmpn_mod_1__gmpn_lshift__gmpn_hamdist__gmpn_get_str__gmpn_gcdextmp_size_t *long *__gmpn_gcdext_1mp_limb_signed_t *__gmpn_gcd_1__gmpn_gcd_11__gmpn_gcd__gmpn_div_qr_2__gmpn_div_qr_1__gmpn_divrem_2__gmpn_divrem_1__gmpn_divrem__gmpn_divexact_by3c__gmpn_divexact_1__gmpn_addmul_1__gmpf_urandomb__gmpf_ui_sub__gmpf_ui_div__gmpf_trunc__gmpf_swap__gmpf_sub_ui__gmpf_sub__gmpf_sqrt_ui__gmpf_sqrt__gmpf_size__gmpf_set_z__gmpf_set_ui__gmpf_set_str__gmpf_set_si__gmpf_set_q__gmpf_set_prec_raw__gmpf_set_prec__gmpf_set_default_prec__gmpf_set_d__gmpf_set__gmpf_reldiff__gmpf_random2__gmpf_pow_ui__gmpf_out_strFILE *_IO_FILE *__gmpf_neg__gmpf_mul_ui__gmpf_mul_2exp__gmpf_mul__gmpf_integer_p__gmpf_inp_str__gmpf_init_set_ui__gmpf_init_set_str__gmpf_init_set_si__gmpf_init_set_d__gmpf_init_set__gmpf_inits__gmpf_init2__gmpf_init__gmpf_get_ui__gmpf_get_strmp_exp_t *__gmpf_get_si__gmpf_get_prec__gmpf_get_default_prec__gmpf_get_d_2expsigned long *__gmpf_get_d__gmpf_floor__gmpf_fits_ushort_p__gmpf_fits_ulong_p__gmpf_fits_uint_p__gmpf_fits_sshort_p__gmpf_fits_slong_p__gmpf_fits_sint_p__gmpf_eq__gmpf_dump__gmpf_div_ui__gmpf_div_2exp__gmpf_div__gmpf_cmp_ui__gmpf_cmp_si__gmpf_cmp_d__gmpf_cmp_z__gmpf_cmp__gmpf_clears__gmpf_clear__gmpf_ceil__gmpf_add_ui__gmpf_add__gmpf_abs__gmpq_swap__gmpq_sub__gmpq_set_z__gmpq_set_ui__gmpq_set_str__gmpq_set_si__gmpq_set_num__gmpq_set_f__gmpq_set_den__gmpq_set_d__gmpq_set__gmpq_out_str__gmpq_mul_2exp__gmpq_mul__gmpq_inv__gmpq_inp_str__gmpq_inits__gmpq_init__gmpq_get_str__gmpq_get_d__gmpq_get_den__gmpq_get_num__gmpq_equal__gmpq_div_2exp__gmpq_div__gmpq_cmp_z__gmpq_cmp_ui__gmpq_cmp_si__gmpq_cmp__gmpq_clears__gmpq_clear__gmpq_canonicalize__gmpq_add__gmpz_roinit_n__gmpz_limbs_finish__gmpz_limbs_modify__gmpz_limbs_write__gmpz_limbs_read__gmpz_xor__gmpz_urandomm__gmpz_urandomb__gmpz_ui_pow_ui__gmpz_tstbit__gmpz_tdiv_r_ui__gmpz_tdiv_r_2exp__gmpz_tdiv_r__gmpz_tdiv_qr_ui__gmpz_tdiv_qr__gmpz_tdiv_q_ui__gmpz_tdiv_q_2exp__gmpz_tdiv_q__gmpz_tdiv_ui__gmpz_swap__gmpz_submul_ui__gmpz_submul__gmpz_ui_sub__gmpz_sub_ui__gmpz_sub__gmpz_sqrtrem__gmpz_sqrt__gmpz_sizeinbase__gmpz_setbit__gmpz_set_ui__gmpz_set_str__gmpz_set_si__gmpz_set_f__gmpz_set_d__gmpz_set__gmpz_scan1__gmpz_scan0__gmpz_rrandomb__gmpz_rootrem__gmpz_root__gmpz_remove__gmpz_realloc2__gmpz_random2__gmpz_random__gmpz_probab_prime_p__gmpz_powm_ui__gmpz_powm_sec__gmpz_powm__gmpz_pow_ui__gmpz_perfect_power_p__gmpz_out_str__gmpz_out_raw__gmpz_nextprime__gmpz_mul_ui__gmpz_mul_si__gmpz_mul_2exp__gmpz_mul__gmpz_mod__gmpz_millerrabin__gmpz_lucnum2_ui__gmpz_lucnum_ui__gmpz_lcm_ui__gmpz_lcm__gmpz_ui_kronecker__gmpz_si_kronecker__gmpz_kronecker_ui__gmpz_kronecker_si__gmpz_jacobi__gmpz_ior__gmpz_invert__gmpz_inp_str__gmpz_inp_raw__gmpz_init_set_ui__gmpz_init_set_str__gmpz_init_set_si__gmpz_init_set_d__gmpz_init_set__gmpz_inits__gmpz_init2__gmpz_init__gmpz_importconst voidconst void *__gmpz_hamdist__gmpz_get_str__gmpz_get_si__gmpz_get_d_2exp__gmpz_get_d__gmpz_gcdext__gmpz_gcd_ui__gmpz_gcd__gmpz_fits_sshort_p__gmpz_fits_slong_p__gmpz_fits_sint_p__gmpz_fib2_ui__gmpz_fib_ui__gmpz_fdiv_ui__gmpz_fdiv_r_ui__gmpz_fdiv_r_2exp__gmpz_fdiv_r__gmpz_fdiv_qr_ui__gmpz_fdiv_qr__gmpz_fdiv_q_ui__gmpz_fdiv_q_2exp__gmpz_fdiv_q__gmpz_primorial_ui__gmpz_mfac_uiui__gmpz_2fac_ui__gmpz_fac_ui__gmpz_exportsize_t *__gmpz_dump__gmpz_divisible_2exp_p__gmpz_divisible_ui_p__gmpz_divisible_p__gmpz_divexact_ui__gmpz_divexact__gmpz_congruent_ui_p__gmpz_congruent_2exp_p__gmpz_congruent_p__gmpz_combit__gmpz_com__gmpz_cmpabs_ui__gmpz_cmpabs_d__gmpz_cmpabs__gmpz_cmp_ui__gmpz_cmp_si__gmpz_cmp_d__gmpz_cmp__gmpz_clrbit__gmpz_clears__gmpz_clear__gmpz_cdiv_ui__gmpz_cdiv_r_ui__gmpz_cdiv_r_2exp__gmpz_cdiv_r__gmpz_cdiv_qr_ui__gmpz_cdiv_qr__gmpz_cdiv_q_ui__gmpz_cdiv_q_2exp__gmpz_cdiv_q__gmpz_bin_uiui__gmpz_bin_ui__gmpz_array_init__gmpz_and__gmpz_addmul_ui__gmpz_addmul__gmpz_add_ui__gmpz_add__gmpz_realloc__gmp_sscanf__gmp_scanf__gmp_fscanf__gmp_sprintf__gmp_snprintf__gmp_printf__gmp_fprintf__gmp_asprintfchar **__gmp_urandomm_ui__gmp_urandomb_ui__gmp_randclear__gmp_randseed_ui__gmp_randseed__gmp_randinit_setconst __gmp_randstate_structconst __gmp_randstate_struct *__gmp_randinit_mt__gmp_randinit_lc_2exp_size__gmp_randinit_lc_2exp__gmp_randinit_default__gmp_randinit__gmp_get_memory_functions..(**)(..)__gmp_set_memory_functionsGMP_ERROR_NONEGMP_ERROR_UNSUPPORTED_ARGUMENTGMP_ERROR_DIVISION_BY_ZEROGMP_ERROR_SQRT_OF_NEGATIVEGMP_ERROR_INVALID_ARGUMENT__mpq_struct *mpq_ptrmpq_srcptr__mpf_struct *mpf_ptrconst __mpf_structconst __mpf_struct *mpf_srcptr__mpz_struct *mpz_ptrmpz_srcptr__gmp_randstate_struct[1]struct <unnamed>[1]gmp_randstate_t__gmp_randstate_structstruct <unnamed>union <unnamed>gmp_randalg_tGMP_RAND_ALG_DEFAULTGMP_RAND_ALG_LC__mpf_struct[1]mpf_t__mpf_struct__mpq_struct[1]mpq_tMP_RAT__mpq_structmp_exp_tmp_size_tmp_srcptrmp_ptr__mpz_struct[1]mpz_tMP_INT__mpz_structmp_limb_signed_t_mp_algdata_mp_alg_mp_seed_mp_lc_mp_d_mp_exp_mp_size_mp_prec_mp_den_mp_num_mp_allocconst char *const__gmp_version__gmp_errnoconst int__gmp_bits_per_limb__GMP_H____GNU_MP_RELEASE(__GNU_MP_VERSION * 10000 + __GNU_MP_VERSION_MINOR * 100 + __GNU_MP_VERSION_PATCHLEVEL)__GNU_MP_VERSION_PATCHLEVEL__GNU_MP_VERSION_MINOR__GNU_MP_VERSION__GMP_CFLAGS"-g -O2 -ffile-prefix-map=/build/gmp-Wr5pU1/gmp-6.2.1+dfsg=. -flto=auto -ffat-lto-objects -flto=auto -ffat-lto-objects -fstack-protector-strong -Wformat -Werror=format-security -O3"__GMP_CC"x86_64-linux-gnu-gcc"mpz_mod_2expmpz_fdiv_r_2expmpz_div_2expmpz_fdiv_q_2expmpz_divmod_uimpz_fdiv_qr_uimpz_div_uimpz_fdiv_q_uimpz_divmodmpz_fdiv_qrmpz_divmpz_fdiv_qmpz_mmod_ui(r,n,d)(((r) == 0) ? mpz_fdiv_ui (n,d) : mpz_fdiv_r_ui (r,n,d))mpz_mdivmod_ui(q,r,n,d)(((r) == 0) ? mpz_fdiv_q_ui (q,n,d) : mpz_fdiv_qr_ui (q,r,n,d))mpz_mdiv_uimpz_mmodmpz_fdiv_rmpz_mdivmodmpz_mdivmpn_divmod(qp,np,nsize,dp,dsize)mpn_divrem (qp, __GMP_CAST (mp_size_t, 0), np, nsize, dp, dsize)mpz_even_p(z)(! mpz_odd_p (z))mpz_odd_p(z)(((z)->_mp_size != 0) & __GMP_CAST (int, (z)->_mp_d[0]))mpq_cmp_si(q,n,d)(__builtin_constant_p ((n) >= 0) && (n) >= 0 ? mpq_cmp_ui (q, __GMP_CAST (unsigned long, n), d) : _mpq_cmp_si (q, n, d))mpq_cmp_ui(Q,NUI,DUI)(__builtin_constant_p (NUI) && (NUI) == 0 ? mpq_sgn (Q) : __builtin_constant_p ((NUI) == (DUI)) && (NUI) == (DUI) ? mpz_cmp (mpq_numref (Q), mpq_denref (Q)) : _mpq_cmp_ui (Q,NUI,DUI))mpz_cmp_si(Z,SI)(__builtin_constant_p ((SI) >= 0) && (SI) >= 0 ? mpz_cmp_ui (Z, __GMP_CAST (unsigned long, SI)) : _mpz_cmp_si (Z,SI))mpz_cmp_ui(Z,UI)(__builtin_constant_p (UI) && (UI) == 0 ? mpz_sgn (Z) : _mpz_cmp_ui (Z,UI))mpq_sgn(Q)((Q)->_mp_num._mp_size < 0 ? -1 : (Q)->_mp_num._mp_size > 0)mpf_sgn(F)((F)->_mp_size < 0 ? -1 : (F)->_mp_size > 0)mpz_sgn(Z)((Z)->_mp_size < 0 ? -1 : (Z)->_mp_size > 0)__GMPN_COPY(dst,src,size)__GMPN_COPY_REST (dst, src, size, 0)__GMPN_COPY_REST(dst,src,size,start)do { mp_size_t __gmp_j; __GMP_CRAY_Pragma ("_CRI ivdep"); for (__gmp_j = (start); __gmp_j < (size); __gmp_j++) (dst)[__gmp_j] = (src)[__gmp_j]; } while (0)__GMPN_CMP(result,xp,yp,size)do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_y; (result) = 0; __gmp_i = (size); while (--__gmp_i >= 0) { __gmp_x = (xp)[__gmp_i]; __gmp_y = (yp)[__gmp_i]; if (__gmp_x != __gmp_y) { (result) = (__gmp_x > __gmp_y ? 1 : -1); break; } } } while (0)__GMPN_SUB_1(cout,dst,src,n,v)__GMPN_AORS_1(cout, dst, src, n, v, -, __GMPN_SUBCB)__GMPN_ADD_1(cout,dst,src,n,v)__GMPN_AORS_1(cout, dst, src, n, v, +, __GMPN_ADDCB)__GMPN_SUBCB(r,x,y)((x) < (y))__GMPN_ADDCB(r,x,y)((r) < (y))__GMPN_AORS_1(cout,dst,src,n,v,OP,CB)do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_r; __gmp_x = (src)[0]; __gmp_r = __gmp_x OP (v); (dst)[0] = __gmp_r; if (CB (__gmp_r, __gmp_x, (v))) { (cout) = 1; for (__gmp_i = 1; __gmp_i < (n);) { __gmp_x = (src)[__gmp_i]; __gmp_r = __gmp_x OP 1; (dst)[__gmp_i] = __gmp_r; ++__gmp_i; if (!CB (__gmp_r, __gmp_x, 1)) { if ((src) != (dst)) __GMPN_COPY_REST (dst, src, n, __gmp_i); (cout) = 0; break; } } } else { if ((src) != (dst)) __GMPN_COPY_REST (dst, src, n, 1); (cout) = 0; } } while (0)__GMPN_SUB(cout,wp,xp,xsize,yp,ysize)__GMPN_AORS (cout, wp, xp, xsize, yp, ysize, mpn_sub_n, (((wp)[__gmp_i++] = (__gmp_x - 1) & GMP_NUMB_MASK), __gmp_x == 0))__GMPN_ADD(cout,wp,xp,xsize,yp,ysize)__GMPN_AORS (cout, wp, xp, xsize, yp, ysize, mpn_add_n, (((wp)[__gmp_i++] = (__gmp_x + 1) & GMP_NUMB_MASK) == 0))__GMPN_AORS(cout,wp,xp,xsize,yp,ysize,FUNCTION,TEST)do { mp_size_t __gmp_i; mp_limb_t __gmp_x; __gmp_i = (ysize); if (__gmp_i != 0) { if (FUNCTION (wp, xp, yp, __gmp_i)) { do { if (__gmp_i >= (xsize)) { (cout) = 1; goto __gmp_done; } __gmp_x = (xp)[__gmp_i]; } while (TEST); } } if ((wp) != (xp)) __GMPN_COPY_REST (wp, xp, xsize, __gmp_i); (cout) = 0; __gmp_done: ; } while (0)__GMPZ_FITS_UTYPE_P(z,maxval)mp_size_t __gmp_n = z->_mp_size; mp_ptr __gmp_p = z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= maxval));mpn_sec_invert_itch__MPN(sec_invert_itch)mpn_sec_invert__MPN(sec_invert)mpn_sec_div_r_itch__MPN(sec_div_r_itch)mpn_sec_div_r__MPN(sec_div_r)mpn_sec_div_qr_itch__MPN(sec_div_qr_itch)mpn_sec_div_qr__MPN(sec_div_qr)mpn_sec_tabselect__MPN(sec_tabselect)mpn_sec_powm_itch__MPN(sec_powm_itch)mpn_sec_powm__MPN(sec_powm)mpn_sec_sqr_itch__MPN(sec_sqr_itch)mpn_sec_sqr__MPN(sec_sqr)mpn_sec_mul_itch__MPN(sec_mul_itch)mpn_sec_mul__MPN(sec_mul)mpn_cnd_swap__MPN(cnd_swap)mpn_sec_sub_1_itch__MPN(sec_sub_1_itch)mpn_sec_sub_1__MPN(sec_sub_1)mpn_sec_add_1_itch__MPN(sec_add_1_itch)mpn_sec_add_1__MPN(sec_add_1)mpn_cnd_sub_n__MPN(cnd_sub_n)mpn_cnd_add_n__MPN(cnd_add_n)mpn_zero__MPN(zero)mpn_copyd__MPN(copyd)mpn_copyi__MPN(copyi)mpn_xnor_n__MPN(xnor_n)mpn_xor_n__MPN(xor_n)mpn_nior_n__MPN(nior_n)mpn_iorn_n__MPN(iorn_n)mpn_ior_n__MPN(ior_n)mpn_nand_n__MPN(nand_n)mpn_andn_n__MPN(andn_n)mpn_and_n__MPN(and_n)mpn_tdiv_qr__MPN(tdiv_qr)mpn_submul_1__MPN(submul_1)__MPN(sub_n)mpn_sub_1__MPN(sub_1)mpn_sub__MPN(sub)mpn_sqrtrem__MPN(sqrtrem)mpn_sizeinbase__MPN(sizeinbase)mpn_set_str__MPN(set_str)mpn_scan1__MPN(scan1)mpn_scan0__MPN(scan0)mpn_rshift__MPN(rshift)mpn_random2__MPN(random2)mpn_random__MPN(random)mpn_preinv_mod_1__MPN(preinv_mod_1)mpn_pow_1__MPN(pow_1)mpn_popcount__MPN(popcount)mpn_perfect_power_p__MPN(perfect_power_p)mpn_perfect_square_p__MPN(perfect_square_p)mpn_com__MPN(com)mpn_neg__MPN(neg)mpn_sqr__MPN(sqr)mpn_mul_n__MPN(mul_n)mpn_mul_1__MPN(mul_1)mpn_mul__MPN(mul)mpn_mod_1__MPN(mod_1)mpn_lshift__MPN(lshift)mpn_hamdist__MPN(hamdist)mpn_get_str__MPN(get_str)mpn_gcdext__MPN(gcdext)mpn_gcdext_1__MPN(gcdext_1)mpn_gcd_1__MPN(gcd_1)mpn_gcd_11__MPN(gcd_11)mpn_gcd__MPN(gcd)mpn_div_qr_2__MPN(div_qr_2)mpn_div_qr_1__MPN(div_qr_1)mpn_divrem_2__MPN(divrem_2)mpn_divrem_1__MPN(divrem_1)mpn_divrem__MPN(divrem)mpn_divmod_1(qp,np,nsize,dlimb)mpn_divrem_1 (qp, __GMP_CAST (mp_size_t, 0), np, nsize, dlimb)mpn_divexact_by3c__MPN(divexact_by3c)mpn_divexact_by3(dst,src,size)mpn_divexact_by3c (dst, src, size, __GMP_CAST (mp_limb_t, 0))mpn_divexact_1__MPN(divexact_1)mpn_zero_p__MPN(zero_p)mpn_cmp__MPN(cmp)mpn_addmul_1__MPN(addmul_1)__MPN(add_n)mpn_add_1__MPN(add_1)mpn_add__MPN(add)mpf_urandombmpf_ui_submpf_ui_divmpf_truncmpf_swapmpf_sub_uimpf_submpf_sqrt_uimpf_sqrtmpf_sizempf_set_zmpf_set_uimpf_set_strmpf_set_simpf_set_qmpf_set_prec_rawmpf_set_precmpf_set_default_precmpf_set_dmpf_setmpf_reldiffmpf_random2mpf_pow_uimpf_out_strmpf_negmpf_mul_uimpf_mul_2expmpf_mulmpf_integer_pmpf_inp_strmpf_init_set_uimpf_init_set_strmpf_init_set_simpf_init_set_dmpf_init_setmpf_initsmpf_init2mpf_initmpf_get_uimpf_get_strmpf_get_simpf_get_precmpf_get_default_precmpf_get_d_2expmpf_get_dmpf_floormpf_fits_ushort_pmpf_fits_ulong_pmpf_fits_uint_pmpf_fits_sshort_pmpf_fits_slong_pmpf_fits_sint_pmpf_eqmpf_dumpmpf_div_uimpf_div_2expmpf_divmpf_cmp_uimpf_cmp_simpf_cmp_dmpf_cmp_zmpf_cmpmpf_clearsmpf_clearmpf_ceilmpf_add_uimpf_addmpf_absmpq_swapmpq_submpq_set_zmpq_set_uimpq_set_strmpq_set_simpq_set_nummpq_set_fmpq_set_denmpq_set_dmpq_setmpq_out_strmpq_negmpq_mul_2expmpq_mulmpq_invmpq_inp_strmpq_initsmpq_initmpq_get_strmpq_get_dmpq_get_denmpq_get_nummpq_equalmpq_div_2expmpq_divmpq_cmp_z_mpq_cmp_ui_mpq_cmp_simpq_cmpmpq_clearsmpq_clearmpq_canonicalizempq_addmpq_absMPZ_ROINIT_N(xp,xs){{0, (xs),(xp) }}mpz_roinit_nmpz_limbs_finishmpz_limbs_modifympz_limbs_writempz_limbs_readmpz_eormpz_xormpz_urandommmpz_urandombmpz_ui_pow_uimpz_tstbitmpz_tdiv_r_uimpz_tdiv_r_2expmpz_tdiv_rmpz_tdiv_qr_uimpz_tdiv_qrmpz_tdiv_q_uimpz_tdiv_q_2expmpz_tdiv_qmpz_tdiv_uimpz_swapmpz_submul_uimpz_submulmpz_ui_submpz_sub_uimpz_submpz_sqrtremmpz_sqrtmpz_sizeinbasempz_sizempz_setbitmpz_set_uimpz_set_strmpz_set_simpz_set_qmpz_set_fmpz_set_dmpz_setmpz_scan1mpz_scan0mpz_rrandombmpz_rootremmpz_rootmpz_removempz_realloc2mpz_random2mpz_randommpz_probab_prime_pmpz_powm_uimpz_powm_secmpz_powmmpz_pow_uimpz_popcountmpz_perfect_square_pmpz_perfect_power_pmpz_out_strmpz_out_rawmpz_nextprimempz_negmpz_mul_uimpz_mul_simpz_mul_2expmpz_mulmpz_mod_uimpz_fdiv_r_uimpz_modmpz_millerrabinmpz_lucnum2_uimpz_lucnum_uimpz_legendrempz_jacobimpz_lcm_uimpz_lcmmpz_ui_kroneckermpz_si_kroneckermpz_kronecker_uimpz_kronecker_simpz_kroneckermpz_iormpz_invertmpz_inp_strmpz_inp_rawmpz_init_set_uimpz_init_set_strmpz_init_set_simpz_init_set_dmpz_init_setmpz_initsmpz_init2mpz_initmpz_importmpz_hamdistmpz_getlimbnmpz_get_uimpz_get_strmpz_get_simpz_get_d_2expmpz_get_dmpz_gcdextmpz_gcd_uimpz_gcdmpz_fits_ushort_pmpz_fits_ulong_pmpz_fits_uint_pmpz_fits_sshort_pmpz_fits_slong_pmpz_fits_sint_pmpz_fib2_uimpz_fib_uimpz_fdiv_uimpz_primorial_uimpz_mfac_uiuimpz_2fac_uimpz_fac_uimpz_exportmpz_dumpmpz_divisible_2exp_pmpz_divisible_ui_pmpz_divisible_pmpz_divexact_uimpz_divexactmpz_congruent_ui_pmpz_congruent_2exp_pmpz_congruent_pmpz_combitmpz_commpz_cmpabs_uimpz_cmpabs_dmpz_cmpabs_mpz_cmp_ui_mpz_cmp_simpz_cmp_dmpz_cmpmpz_clrbitmpz_clearsmpz_clearmpz_cdiv_uimpz_cdiv_r_uimpz_cdiv_r_2expmpz_cdiv_rmpz_cdiv_qr_uimpz_cdiv_qrmpz_cdiv_q_uimpz_cdiv_q_2expmpz_cdiv_qmpz_bin_uiuimpz_bin_uimpz_array_initmpz_andmpz_addmul_uimpz_addmulmpz_add_uimpz_addmpz_absmpz_realloc_mpz_reallocgmp_vsscanf__gmp_vsscanfgmp_vscanf__gmp_vscanfgmp_vfscanf__gmp_vfscanfgmp_sscanfgmp_scanfgmp_fscanfgmp_vsprintf__gmp_vsprintfgmp_vsnprintf__gmp_vsnprintfgmp_vprintf__gmp_vprintfgmp_vfprintf__gmp_vfprintfgmp_vasprintf__gmp_vasprintfgmp_sprintfgmp_snprintfgmp_printfgmp_obstack_vprintf__gmp_obstack_vprintfgmp_obstack_printf__gmp_obstack_printfgmp_fprintfgmp_asprintfgmp_urandomm_uigmp_urandomb_uigmp_randcleargmp_randseed_uigmp_randseedgmp_randinit_setgmp_randinit_mtgmp_randinit_lc_2exp_sizegmp_randinit_lc_2expgmp_randinit_defaultgmp_randinitgmp_versiongmp_errnomp_bits_per_limbmp_get_memory_functionsmp_set_memory_functionsmpq_denref(Q)(&((Q)->_mp_den))mpq_numref(Q)(&((Q)->_mp_num))__GMP_CRAY_Pragma(str)__GMP_UNLIKELY(cond)__builtin_expect ((cond) != 0, 0)__GMP_LIKELY(cond)__builtin_expect ((cond) != 0, 1)__GMP_MAX(h,i)((h) > (i) ? (h) : (i))__GMP_ABS(x)((x) >= 0 ? (x) : -(x))__GMP_INLINE_PROTOTYPES__GMP_EXTERN_INLINEextern __inline__ __attribute__ ((__gnu_inline__))__GMP_NOTHROW__GMP_CAST(type,expr)((type) (expr))__GMP_ATTRIBUTE_PURE__attribute__ ((__pure__))__GMP_GNUC_PREREQ(maj,min)_GMP_H_HAVE_FILE__MPN(x)__gmpn_ ## x__GMP_DECLSPEC_XX__GMP_MP_SIZE_T_INT__GMP_DECLSPEC__GMP_DECLSPEC_IMPORT__declspec(__dllimport__)__GMP_DECLSPEC_EXPORT__declspec(__dllexport__)__GMP_LIBGMP_DLL__GNU_MP__GMP_NAIL_MASK(~ GMP_NUMB_MASK)GMP_NUMB_MAX((~ __GMP_CAST (mp_limb_t, 0)) >> GMP_NAIL_BITS)GMP_NUMB_BITS(GMP_LIMB_BITS - GMP_NAIL_BITS)GMP_NAIL_BITSGMP_LIMB_BITS64__GMP_HAVE_HOST_CPU_FAMILY_powerpc__GMP_HAVE_HOST_CPU_FAMILY_powerdefined (__cplusplus)! defined (__GMP_WITHIN_CONFIGURE)defined (__GNUC__)defined (_MSC_VER) || defined (__BORLANDC__)__WATCOMC____IBMC____GMP_WITHIN_GMP__GMP_SHORT_LIMB_LONG_LONG_LIMBdefined (_CRAY) && ! defined (_CRAYMPP)__GMP_WITHIN_GMPXX__MPNdefined (FILE)                                              \defined (_OBSTACK_H)va_startdefined (__GNUC__) && defined (__GNUC_MINOR__)__GMP_GNUC_PREREQ (2,96) && ! defined (__GMP_NO_ATTRIBUTE_CONST_PURE)__cplusplus >= 201103L(defined __GNUC_STDC_INLINE__) || (__GNUC__ == 4 && __GNUC_MINOR__ == 2) \__DECC__SCO_VERSION____SCO_VERSION__ > 400000000 && __STDC__ != 1 \_MSC_VERdefined (__SUNPRO_C) && __SUNPRO_C >= 0x560 \defined (__SUNPRO_C) && __SUNPRO_C >= 0x540 \defined (__cplusplus) && ! defined (__GMP_EXTERN_INLINE)defined (__GMP_WITHIN_CONFIGURE) && ! __GMP_WITHIN_CONFIGURE_INLINE__GMP_GNUC_PREREQ (3,0)_CRAYdefined (_GMP_H_HAVE_OBSTACK)defined (_GMP_H_HAVE_OBSTACK) && defined (_GMP_H_HAVE_VA_LIST)defined (_GMP_H_HAVE_VA_LIST)defined (_GMP_H_HAVE_FILE) && defined (_GMP_H_HAVE_VA_LIST)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_abs)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_fits_uint_p)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_fits_ulong_p)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_fits_ushort_p)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_get_ui)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_getlimbn)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_neg)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_perfect_square_p)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_popcount)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_set_q)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpz_size)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpq_abs)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpq_neg)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpn_add)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpn_add_1)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpn_cmp)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpn_zero_p)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpn_neg)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpn_sub)__GMP_INLINE_PROTOTYPES || defined (__GMP_FORCE_mpn_sub_1)defined (__GMP_EXTERN_INLINE) && ! defined (__GMP_FORCE_mpz_abs)GMP_NAIL_BITS == 0defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_fits_uint_p)! defined (__GMP_FORCE_mpz_fits_uint_p)defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_fits_ulong_p)! defined (__GMP_FORCE_mpz_fits_ulong_p)defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_fits_ushort_p)! defined (__GMP_FORCE_mpz_fits_ushort_p)defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_get_ui)! defined (__GMP_FORCE_mpz_get_ui)GMP_NAIL_BITS == 0 || defined (_LONG_LONG_LIMB)defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_getlimbn)! defined (__GMP_FORCE_mpz_getlimbn)defined (__GMP_EXTERN_INLINE) && ! defined (__GMP_FORCE_mpz_neg)defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_perfect_square_p)! defined (__GMP_FORCE_mpz_perfect_square_p)defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_popcount)! defined (__GMP_FORCE_mpz_popcount)defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_set_q)! defined (__GMP_FORCE_mpz_set_q)defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpz_size)! defined (__GMP_FORCE_mpz_size)defined (__GMP_EXTERN_INLINE) && ! defined (__GMP_FORCE_mpq_abs)defined (__GMP_EXTERN_INLINE) && ! defined (__GMP_FORCE_mpq_neg)GMP_NAIL_BITS >= 1defined (__GMPN_COPY) && ! defined (__GMPN_COPY_REST)! defined (__GMPN_COPY_REST)! defined (__GMPN_COPY)defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpn_add)! defined (__GMP_FORCE_mpn_add)__gmp_adefined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpn_add_1)! defined (__GMP_FORCE_mpn_add_1)defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpn_cmp)! defined (__GMP_FORCE_mpn_cmp)defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpn_zero_p)! defined (__GMP_FORCE_mpn_zero_p)defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpn_sub)! defined (__GMP_FORCE_mpn_sub)defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpn_sub_1)! defined (__GMP_FORCE_mpn_sub_1)defined (__GMP_EXTERN_INLINE) || defined (__GMP_FORCE_mpn_neg)! defined (__GMP_FORCE_mpn_neg)defined (__GNUC__) && __GNUC__ >= 2puresec_invert_itchsec_invertsec_div_r_itchsec_div_rsec_div_qr_itchsec_div_qrsec_tabselectsec_powm_itchsec_powmsec_sqr_itchsec_sqrsec_mul_itchsec_mulcnd_swapsec_sub_1_itchsec_sub_1sec_add_1_itchsec_add_1cnd_sub_ncnd_add_nzerocopydcopyixnor_nxor_nnior_niorn_nior_nnand_nandn_nand_ntdiv_qrsubmul_1sqrtremsizeinbaseset_strscan1scan0rshiftrandom2randompreinv_mod_1pow_1perfect_power_psqrmul_nmul_1mulmod_1lshifthamdistget_strgcdextgcdext_1gcd_1gcd_11gcddiv_qr_2div_qr_1divrem_2divrem_1divremdivexact_by3cdivexact_1addmul_1void_param_list__SHRT_MAX__0x7fff__LONG_MAX__0x7fffffffffffffffL__INT_MAX__0x7fffffff3__GNUC_STDC_INLINE__96/* __GMP_H__ *//* Major version number is the value of __GNU_MP__ too, above. *//* Define CC and CFLAGS which were used to build this version of GMP *//* Useful synonyms, but not quite compatible with GMP 1.  *//* Source-level compatibility with GMP 1.  *//* Source-level compatibility with GMP 2 and earlier. *//**************** C++ routines ****************//* Using "&" rather than "&&" means these can come out branch-free.  Every
   mpz_t has at least one limb allocated, so fetching the low limb is always
   allowed.  *//* When using GCC, optimize certain common comparisons.  *//* Allow faster testing for negative, zero, and positive.  *//* Higher limbs get complemented. *//* All zero *//* Low zero limbs are unchanged by negation. *//* if (__GMP_LIKELY (__gmp_n > 0)) *//* Enhancement: Use some of the smarter code from gmp-impl.h.  Maybe use
   mpn_copyi if there's a native version, and if we don't mind demanding
   binary compatibility for it (on targets which use it).  *//* ASSERT (MPN_SAME_OR_SEPARATE_P (dst, src, size)); *//* ASSERT ((start) <= (size)); *//* ASSERT ((start) >= 0); *//* ASSERT ((size) >= 0); *//* Copy {src,size} to {dst,size}, starting at "start".  This is designed to
   keep the indexing dst[j] and src[j] nice and simple for __GMPN_ADD_1,
   __GMPN_ADD, etc.  *//* Cannot use __gmp_x - __gmp_y, may overflow an "int" *//* Compare {xp,size} and {yp,size}, setting "result" to positive, zero or
   negative.  size==0 is allowed.  On random data usually only one limb will
   need to be examined to get a result, so it's worth having it inline.  *//* ASSERT (MPN_SAME_OR_SEPARATE_P (dst, src, n)); *//* ASSERT ((n) >= 1); *//* The use of __gmp_i indexing is designed to ensure a compile time src==dst
   remains nice and clear to the compiler, so that __GMPN_COPY_REST can
   disappear, and the load/add/store gets a chance to become a
   read-modify-write on CISC CPUs.

   Alternatives:

   Using a pair of pointers instead of indexing would be possible, but gcc
   isn't able to recognise compile-time src==dst in that case, even when the
   pointers are incremented more or less together.  Other compilers would
   very likely have similar difficulty.

   gcc could use "if (__builtin_constant_p(src==dst) && src==dst)" or
   similar to detect a compile-time src==dst.  This works nicely on gcc
   2.95.x, it's not good on gcc 3.0 where __builtin_constant_p(p==p) seems
   to be always false, for a pointer p.  But the current code form seems
   good enough for src==dst anyway.

   gcc on x86 as usual doesn't give particularly good flags handling for the
   carry/borrow detection.  It's tempting to want some multi instruction asm
   blocks to help it, and this was tried, but in truth there's only a few
   instructions to save and any gain is all too easily lost by register
   juggling setting up for the asm.  *//* ASSERT (MPN_SAME_OR_SEPARATE2_P (wp, xsize, yp, ysize)); *//* ASSERT (MPN_SAME_OR_SEPARATE2_P (wp, xsize, xp, xsize)); *//* ASSERT ((xsize) >= (ysize)); *//* ASSERT ((ysize) >= 0); *//* The comments with __GMPN_ADD_1 below apply here too.

   The test for FUNCTION returning 0 should predict well.  If it's assumed
   {yp,ysize} will usually have a random number of bits then the high limb
   won't be full and a carry out will occur a good deal less than 50% of the
   time.

   ysize==0 isn't a documented feature, but is used internally in a few
   places.

   Producing cout last stops it using up a register during the main part of
   the calculation, though gcc (as of 3.0) on an "if (mpn_add (...))"
   doesn't seem able to move the true and false legs of the conditional up
   to the two places cout is generated.  *//**************** mpn inlines ****************//**************** mpq inlines ****************//* zero is a square, negatives are not *//* limb==long and nails, need two limbs when available *//* limb==long and no nails, or limb==longlong, one limb is enough *//* This is a "#if" rather than a plain "if" so as to avoid gcc warnings
     about "<< GMP_NUMB_BITS" exceeding the type size, and to avoid Borland
     C++ 6.0 warnings about condition always true for something like
     "ULONG_MAX < GMP_NUMB_MASK".  *//* The following are provided as inlines where possible, but always exist as
   library functions too, for binary compatibility.

   Within gmp itself this inlining generally isn't relied on, since it
   doesn't get done for all compilers, whereas if something is worth
   inlining then it's worth arranging always.

   There are two styles of inlining here.  When the same bit of code is
   wanted for the inline as for the library version, then __GMP_FORCE_foo
   arranges for that code to be emitted and the __GMP_EXTERN_INLINE
   directive suppressed, eg. mpz_fits_uint_p.  When a different bit of code
   is wanted for the inline than for the library version, then
   __GMP_FORCE_foo arranges the inline to be suppressed, eg. mpz_abs.  *//**************** mpz inlines ****************//* undocumented now, but retained here for upward compatibility *//* This is ugly, but we need to make user calls reach the prefixed function. *//************ Low level positive-integer (i.e. N) routines.  ************//**************** Float (i.e. F) routines.  ****************//**************** Rational (i.e. Q) routines.  ****************//* same as fdiv_r because divisor unsigned *//* alias *//* signed *//**************** Integer (i.e. Z) routines.  ****************//**************** Formatted input routines.  ****************//**************** Formatted output routines.  ****************//* obsolete *//**************** Random number routines.  ****************//* Allow direct user access to numerator and denominator of an mpq_t object.  *//* __builtin_expect is in gcc 3.0, and not in 2.95. *//* By default, don't give a prototype when there's going to be an inline
   version.  Note in particular that Cray C++ objects to the combination of
   prototype and inline.  *//* Don't do any inlining within a configure run, since if the compiler ends
   up emitting copies of the code into the object file it can end up
   demanding the various support routines (like mpn_popcount) for linking,
   making the "alloca" test and perhaps others fail.  And on hppa ia64 a
   pre-release gcc 3.2 was seen not respecting the "extern" in "extern
   __inline__", triggering this problem too.  *//* C++ always has "inline" and since it's a normal feature the linker should
   discard duplicate non-inlined copies, or if it doesn't then that's a
   problem for everyone, not just GMP.  *//* Somewhat older Sun C compilers want "static inline" *//* Recent enough Sun C compilers want "inline" *//* Microsoft's C compiler accepts __inline *//* SCO OpenUNIX 8 cc supports "static inline foo()" but not in -Xc strict
   ANSI mode (__STDC__ is 1 in that mode).  Inlining only actually takes
   place under -O.  Without -O "foo" seems to be emitted whether it's used
   or not, which is wasteful.  "extern inline foo()" isn't useful, the
   "extern" is apparently ignored, so foo is inlined if possible but also
   emitted as a global, which causes multiple definition errors when
   building a shared libgmp.  *//* DEC C (eg. version 5.9) supports "static __inline foo()", even in -std1
   strict ANSI mode.  Inlining is done even when not optimizing (ie. -O0
   mode, which is the default), but an unnecessary local copy of foo is
   emitted unless -O is used.  "extern __inline" is accepted, but the
   "extern" appears to be ignored, ie. it becomes a plain global function
   but which is inlined within its file.  Don't know if all old versions of
   DEC C supported __inline, but as a start let's do the right thing for
   current versions.  *//* gcc has __inline__ in all modes, including strict ansi.  Give a prototype
    for an inline too, so as to correctly specify "dllimport" on windows, in
    case the function is called rather than inlined.
    GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
    inline semantics, unless -fgnu89-inline is used.  *//* PORTME: What other compilers have a useful "extern inline"?  "static
   inline" would be an acceptable substitute if the compiler (or linker)
   discards unused statics.  *//* An empty "throw ()" means the function doesn't throw any C++ exceptions,
   this can save some stack frame info in applications.

   Currently it's given only on functions which never divide-by-zero etc,
   don't allocate memory, and are expected to never need to allocate memory.
   This leaves open the possibility of a C++ throw from a future GMP
   exceptions scheme.

   mpz_set_ui etc are omitted to leave open the lazy allocation scheme
   described in doc/tasks.html.  mpz_get_d etc are omitted to leave open
   exceptions for float overflows.

   Note that __GMP_NOTHROW must be given on any inlines the same as on their
   prototypes (for g++ at least, where they're used together).  Note also
   that g++ 3.0 demands that __GMP_NOTHROW is before other attributes like
   __GMP_ATTRIBUTE_PURE.  *//* __GMP_CAST allows us to use static_cast in C++, so our macros are clean
   to "g++ -Wold-style-cast".

   Casts in "extern inline" code within an extern "C" block don't induce
   these warnings, so __GMP_CAST only needs to be used on documented
   macros.  *//* "pure" is in gcc 2.96 and up, see "(gcc)Function Attributes".  Basically
   it means a function does nothing but examine its arguments and memory
   (global or via arguments) to generate a return value, but changes nothing
   and has no side-effects.  __GMP_NO_ATTRIBUTE_CONST_PURE lets
   tune/common.c etc turn this off when trying to write timing loops.  *//* Test for gcc >= maj.min, as per __GNUC_PREREQ in glibc *//* The prototypes for gmp_vprintf etc are provided only if va_list is defined,
   via an application having included <stdarg.h>.  Usually va_list is a typedef
   so can't be tested directly, but C99 specifies that va_start is a macro.

   <stdio.h> will define some sort of va_list for vprintf and vfprintf, but
   let's not bother trying to use that since it's not standard and since
   application uses for gmp_vprintf etc will almost certainly require the
   whole <stdarg.h> anyway.  *//* glibc <obstack.h> *//* In ISO C, if a prototype involving "struct obstack *" is given without
   that structure defined, then the struct is scoped down to just the
   prototype, causing a conflict if it's subsequently defined for real.  So
   only give prototypes if we've got obstack.h.  *//* musl *//* VMS *//* Sun C++ *//* QNX4 *//* Metrowerks *//* Apple MPW MrC *//* Microsoft *//* DJGPP *//* HPUX *//* IRIX *//* Borland *//* BSD, OSF *//* glibc, Sun, SCO *//* AIX *//* For reference, "defined(EOF)" cannot be used here.  In g++ 2.95.4,
   <iostream> defines EOF but not FILE.  *//* all other cases *//* compiling to go into a application which will link to a DLL libgmpxx *//* compiling to go into a DLL libgmpxx *//* ??? Should not pollute user name space with these ??? *//* Types for function declarations in gmp files.  *//* Pointer to function pointers structure.  *//* Currently unused. *//* _mp_d member points to state of the generator. *//* Random state struct.  *//* Linear congruential.  *//* Available random number generation algorithms.  *//* typedef __mpf_struct MP_FLOAT; *//* Pointer to the limbs.  *//* Exponent, in the base of `mp_limb_t'.  *//* abs(_mp_size) is the number of limbs the
				   last field points to.  If _mp_size is
				   negative this is a negative number.  *//* Max precision, in number of `mp_limb_t's.
				   Set by mpf_init and modified by
				   mpf_set_prec.  The area pointed to by the
				   _mp_d field contains `prec' + 1 limbs.  *//* gmp 1 source compatibility *//* plain `int' is much faster (48 bits) *//* __GNU_MP__ *//* Number of *limbs* allocated and pointed
				   to by the _mp_d field.  *//* For reference, note that the name __mpz_struct gets into C++ mangled
   function names, which means although the "__" suggests an internal, we
   must leave this name for binary compatibility.  *//* compiling to go into an application which will link to a DLL libgmp *//* compiling to go into a DLL libgmp *//* __GMP_DECLSPEC supports Windows DLL versions of libgmp, and is empty in
   all other circumstances.

   When compiling objects for libgmp, __GMP_DECLSPEC is an export directive,
   or when compiling for an application it's an import directive.  The two
   cases are differentiated by __GMP_WITHIN_GMP defined by the GMP Makefiles
   (and not defined from an application).

   __GMP_DECLSPEC_XX is similarly used for libgmpxx.  __GMP_WITHIN_GMPXX
   indicates when building libgmpxx, and in that case libgmpxx functions are
   exports, but libgmp functions which might get called are imports.

   Libtool DLL_EXPORT define is not used.

   There's no attempt to support GMP built both static and DLL.  Doing so
   would mean applications would have to tell us which of the two is going
   to be used when linking, and that seems very tedious and error prone if
   using GMP by hand, and equally tedious from a package since autoconf and
   automake don't give much help.

   __GMP_DECLSPEC is required on all documented global functions and
   variables, the various internals in gmp-impl.h etc can be left unadorned.
   But internals used by the test programs or speed measuring programs
   should have __GMP_DECLSPEC, and certainly constants or variables must
   have it or the wrong address will be resolved.

   In gcc __declspec can go at either the start or end of a prototype.

   In Microsoft C __declspec must go at the start, or after the type like
   void __declspec(...) *foo()".  There's no __dllexport or anything to
   guard against someone foolish #defining dllexport.  _export used to be
   available, but no longer.

   In Borland C _export still exists, but needs to go after the type, like
   "void _export foo();".  Would have to change the __GMP_DECLSPEC syntax to
   make use of that.  Probably more trouble than it's worth.  *//* #undef _LONG_LONG_LIMB *//* Instantiated by configure. *//* for size_t *//* for std::istream, std::ostream, std::string *//* Definitions for GNU multiple precision functions.   -*- mode: c -*-

Copyright 1991, 1993-1997, 1999-2016, 2020 Free Software Foundation, Inc.

This file is part of the GNU MP Library.

The GNU MP Library is free software; you can redistribute it and/or modify
it under the terms of either:

  * the GNU Lesser General Public License as published by the Free
    Software Foundation; either version 3 of the License, or (at your
    option) any later version.

or

  * the GNU General Public License as published by the Free Software
    Foundation; either version 2 of the License, or (at your option) any
    later version.

or both in parallel, as here.

The GNU MP Library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received copies of the GNU General Public License and the
GNU Lesser General Public License along with the GNU MP Library.  If not,
see https://www.gnu.org/licenses/.  *//usr/include/guile/2.0/libguile/__scm.hSCM___SCM_HSCM_GNUC_PREREQ (3, 0)!defined (SCM_BUILDING_DEPRECATED_CODE) && SCM_GNUC_PREREQ (3, 0)defined __GNUC__ || (defined( __SUNPRO_C ) && (__SUNPRO_C - 0 >= 0x590))defined __INTEL_COMPILERdefined BUILDING_LIBGUILE && defined HAVE_VISIBILITYdefined BUILDING_LIBGUILE && defined _MSC_VERdefined _MSC_VER(defined __GNUC__) && (!(((defined __APPLE_CC__) && (__APPLE_CC__ > 5400)) && __STDC_VERSION__ >= 199901L))(defined __GNUC_STDC_INLINE__) || (__GNUC__ == 4 && __GNUC_MINOR__ == 2)defined SCM_IMPLEMENT_INLINESdefined SCM_C_INLINESCM_C_EXTERN_INLINESCM_DEBUGSCM_DEBUG_MARKING_APISCM_DEBUG_CELL_ACCESSESSCM_DEBUG_INTERRUPTSSCM_DEBUG_PAIR_ACCESSESSCM_DEBUG_REST_ARGUMENTSCM_DEBUG_TYPING_STRICTNESSSCM_DEBUG_DEBUGGING_SUPPORTCHAR_BITLONG_BITBUILDING_LIBGUILEvmsCHEAP_CONTINUATIONS_CRAY1defined (__ia64__)SCM_I_SETJMPdefined (sparc) || defined (__sparc__) || defined (__sparc)THINK_CMSDOSataristSHORT_ALIGNdefined (__INTEL_COMPILER) && defined (__ia64)SCM_RECKLESSSCM_MAGIC_SNARFERSCM_EXIT_SUCCESSSCM_EXIT_FAILURE/*
  Local Variables:
  c-file-style: "gnu"
  End:
*//* SCM___SCM_H *//* Handling thread-local storage (TLS).  *//* Define SCM_C_INLINE_KEYWORD so that it can be used as a replacement
   for the "inline" keyword, expanding to nothing when "inline" is not
   available.
*//* ndef SCM_EXIT_FAILURE *//* def vms *//* ndef SCM_EXIT_SUCCESS *//* SCM_EXIT_SUCCESS is the default code to return from SCM if no errors
 * were encountered.  SCM_EXIT_FAILURE is the default code to return from
 * SCM if errors were encountered.  The return code can be explicitly
 * specified in a SCM program with (scm_quit <n>).
 *//* SCM_MAGIC_SNARFER *//* Let these macros pass through if
   we are snarfing;  thus we can tell the
   difference between the use of an actual
   number vs. the use of one of these macros --
   actual numbers in SCM_VALIDATE_* and SCM_ASSERT
   constructs must match the formal argument name,
   but using SCM_ARG* avoids the test *//* This form is for dispatching a subroutine.  *//* Dirk:FIXME:: In all of the SCM_WTA_DISPATCH_* macros it is assumed that
 * 'gf' is zero if uninitialized.  It would be cleaner if some valid SCM value
 * like SCM_BOOL_F or SCM_UNDEFINED was chosen.
 *//*
 * SCM_WTA_DISPATCH
 *//** SCM_ASSERT
 **
 **//* volatile *//* Anthony Green writes:
   When the compiler sees...
	   DEFER_INTS;
	   [critical code here]
	   ALLOW_INTS;
   ...it doesn't actually promise to keep the critical code within the
   boundries of the DEFER/ALLOW_INTS instructions. It may very well
   schedule it outside of the magic defined in those macros.

   However, GCC's volatile asm feature forms a barrier over which code is
   never moved. So if you add...
	   asm ("");
   ...to each of the DEFER_INTS and ALLOW_INTS macros, the critical
   code will always remain in place.  asm's without inputs or outputs
   are implicitly volatile. *//* !BUILDING_LIBGUILE *//* SCM_ASYNC_TICK_WITH_CODE is only available to Guile itself *//* FIXME: should change names *//* Cast pointer through (void *) in order to avoid compiler warnings
   when strict aliasing is enabled *//* #define SHORT_ALIGN *//* If stack is not longword aligned then
 *//* empty *//* James Clark came up with this neat one instruction fix for
 * continuations on the SPARC.  It flushes the register windows so
 * that all the state of the process is contained in the stack.
 *//* For any platform where SCM_I_SETJMP hasn't been defined in some
   special way above, map SCM_I_SETJMP, SCM_I_LONGJMP and
   scm_i_jmp_buf to setjmp, longjmp and jmp_buf. *//* ndef vms *//* ndef _CRAY1 *//* ndef __ia64__ *//* For IA64, emulate the setjmp API using getcontext. *//* The type of subrs, i.e., Scheme procedures implemented in C.  Empty
   function declarators are used internally for pointers to functions of
   any arity.  However, these are equivalent to `(void)' in C++, are
   obsolescent as of C99, and trigger `strict-prototypes' GCC warnings
   (bug #23681).  *//* {Architecture and compiler properties}
 *
 * Guile as of today can only work on systems which fulfill at least the
 * following requirements:
 *
 * - scm_t_bits and SCM variables have at least 32 bits.
 *   Guile's type system is based on this assumption.
 *
 * - sizeof (scm_t_bits) >= sizeof (void*) and sizeof (SCM) >= sizeof (void*)
 *   Guile's type system is based on this assumption, since it must be
 *   possible to store pointers to cells on the heap in scm_t_bits and SCM
 *   variables.
 *
 * - sizeof (scm_t_bits) >= 4 and sizeof (scm_t_bits) is a power of 2.
 *   Guile's type system is based on this assumption.  In particular, it is
 *   assumed that cells, i. e. pairs of scm_t_bits variables, are eight
 *   character aligned.  This is because three bits of a scm_t_bits variable
 *   that is holding a pointer to a cell on the heap must be available for
 *   storing type data.
 *
 * - sizeof (scm_t_bits) <= sizeof (void*) and sizeof (SCM) <= sizeof (void*)
 *   In some parts of guile, scm_t_bits and SCM variables are passed to
 *   functions as void* arguments.  Together with the requirement above, this
 *   requires a one-to-one correspondence between the size of a void* and the
 *   sizes of scm_t_bits and SCM variables.
 *
 * - numbers are encoded using two's complement.
 *   The implementation of the bitwise scheme level operations is based on
 *   this assumption.
 *
 * - ... add more
 *//* If SCM_ENABLE_DEPRECATED is set to 1, deprecated code will be included in
 * guile, as well as some functions to issue run-time warnings about uses of
 * deprecated functions.
 *//* {Feature Options}
 *
 * These compile time options determine whether code for certain features
 * should be compiled into guile.  The common prefix for all option macros
 * of this kind is "SCM_ENABLE_".  It is guaranteed that a macro named
 * SCM_ENABLE_XXX is defined to be either 0 or 1, i. e. there is no need to
 * test for the undefined case.  This allows to use these definitions
 * comfortably within code, as in the following example:
 *   #define FOO do { if (SCM_ENABLE_XXX) bar(); else baz(); } while (0)
 * Any sane compiler will remove the unused branch without any performance
 * penalty for the resulting code.
 *
 * Note:  Some SCM_ENABLE_XXX options are not settable at configure time.
 * To change the value of such options you will have to edit this header
 * file or give suitable options to make, like:
 *   make all CFLAGS="-DSCM_ENABLE_XXX=1 ..."
 *//* If SCM_DEBUG_DEBUGGING_SUPPORT is set to 1, guile will provide a set of
 * special functions that support debugging with a debugger like gdb or
 * debugging of guile internals on the scheme level.  The behaviour of guile
 * is not changed by this macro, only the set of functions that are available
 * will differ.  All functions that are introduced this way have the prefix
 * 'scm_dbg_' on the C level and the prefix 'dbg-' on the scheme level.  This
 * allows to easily determine the set of support functions, given that your
 * debugger or repl provide automatic name completion.  Note that these
 * functions are intended to be used during interactive debugging sessions
 * only.  They are not considered part of guile's official API.  They may
 * change or disappear without notice or deprecation phase.
 *//* The macro SCM_DEBUG_TYPING_STRICTNESS indicates what level of type checking
 * shall be performed with respect to the use of the SCM datatype.  The macro
 * may be defined to one of the values 0, 1 and 2.
 *
 * A value of 0 means that there will be no compile time type checking, since
 * the SCM datatype will be declared as an integral type.  This setting should
 * only be used on systems, where casting from integral types to pointers may
 * lead to loss of bit information.
 *
 * A value of 1 means that there will an intermediate level of compile time
 * type checking, since the SCM datatype will be declared as a pointer to an
 * undefined struct.  This setting is the default, since it does not cost
 * anything in terms of performance or code size.
 *
 * A value of 2 provides a maximum level of compile time type checking since
 * the SCM datatype will be declared as a struct.  This setting should be used
 * for _compile time_ type checking only, since the compiled result is likely
 * to be quite inefficient.  The right way to make use of this option is to do
 * a 'make clean; make CFLAGS=-DSCM_DEBUG_TYPING_STRICTNESS=2', fix your
 * errors, and then do 'make clean; make'.
 *//* If SCM_DEBUG_REST_ARGUMENT is set to 1, functions that take rest arguments
 * will check whether the rest arguments are actually passed as a proper list.
 * Otherwise, if SCM_DEBUG_REST_ARGUMENT is 0, functions that take rest
 * arguments will take it for granted that these are passed as a proper list.
 *//* If SCM_DEBUG_PAIR_ACCESSES is set to 1, accesses to cons cells will be
 * exhaustively checked.  Note:  If this option is enabled, guile will run
 * slower than normally.
 *//* If SCM_DEBUG_INTERRUPTS is set to 1, with every deferring and allowing of
 * interrupts a consistency check will be performed.
 *//* If SCM_DEBUG_CELL_ACCESSES is set to 1, cell accesses will perform
 * exhaustive parameter checking:  It will be verified that cell parameters
 * actually point to a valid heap cell.  Note:  If this option is enabled,
 * guile will run about ten times slower than normally.
 *//* For debugging purposes: define this is to ensure nobody is using
 * the mark bits outside of the marking phase.  This is meant for
 * debugging purposes only.
 *//* The value of SCM_DEBUG determines the default for most of the not yet
 * defined debugging options.  This allows, for example, to enable most of the
 * debugging options by simply defining SCM_DEBUG as 1.
 *//* {Debugging Options}
 *
 * These compile time options determine whether to include code that is only
 * useful for debugging guile itself or C level extensions to guile.  The
 * common prefix for all option macros of this kind is "SCM_DEBUG_".  It is
 * guaranteed that a macro named SCM_DEBUG_XXX is always defined (typically to
 * either 0 or 1), i. e. there is no need to test for the undefined case.
 * This allows to use these definitions comfortably within code, as in the
 * following example:
 *   #define FOO do { if (SCM_DEBUG_XXX) bar(); else baz(); } while (0)
 * Any sane compiler will remove the unused branch without any performance
 * penalty for the resulting code.
 *
 * Note:  Some SCM_DEBUG_XXX options are not settable at configure time.
 * To change the value of such options you will have to edit this header
 * file or give suitable options to make, like:
 *   make all CFLAGS="-DSCM_DEBUG_XXX=1 ..."
 *//* Don't define SCM_INLINE_IMPLEMENTATION; it should never be seen in
   this case.  *//* Declarations when inlining is not available.  *//* Fall back to static inline if GNU "extern inline" is unavailable.  *//* Declarations when inlining is available.  *//* Reifying functions to a file, whether or not inlining is available.  *//* SCM_INLINE is a macro prepended to all public inline function
   declarations.  Implementations of those functions should also be in
   the header file, prefixed by SCM_INLINE_IMPLEMENTATION, and protected
   by SCM_CAN_INLINE and a CPP define for the C file in question, like
   SCM_INLINE_C_INCLUDING_INLINE_H.  See inline.h for an example
   usage.  *//* We would like gnu89 extern inline semantics, not C99 extern inline
   semantics, so that we can be sure to avoid reifying definitions of
   inline functions in all compilation units, which is a possibility at
   low optimization levels, or if a user takes the address of an inline
   function.

   Hence the `__gnu_inline__' attribute, in accordance with:
   http://gcc.gnu.org/gcc-4.3/porting_to.html .

   With GCC 4.2, `__GNUC_STDC_INLINE__' is never defined (because C99 inline
   semantics are not supported), but a warning is issued in C99 mode if
   `__gnu_inline__' is not used.

   Apple's GCC build >5400 (since Xcode 3.0) doesn't support GNU inline in
   C99 mode and doesn't define `__GNUC_STDC_INLINE__'.  Fall back to "static
   inline" in that case.  *//* SCM_API is a macro prepended to all function and data definitions
   which should be exported from libguile. *//* Random options (not yet supported or in final form). *//* Guile Scheme supports the #f/() distinction; Guile Lisp won't.  We
   have horrible plans for their unification.  *//* {Unsupported Options}
 *
 * These must be defined as given here.
 *//* Use engineering notation when converting numbers strings?
 *//* #define GUILE_DEBUG_FREELIST *//* {Supported Options}
 *
 * These may be defined or undefined.
 *//* The SCM_MALLOC macro can be used in function declarations to tell the
 * compiler that a function may be treated as if any non-NULL pointer it returns
 * cannot alias any other pointer valid when the function returns.  *//* Don't know how to align things.  *//* Sun Studio supports alignment since Sun Studio 12 *//* The SCM_ALIGNED macro, when defined, can be used to instruct the compiler
 * to honor the given alignment constraint.  *//* The SCM_DEPRECATED macro is used in declarations of deprecated functions
 * or variables.  Defining `SCM_BUILDING_DEPRECATED_CODE' allows deprecated
 * functions to be implemented in terms of deprecated functions, and allows
 * deprecated functions to be referred to by `scm_c_define_gsubr ()'.  *//* The SCM_INTERNAL macro makes it possible to explicitly declare a function
 * as having "internal" linkage.  However our current tack on this problem is
 * to use GCC 4's -fvisibility=hidden, making functions internal by default,
 * and then SCM_API marks them for export. *//* The SCM_EXPECT macros provide branch prediction hints to the compiler.  To
 * use only in places where the result of the expression under "normal"
 * circumstances is known.  *//* The macro SCM_UNUSED indicates that a function, function argument or
 * variable may potentially be unused.
 * Examples:
 *   1) static int unused_function (char arg) SCM_UNUSED;
 *   2) int foo (char unused_argument SCM_UNUSED);
 *   3) int unused_variable SCM_UNUSED;
 *//* The macro SCM_NORETURN indicates that a function will never return.
 * Examples:
 *   1) int foo (char arg) SCM_NORETURN;
 *//* Return true (non-zero) if GCC version MAJ.MIN or later is being used
 * (macro taken from glibc.)  *//* {Compiler hints}
 *
 * The following macros are used to provide additional information for the
 * compiler, which may help to do better error checking and code
 * optimization.  A second benefit of these macros is, that they also provide
 * additional information to the developers.
 *//* What did the configure script discover about the outside world?  *//**********************************************************************
 This file is Guile's central public header.

 When included by other files, this file should preceed any include
 other than __scm.h.

 Under *NO* circumstances should new items be added to the global
 namespace (via adding #define, typedef, or similar to this file) with
 generic names.  This usually means that any new names should be
 prefixed by either SCM_ or GUILE_.  i.e. do *not* #define HAVE_FOO or
 SIZEOF_BAR.  See configure.in, gen-scmconfig.h.in, and
 gen-scmconfig.c for examples of how to properly handle this issue.
 The main documentation is in gen-scmconfig.c.

 "What's the difference between _scm.h and __scm.h?"

   _scm.h is not installed; it's only visible to the libguile sources
   themselves, and it includes config.h, the private config header.

   __scm.h is installed, and is #included by <libguile.h>.  If both
   the client and libguile need some piece of information, and it
   doesn't fit well into the header file for any particular module, it
   should go in __scm.h.  __scm.h includes scmconfig.h, the public
   config header.
 **********************************************************************//* Copyright (C) 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2006,
 *   2007, 2008, 2009, 2010, 2011, 2012, 2013 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//* classes: h_files *//usr/include/guile/2.0/libguile/tags.h"libguile/__scm.h"scm_tc8_tagsscm_tc8_flagscm_tc3_imm240x00scm_tc8_char0x08scm_tc8_unused_0160x1020scm_tc8_unused_1240x1828scm_unused_struct *SCMscm_unused_structscm_t_bitsscm_t_signed_bitsscm_unused_fieldSCM_NCELLP(x)(!SCM_CELLP (x))SCM_CELLP(x)(((sizeof (scm_t_cell) - 1) & SCM_UNPACK (x)) == 0)scm_tcs_structscm_tc3_struct + 0: case scm_tc3_struct + 8: case scm_tc3_struct + 16: case scm_tc3_struct + 24: case scm_tc3_struct + 32: case scm_tc3_struct + 40: case scm_tc3_struct + 48: case scm_tc3_struct + 56: case scm_tc3_struct + 64: case scm_tc3_struct + 72: case scm_tc3_struct + 80: case scm_tc3_struct + 88: case scm_tc3_struct + 96: case scm_tc3_struct + 104: case scm_tc3_struct + 112: case scm_tc3_struct + 120scm_tcs_cons_nimcarscm_tc3_cons + 0: case scm_tc3_cons + 8: case scm_tc3_cons + 16: case scm_tc3_cons + 24: case scm_tc3_cons + 32: case scm_tc3_cons + 40: case scm_tc3_cons + 48: case scm_tc3_cons + 56: case scm_tc3_cons + 64: case scm_tc3_cons + 72: case scm_tc3_cons + 80: case scm_tc3_cons + 88: case scm_tc3_cons + 96: case scm_tc3_cons + 104: case scm_tc3_cons + 112: case scm_tc3_cons + 120scm_tcs_cons_imcarscm_tc2_int + 0: case scm_tc2_int + 4: case scm_tc3_imm24 + 0: case scm_tc2_int + 8: case scm_tc2_int + 12: case scm_tc3_imm24 + 8: case scm_tc2_int + 16: case scm_tc2_int + 20: case scm_tc3_imm24 + 16: case scm_tc2_int + 24: case scm_tc2_int + 28: case scm_tc3_imm24 + 24: case scm_tc2_int + 32: case scm_tc2_int + 36: case scm_tc3_imm24 + 32: case scm_tc2_int + 40: case scm_tc2_int + 44: case scm_tc3_imm24 + 40: case scm_tc2_int + 48: case scm_tc2_int + 52: case scm_tc3_imm24 + 48: case scm_tc2_int + 56: case scm_tc2_int + 60: case scm_tc3_imm24 + 56: case scm_tc2_int + 64: case scm_tc2_int + 68: case scm_tc3_imm24 + 64: case scm_tc2_int + 72: case scm_tc2_int + 76: case scm_tc3_imm24 + 72: case scm_tc2_int + 80: case scm_tc2_int + 84: case scm_tc3_imm24 + 80: case scm_tc2_int + 88: case scm_tc2_int + 92: case scm_tc3_imm24 + 88: case scm_tc2_int + 96: case scm_tc2_int + 100: case scm_tc3_imm24 + 96: case scm_tc2_int + 104: case scm_tc2_int + 108: case scm_tc3_imm24 + 104: case scm_tc2_int + 112: case scm_tc2_int + 116: case scm_tc3_imm24 + 112: case scm_tc2_int + 120: case scm_tc2_int + 124: case scm_tc3_imm24 + 120SCM_MATCHES_BITS_IN_COMMON(x,a,b)((SCM_UNPACK(x) & ~(SCM_UNPACK(a) ^ SCM_UNPACK(b))) == (SCM_UNPACK(a) & SCM_UNPACK(b)))SCM_UNBNDP(x)(scm_is_eq ((x), SCM_UNDEFINED))SCM_UNBOUNDSCM_PACK (SCM_UNBOUND_BITS)SCM_UNBOUND_BITSSCM_MAKIFLAG_BITS (11)SCM_EOF_VALSCM_PACK (SCM_EOF_VAL_BITS)SCM_UNDEFINEDSCM_PACK (SCM_UNDEFINED_BITS)SCM_UNSPECIFIEDSCM_PACK (SCM_UNSPECIFIED_BITS)SCM_EOF_VAL_BITSSCM_MAKIFLAG_BITS (10)SCM_UNDEFINED_BITSSCM_MAKIFLAG_BITS (9)SCM_UNSPECIFIED_BITSSCM_MAKIFLAG_BITS (8)SCM_BOOL_TSCM_PACK (SCM_BOOL_T_BITS)SCM_EOLSCM_PACK (SCM_EOL_BITS)SCM_BOOL_T_BITSSCM_MAKIFLAG_BITS (4)SCM_EOL_BITSSCM_MAKIFLAG_BITS (3)SCM_ELISP_NILSCM_PACK (SCM_ELISP_NIL_BITS)SCM_BOOL_FSCM_PACK (SCM_BOOL_F_BITS)SCM_ELISP_NIL_BITSSCM_MAKIFLAG_BITS (1)SCM_BOOL_F_BITSSCM_MAKIFLAG_BITS (0)SCM_IFLAGNUM(n)(SCM_ITAG8_DATA (n))SCM_MAKIFLAG_BITS(n)(SCM_MAKE_ITAG8_BITS ((n), scm_tc8_flag))SCM_IFLAGP(n)(SCM_ITAG8 (n) == scm_tc8_flag)SCM_ITAG8_DATA(X)(SCM_UNPACK (X) >> 8)SCM_MAKE_ITAG8(X,TAG)(SCM_PACK (SCM_MAKE_ITAG8_BITS (X, TAG)))SCM_MAKE_ITAG8_BITS(X,TAG)(((X) << 8) + TAG)SCM_ITAG8(X)(SCM_UNPACK (X) & 0xff)SCM_TYP16_PREDICATE(tag,x)(!SCM_IMP (x) && SCM_TYP16 (x) == (tag))SCM_TYP16(x)(0xffff & SCM_CELL_TYPE (x))scm_tc7_smob127scm_tc7_port125scm_tc7_unused_16119scm_tc7_unused_15117scm_tc7_unused_14111scm_tc7_unused_13109scm_tc7_unused_18103scm_tc7_unused_12101scm_tc7_unused_1195scm_tc7_unused_2093scm_tc7_bitvector87scm_tc7_array85scm_tc7_program79scm_tc7_unused_1969scm_tc7_with_fluids63scm_tc7_prompt61scm_tc7_vm_cont71scm_tc7_vm55scm_tc7_objcode53scm_tc7_frame47scm_tc7_dynamic_state45scm_tc7_fluid37scm_tc7_hashtable29scm_tc7_pointer31scm_tc7_bytevector77scm_tc7_stringbuf39scm_tc7_number23scm_tc7_string21scm_tc7_wvect15scm_tc7_vector13scm_tc7_variablescm_tc7_symbol5SCM_TYP7S(x)((0x7f & ~2) & SCM_CELL_TYPE (x))SCM_TYP7(x)(0x7f & SCM_CELL_TYPE (x))SCM_ITAG7(x)(127 & SCM_UNPACK (x))scm_tc3_tc7_2scm_tc3_int_2(scm_tc2_int + 4)scm_tc3_tc7_1scm_tc3_unusedscm_tc3_int_1(scm_tc2_int + 0)scm_tc3_structscm_tc3_consSCM_TYP3(x)(7 & SCM_CELL_TYPE (x))SCM_ITAG3(x)(7 & SCM_UNPACK (x))scm_tc2_intSCM_I_CONSP(x)(!SCM_IMP (x) && ((1 & SCM_CELL_TYPE (x)) == 0))SCM_NIMP(x)(!SCM_IMP (x))SCM_IMP(x)(6 & SCM_UNPACK (x))scm_is_eq(x,y)(SCM_UNPACK (x) == SCM_UNPACK (y))SCM_PACK(x)((SCM) (x))SCM_UNPACK(x)((scm_t_bits) (0? (*(volatile SCM *)0=(x)): x))SCM_T_BITS_MAXSCM_T_UINTPTR_MAXSCM_T_SIGNED_BITS_MINSCM_T_INTPTR_MINSCM_T_SIGNED_BITS_MAXSCM_T_INTPTR_MAXSCM_TAGS_H(SCM_DEBUG_TYPING_STRICTNESS == 2)(SCM_DEBUG_TYPING_STRICTNESS == 1)defined __DECC || defined __HP_cc(SCM_ENABLE_DEPRECATED == 1)/* SCM_TAGS_H *//* For structs
 *//* For cons pairs with non-immediate values in the SCM_CAR
 *//* For cons pairs with immediate values in the CAR
 *//* Dispatching aids:

   When switching on SCM_TYP7 of a SCM value, use these fake case
   labels to catch types that use fewer than 7 bits for tagging.  *//* BUILDING_LIBGUILE *//*
 * These macros are used for compile-time verification that the
 * constants have the properties needed for the above macro to work
 * properly.
 *//*
 * SCM_MATCHES_BITS_IN_COMMON(x,a,b) returns 1 if and only if x
 * matches both a and b in every bit position where a and b are equal;
 * otherwise it returns 0.  Bit positions where a and b differ are
 * ignored.
 *
 * This is used to efficiently compare against two values which differ
 * in exactly one bit position, or against four values which differ in
 * exactly two bit positions.  It is the basis for the following
 * macros:
 *
 *   scm_is_null_or_nil,
 *   scm_is_false_or_nil,
 *   scm_is_true_and_not_nil,
 *   scm_is_lisp_false,
 *   scm_is_lisp_true,
 *   scm_is_bool_and_not_nil (aka scm_is_bool)
 *   scm_is_bool_or_nil.
 *//* When a variable is unbound this is marked by the SCM_UNDEFINED
 * value.  The following is an unbound value which can be handled on
 * the Scheme level, i.e., it can be stored in and retrieved from a
 * Scheme variable.  This value is only intended to mark an unbound
 * slot in GOOPS.  It is needed now, but we should probably rewrite
 * the code which handles this value in C so that SCM_UNDEFINED can be
 * used instead.  It is not ideal to let this kind of unique and
 * strange values loose on the Scheme level.  *//*
 * IMPORTANT NOTE regarding IFLAG numbering!!!
 *
 * Several macros depend upon careful IFLAG numbering of SCM_BOOL_F,
 * SCM_BOOL_T, SCM_ELISP_NIL, SCM_EOL, and the two SCM_XXX_*_DONT_USE
 * constants.  In particular:
 *
 * - SCM_BOOL_F and SCM_BOOL_T must differ in exactly one bit position.
 *   (used to implement scm_is_bool_and_not_nil, aka scm_is_bool)
 *
 * - SCM_ELISP_NIL and SCM_BOOL_F must differ in exactly one bit position.
 *   (used to implement scm_is_false_or_nil and
 *    scm_is_true_and_not_nil)
 *
 * - SCM_ELISP_NIL and SCM_EOL must differ in exactly one bit position.
 *   (used to implement scm_is_null_or_nil)
 *
 * - SCM_ELISP_NIL, SCM_BOOL_F, SCM_EOL, SCM_XXX_ANOTHER_LISP_FALSE_DONT_USE
 *   must all be equal except for two bit positions.
 *   (used to implement scm_is_lisp_false)
 *
 * - SCM_ELISP_NIL, SCM_BOOL_F, SCM_BOOL_T, SCM_XXX_ANOTHER_BOOLEAN_DONT_USE_0
 *   must all be equal except for two bit positions.
 *   (used to implement scm_is_bool_or_nil)
 *
 * These properties allow the aforementioned macros to be implemented
 * by bitwise ANDing with a mask and then comparing with a constant,
 * using as a common basis the macro SCM_MATCHES_BITS_IN_COMMON,
 * defined below.  The properties are checked at compile-time using
 * `verify' macros near the top of boolean.c and pairs.c.
 *//* Flags (special objects).  The indices of the flags must agree with the
 * declarations in print.c: iflagnames.  *//* characters *//* special objects ('flags') *//* {Immediate Values}
 *//* Definitions for tc16: *//* DO NOT CHANGE [**] *//* There are 256 smob subtypes.  [**] If you change scm_tc7_smob, you must
 * also change the places it is hard coded in this file and possibly others.
 * Dirk:FIXME:: Any hard coded reference to scm_tc7_smob must be replaced by a
 * symbolic reference.  *//* There are 256 port subtypes.  *//* couple *//* Definitions for tc7: *//* Definitions for tc3: *//* Definitions for tc2: *//* Checking if a SCM variable holds a pair (for historical reasons, in Guile
 * also known as a cons-cell): This is done by first checking that the SCM
 * variable holds a non-immediate, and second, by checking that tc1==0 holds
 * for the SCM_CELL_TYPE of the SCM variable.  
*//* Checking if a SCM variable holds an immediate integer: See numbers.h for
 * the definition of the following macros: SCM_I_FIXNUM_BIT,
 * SCM_MOST_POSITIVE_FIXNUM, SCM_I_INUMP, SCM_I_MAKINUM, SCM_I_INUM.  *//* Checking if a SCM variable holds an immediate or a non-immediate object:
 * This check can either be performed by checking for tc3==000 or tc3==00x,
 * since for a SCM variable it is known that tc1==0.  *//* Representation of scheme objects:
 *
 * Guile's type system is designed to work on systems where scm_t_bits and SCM
 * variables consist of at least 32 bits.  The objects that a SCM variable can
 * represent belong to one of the following two major categories:
 *
 * - Immediates -- meaning that the SCM variable contains an entire Scheme
 *   object.  That means, all the object's data (including the type tagging
 *   information that is required to identify the object's type) must fit into
 *   32 bits.
 *
 * - Non-immediates -- meaning that the SCM variable holds a pointer into the
 *   heap of cells (see below).  On systems where a pointer needs more than 32
 *   bits this means that scm_t_bits and SCM variables need to be large enough
 *   to hold such pointers.  In contrast to immediates, the object's data of
 *   a non-immediate can consume arbitrary amounts of memory: The heap cell
 *   being pointed to consists of at least two scm_t_bits variables and thus
 *   can be used to hold pointers to malloc'ed memory of any size.
 *
 * The 'heap' is the memory area that is under control of Guile's garbage
 * collector.  It holds 'single-cells' or 'double-cells', which consist of
 * either two or four scm_t_bits variables, respectively.  It is guaranteed
 * that the address of a cell on the heap is 8-byte aligned.  That is, since
 * non-immediates hold a cell address, the three least significant bits of a
 * non-immediate can be used to store additional information.  The bits are
 * used to store information about the object's type and thus are called
 * tc3-bits, where tc stands for type-code.  
 *
 * For a given SCM value, the distinction whether it holds an immediate or
 * non-immediate object is based on the tc3-bits (see above) of its scm_t_bits
 * equivalent: If the tc3-bits equal #b000, then the SCM value holds a
 * non-immediate, and the scm_t_bits variable's value is just the pointer to
 * the heap cell.
 *
 * Summarized, the data of a scheme object that is represented by a SCM
 * variable consists of a) the SCM variable itself, b) in case of
 * non-immediates the data of the single-cell or double-cell the SCM object
 * points to, c) in case of non-immediates potentially additional data outside
 * of the heap (like for example malloc'ed data), and d) in case of
 * non-immediates potentially additional data inside of the heap, since data
 * stored in b) and c) may hold references to other cells.
 *
 *
 * Immediates
 *
 * Operations on immediate objects can typically be processed faster than on
 * non-immediates.  The reason is that the object's data can be extracted
 * directly from the SCM variable (or rather a corresponding scm_t_bits
 * variable), instead of having to perform additional memory accesses to
 * obtain the object's data from the heap.  In order to get the best possible
 * performance frequently used data types should be realized as immediates.
 * This is, as has been mentioned above, only possible if the objects can be
 * represented with 32 bits (including type tagging).
 *
 * In Guile, the following data types and special objects are realized as
 * immediates: booleans, characters, small integers (see below), the empty
 * list, the end of file object, the 'unspecified' object (which is delivered
 * as a return value by functions for which the return value is unspecified),
 * a 'nil' object used in the elisp-compatibility mode and certain other
 * 'special' objects which are only used internally in Guile.
 *
 * Integers in Guile can be arbitrarily large.  On the other hand, integers
 * are one of the most frequently used data types.  Especially integers with
 * less than 32 bits are commonly used.  Thus, internally and transparently
 * for application code guile distinguishes between small and large integers.
 * Whether an integer is a large or a small integer depends on the number of
 * bits needed to represent its value.  Small integers are those which can be
 * represented as immediates.  Since they don't require more than a fixed
 * number of bits for their representation, they are also known as 'fixnums'.
 *
 * The tc3-combinations #b010 and #b110 are used to represent small integers,
 * which allows to use the most significant bit of the tc3-bits to be part of
 * the integer value being represented.  This means that all integers with up
 * to 30 bits (including one bit for the sign) can be represented as
 * immediates.  On systems where SCM and scm_t_bits variables hold more than
 * 32 bits, the amount of bits usable for small integers will even be larger.
 * The tc3-code #b100 is shared among booleans, characters and the other
 * special objects listed above.
 *
 *
 * Non-Immediates
 *
 * All object types not mentioned above in the list of immedate objects are
 * represented as non-immediates.  Whether a non-immediate scheme object is
 * represented by a single-cell or a double-cell depends on the object's type,
 * namely on the set of attributes that have to be stored with objects of that
 * type.  Every non-immediate type is allowed to define its own layout and
 * interpretation of the data stored in its cell (with some restrictions, see
 * below).
 *
 * One of the design goals of guile's type system is to make it possible to
 * store a scheme pair with as little memory usage as possible.  The minimum
 * amount of memory that is required to store two scheme objects (car and cdr
 * of a pair) is the amount of memory required by two scm_t_bits or SCM
 * variables.  Therefore pairs in guile are stored in single-cells.
 *
 * Another design goal for the type system is to store procedure objects
 * created by lambda expresssions (closures) and class instances (goops
 * objects) with as little memory usage as possible.  Closures are represented
 * by a reference to the function code and a reference to the closure's
 * environment.  Class instances are represented by a reference to the
 * instance's class definition and a reference to the instance's data.  Thus,
 * closures as well as class instances also can be stored in single-cells.
 *
 * Certain other non-immediate types also store their data in single-cells.
 * By design decision, the heap is split into areas for single-cells and
 * double-cells, but not into areas for single-cells-holding-pairs and areas
 * for single-cells-holding-non-pairs.  Any single-cell on the heap therefore
 * can hold pairs (consisting of two scm_t_bits variables representing two
 * scheme objects - the car and cdr of the pair) and non-pairs (consisting of
 * two scm_t_bits variables that hold bit patterns as defined by the layout of
 * the corresponding object's type).
 *
 *
 * Garbage collection
 *
 * During garbage collection, unreachable cells on the heap will be freed.
 * That is, the garbage collector will detect cells which have no SCM variable
 * pointing towards them.  In order to properly release all memory belonging
 * to the object to which a cell belongs, the gc needs to be able to interpret
 * the cell contents in the correct way.  That means that the gc needs to be
 * able to determine the object type associated with a cell only from the cell
 * itself.
 *
 * Consequently, if the gc detects an unreachable single-cell, those two
 * scm_t_bits variables must provide enough information to determine whether
 * they belong to a pair (i. e. both scm_t_bits variables represent valid
 * scheme objects), to a closure, a class instance or if they belong to any
 * other non-immediate.  Guile's type system is designed to make it possible
 * to determine a the type to which a cell belongs in the majority of cases
 * from the cell's first scm_t_bits variable.  (Given a SCM variable X holding
 * a non-immediate object, the macro SCM_CELL_TYPE(X) will deliver the
 * corresponding cell's first scm_t_bits variable.)
 *
 * If the cell holds a scheme pair, then we already know that the first
 * scm_t_bits variable of the cell will hold a scheme object with one of the
 * following tc3-codes: #b000 (non-immediate), #b010 (small integer), #b110
 * (small integer), #b100 (non-integer immediate).  All these tc3-codes have
 * in common, that their least significant bit is #b0.  This fact is used by
 * the garbage collector to identify cells that hold pairs.  The remaining
 * tc3-codes are assigned as follows: #b001 (class instance or, more
 * precisely, a struct, of which a class instance is a special case), #b011
 * (closure), #b101/#b111 (all remaining non-immediate types).
 *
 *
 * Summary of type codes of scheme objects (SCM variables)
 *
 * Here is a summary of tagging bits as they might occur in a scheme object.
 * The notation is as follows: tc stands for type code as before, tc<n> with n
 * being a number indicates a type code formed by the n least significant bits
 * of the SCM variables corresponding scm_t_bits value.
 *
 * Note that (as has been explained above) tc1==1 can only occur in the first
 * scm_t_bits variable of a cell belonging to a non-immediate object that is
 * not a pair.  For an explanation of the tc tags with tc1==1, see the next
 * section with the summary of the type codes on the heap.
 *
 * tc1:
 *   0:  For scheme objects, tc1==0 must be fulfilled.
 *  (1:  This can never be the case for a scheme object.)
 *
 * tc2:
 *   00:  Either a non-immediate or some non-integer immediate
 *  (01:  This can never be the case for a scheme object.)
 *   10:  Small integer
 *  (11:  This can never be the case for a scheme object.)
 *
 * tc3:
 *   000:  a non-immediate object (pair, closure, class instance etc.)
 *  (001:  This can never be the case for a scheme object.)
 *   010:  an even small integer (least significant bit is 0).
 *  (011:  This can never be the case for a scheme object.)
 *   100:  Non-integer immediate
 *  (101:  This can never be the case for a scheme object.)
 *   110:  an odd small integer (least significant bit is 1).
 *  (111:  This can never be the case for a scheme object.)
 *
 * The remaining bits of the non-immediate objects form the pointer to the
 * heap cell.  The remaining bits of the small integers form the integer's
 * value and sign.  Thus, the only scheme objects for which a further
 * subdivision is of interest are the ones with tc3==100.
 *
 * tc8 (for objects with tc3==100):
 *   00000-100:  special objects ('flags')
 *   00001-100:  characters
 *   00010-100:  unused
 *   00011-100:  unused
 *
 *
 * Summary of type codes on the heap
 *
 * Here is a summary of tagging in scm_t_bits values as they might occur in
 * the first scm_t_bits variable of a heap cell.
 *
 * tc1:
 *   0:  the cell belongs to a pair.
 *   1:  the cell belongs to a non-pair.
 *
 * tc2:
 *   00:  the cell belongs to a pair with no short integer in its car.
 *   01:  the cell belongs to a non-pair (struct or some other non-immediate).
 *   10:  the cell belongs to a pair with a short integer in its car.
 *   11:  the cell belongs to a non-pair (closure or some other non-immediate).
 *
 * tc3:
 *   000:  the cell belongs to a pair with a non-immediate in its car.
 *   001:  the cell belongs to a struct
 *   010:  the cell belongs to a pair with an even short integer in its car.
 *   011:  the cell belongs to a closure
 *   100:  the cell belongs to a pair with a non-integer immediate in its car.
 *   101:  the cell belongs to some other non-immediate.
 *   110:  the cell belongs to a pair with an odd short integer in its car.
 *   111:  the cell belongs to some other non-immediate.
 *
 * tc7 (for tc3==1x1):
 *   See below for the list of types.  Note the special case of scm_tc7_vector
 *   and scm_tc7_wvect:  vectors and weak vectors are treated the same in many
 *   cases.  Thus, their tc7-codes are chosen to only differ in one bit.  This
 *   makes it possible to check an object at the same time for being a vector
 *   or a weak vector by comparing its tc7 code with that bit masked (using
 *   the TYP7S macro).  Three more special tc7-codes are of interest:
 *   numbers, ports and smobs in fact each represent collections of types,
 *   which are subdivided using tc16-codes.
 *
 * tc16 (for tc7==scm_tc7_smob):
 *   The largest part of the space of smob types is not subdivided in a
 *   predefined way, since smobs can be added arbitrarily by user C code.
 *//* SCM values can not be compared by using the operator ==.  Use the following
 * macro instead, which is the equivalent of the scheme predicate 'eq?'.
 *//* This should be used as a fall back solution for machines on which casting
 * to a pointer may lead to loss of bit information, e. g. in the three least
 * significant bits.
 *//*
  There is no typechecking on SCM_PACK, since all kinds of types
  (unsigned long, void*) go in SCM_PACK
 *//*
  The 0?: constructions makes sure that the code is never executed,
  and that there is no performance hit.  However, the alternative is
  compiled, and does generate a warning when used with the wrong
  pointer type.  We use a volatile pointer type to avoid warnings
  from clang.

  The Tru64 and ia64-hp-hpux11.23 compilers fail on `case (0?0=0:x)'
  statements, so for them type-checking is disabled.  *//* This is the default, which provides an intermediate level of compile time
 * type checking while still resulting in very efficient code.
 *//* But as external interface, we define SCM, which may, according to the
 * desired level of type checking, be defined in several ways:
 *//* For dealing with the bit level representation of scheme objects we define
 * scm_t_bits:
 *//* In the beginning was the Word:
 *
 * For the representation of scheme objects and their handling, Guile provides
 * two types:  scm_t_bits and SCM.
 *
 * - scm_t_bits values can hold bit patterns of non-objects and objects:
 *
 *   Non-objects -- in this case the value may not be changed into a SCM value
 *   in any way.
 *
 *   Objects -- in this case the value may be changed into a SCM value using
 *   the SCM_PACK macro.
 *
 * - SCM values can hold proper scheme objects only.  They can be changed into
 *   a scm_t_bits value using the SCM_UNPACK macro.
 *
 * When working in the domain of scm_t_bits values, programmers must keep
 * track of any scm_t_bits value they create that is not a proper scheme
 * object.  This makes sure that in the domain of SCM values developers can
 * rely on the fact that they are dealing with proper scheme objects only.
 * Thus, the distinction between scm_t_bits and SCM values helps to identify
 * those parts of the code where special care has to be taken not to create
 * bad SCM values.
 *//* picks up scmconfig.h too *//** This file defines the format of SCM values and cons pairs.
 ** It is here that tag bits are assigned for various purposes.
 **//* Copyright (C) 1995,1996,1997,1998,1999,2000,2001,2002,2003,2004,2008,2009,2010,2012
 * Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */<setjmp.h>"libguile/tags.h""libguile/scmconfig.h"scm_apply_genericscm_call_generic_2scm_call_generic_1scm_call_generic_0scm_async_tickSCM_STACKITEMscm_t_subrSCM_THREAD_LOCAL__threadSCM_C_INLINE_KEYWORDSCM_ARG7SCM_ARG6SCM_ARG5SCM_ARG4SCM_ARG3SCM_ARG2SCM_ARG1SCM_ARGnSCM_GASSERTn(cond,gf,args,pos,subr)if (SCM_UNLIKELY (!(cond))) SCM_WTA_DISPATCH_n((gf), (args), (pos), (subr))SCM_WTA_DISPATCH_n(gf,args,pos,subr)return (SCM_UNPACK (gf) ? scm_apply_generic ((gf), (args)) : (scm_wrong_type_arg ((subr), (pos), scm_list_ref ((args), scm_from_int ((pos) - 1))), SCM_UNSPECIFIED))SCM_GASSERT2(cond,gf,a1,a2,pos,subr)if (SCM_UNLIKELY (!(cond))) SCM_WTA_DISPATCH_2((gf), (a1), (a2), (pos), (subr))SCM_WTA_DISPATCH_2(gf,a1,a2,pos,subr)return (SCM_UNPACK (gf) ? scm_call_generic_2 ((gf), (a1), (a2)) : (scm_wrong_type_arg ((subr), (pos), (pos) == SCM_ARG1 ? (a1) : (a2)), SCM_UNSPECIFIED))SCM_GASSERT1(cond,gf,a1,pos,subr)if (SCM_UNLIKELY (!(cond))) SCM_WTA_DISPATCH_1((gf), (a1), (pos), (subr))SCM_WTA_DISPATCH_1_SUBR(subr,a1,pos)return (SCM_UNPACK ((*SCM_SUBR_GENERIC (subr))) ? scm_call_generic_1 ((*SCM_SUBR_GENERIC (subr)), (a1)) : (scm_i_wrong_type_arg_symbol (SCM_SUBR_NAME (subr), (pos), (a1)), SCM_UNSPECIFIED))SCM_WTA_DISPATCH_1(gf,a1,pos,subr)return (SCM_UNPACK (gf) ? scm_call_generic_1 ((gf), (a1)) : (scm_wrong_type_arg ((subr), (pos), (a1)), SCM_UNSPECIFIED))SCM_GASSERT0(cond,gf,subr)if (SCM_UNLIKELY(!(cond))) SCM_WTA_DISPATCH_0((gf), (subr))SCM_WTA_DISPATCH_0(gf,subr)return (SCM_UNPACK (gf) ? scm_call_generic_0 ((gf)) : (scm_error_num_args_subr ((subr)), SCM_UNSPECIFIED))SCM_ASSERT_TYPE(_cond,_arg,_pos,_subr,_msg)do { if (SCM_UNLIKELY (!(_cond))) scm_wrong_type_arg_msg(_subr, _pos, _arg, _msg); } while (0)SCM_ASSERT(_cond,_arg,_pos,_subr)do { if (SCM_UNLIKELY (!(_cond))) scm_wrong_type_arg (_subr, _pos, _arg); } while (0)SCM_TICKdo { SCM_ASYNC_TICK; SCM_THREAD_SWITCHING_CODE; } while (0)SCM_FENCEasm ("")SCM_ASYNC_TICK(scm_async_tick ())SCM_STACK_PTR(ptr)((SCM_STACKITEM *) (void *) (ptr))SCM_FLUSH_REGISTER_WINDOWSSCM_I_LONGJMPlongjmpsetjmpscm_i_jmp_bufjmp_bufSCM_I_SSIZE_MAXSCM_I_TYPE_MAX(ssize_t,SCM_I_SIZE_MAX)SCM_I_SSIZE_MINSCM_I_TYPE_MIN(ssize_t,SCM_I_SIZE_MAX)SCM_I_SIZE_MAXSCM_I_UTYPE_MAX(size_t)SCM_I_TYPE_MAX(scm_t_intptr,SCM_T_UINTPTR_MAX)SCM_I_TYPE_MIN(scm_t_intptr,SCM_T_UINTPTR_MAX)SCM_I_UTYPE_MAX(scm_t_uintptr)SCM_T_INTMAX_MAXSCM_I_TYPE_MAX(scm_t_intmax,SCM_T_UINTMAX_MAX)SCM_T_INTMAX_MINSCM_I_TYPE_MIN(scm_t_intmax,SCM_T_UINTMAX_MAX)SCM_T_UINTMAX_MAXSCM_I_UTYPE_MAX(scm_t_uintmax)SCM_I_LLONG_MAXSCM_I_TYPE_MAX(long long,SCM_I_ULLONG_MAX)SCM_I_LLONG_MINSCM_I_TYPE_MIN(long long,SCM_I_ULLONG_MAX)SCM_I_ULLONG_MAXSCM_I_UTYPE_MAX(unsigned long long)SCM_I_TYPE_MAX(scm_t_int64,SCM_T_UINT64_MAX)SCM_I_TYPE_MIN(scm_t_int64,SCM_T_UINT64_MAX)SCM_T_UINT64_MAXSCM_I_UTYPE_MAX(scm_t_uint64)SCM_T_INT32_MAXSCM_I_TYPE_MAX(scm_t_int32,SCM_T_UINT32_MAX)SCM_T_INT32_MINSCM_I_TYPE_MIN(scm_t_int32,SCM_T_UINT32_MAX)SCM_T_UINT32_MAXSCM_I_UTYPE_MAX(scm_t_uint32)SCM_T_INT16_MAXSCM_I_TYPE_MAX(scm_t_int16,SCM_T_UINT16_MAX)SCM_T_INT16_MINSCM_I_TYPE_MIN(scm_t_int16,SCM_T_UINT16_MAX)SCM_T_UINT16_MAXSCM_I_UTYPE_MAX(scm_t_uint16)SCM_T_INT8_MAXSCM_I_TYPE_MAX(scm_t_int8,SCM_T_UINT8_MAX)SCM_T_INT8_MINSCM_I_TYPE_MIN(scm_t_int8,SCM_T_UINT8_MAX)SCM_T_UINT8_MAXSCM_I_UTYPE_MAX(scm_t_uint8)SCM_I_TYPE_MIN(type,umax)(-((type)((umax)/2))-1)SCM_I_TYPE_MAX(type,umax)((type)((umax)/2))SCM_I_UTYPE_MAX(type)((type)-1)SCM_LONG_BITSCM_CHAR_BITSCM_INLINE_IMPLEMENTATIONSCM_INLINESCM_CAN_INLINESCM_APINO_CEVAL_STACK_CHECKINGSTACK_CHECKINGSICPENGNOTSCM_MALLOC__attribute__ ((__malloc__))SCM_ALIGNED(x)__attribute__ ((aligned (x)))SCM_DEPRECATEDSCM_API __attribute__ ((__deprecated__))SCM_INTERNALSCM_UNLIKELY(_expr)SCM_EXPECT ((_expr), 0)SCM_LIKELY(_expr)SCM_EXPECT ((_expr), 1)SCM_EXPECTSCM_UNUSED__attribute__ ((unused))SCM_NORETURN__attribute__ ((__noreturn__))SCM_GNUC_PREREQ(maj,min)gfargsa1a2/usr/include/guile/2.0/libguile/alist.hscm_init_alistscm_assoc_remove_xscm_assv_remove_xscm_assq_remove_xscm_assoc_set_xscm_assv_set_xscm_assq_set_xscm_assoc_refscm_assv_refscm_assq_refscm_assocscm_assvscm_assqscm_sloppy_assocscm_sloppy_assvscm_sloppy_assqscm_aconsSCM_ALIST_H/* SCM_ALIST_H *//* Copyright (C) 1995,1996,2000, 2006, 2008 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */alistkeyvalxwy/usr/include/guile/2.0/libguile/arbiters.hscm_init_arbitersscm_release_arbiterscm_try_arbiterscm_make_arbiterSCM_ARBITERS_H/* SCM_ARBITERS_H */arbname/usr/include/guile/2.0/libguile/error.hscm_init_errorscm_misc_errorscm_memory_errorscm_wrong_type_arg_msgscm_i_wrong_type_arg_symbolscm_wrong_type_argscm_error_num_args_subrscm_wrong_num_argsscm_out_of_range_posscm_out_of_rangescm_num_overflowscm_syserror_msgscm_syserrorscm_strerrorscm_error_scmscm_errorscm_misc_error_keyscm_memory_alloc_keyscm_arg_type_keyscm_args_number_keyscm_out_of_range_keyscm_num_overflow_keyscm_system_error_keySCM_ERROR_Hnoreturn/* SCM_ERROR_H *//* Copyright (C) 1995,1996,1997,1998,2000,2001, 2002, 2006, 2008 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */subrmessageposbad_valueszsymbolprocenoerrrest/usr/include/guile/2.0/libguile/chars.hscm_init_charsscm_i_charname_to_charscm_i_charnamescm_c_titlecasescm_c_downcasescm_c_upcasescm_char_general_categoryscm_char_titlecasescm_char_downcasescm_char_upcasescm_integer_to_charscm_char_to_integerscm_char_is_both_pscm_char_lower_case_pscm_char_upper_case_pscm_char_whitespace_pscm_char_numeric_pscm_char_alphabetic_pscm_char_ci_geq_pscm_char_ci_gr_pscm_char_ci_leq_pscm_char_ci_less_pscm_char_ci_eq_pscm_char_geq_pscm_char_gr_pscm_char_leq_pscm_char_less_pscm_char_eq_pscm_char_pscm_t_wcharSCM_IS_UNICODE_CHAR(c)(((scm_t_wchar) (c) >= 0 && (scm_t_wchar) (c) < SCM_CODEPOINT_SURROGATE_START) || ((scm_t_wchar) (c) > SCM_CODEPOINT_SURROGATE_END && (scm_t_wchar) (c) <= SCM_CODEPOINT_MAX))SCM_CODEPOINT_MAX(0x10ffff)SCM_CODEPOINT_SURROGATE_END(0xdfff)SCM_CODEPOINT_SURROGATE_START(0xd800)SCM_CODEPOINT_DOTTED_CIRCLE(0x25cc)SCM_MAKE_CHAR(x)((x) <= 1 ? SCM_MAKE_ITAG8 ((scm_t_bits) (unsigned char) (x), scm_tc8_char) : SCM_MAKE_ITAG8 ((scm_t_bits) (x), scm_tc8_char))SCM_CHAR(x)((scm_t_wchar)SCM_ITAG8_DATA(x))SCM_CHARP(x)(SCM_ITAG8(x) == scm_tc8_char)SCM_T_WCHAR_DEFINEDSCM_CHARS_H/* SCM_CHARS_H *//* SCM_MAKE_CHAR maps signed chars (-128 to 127) and unsigned chars (0
   to 255) to Latin-1 codepoints (0 to 255) while allowing higher
   codepoints (256 to 1114111) to pass through unchanged.

   This macro evaluates x twice, which may lead to side effects if not
   used properly. *//* Immediate Characters
 *//* SCM_T_WCHAR_DEFINED *//* Copyright (C) 1995,1996,2000,2001,2004, 2006, 2008, 2009 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */charnamecharname_lenchrcn/usr/include/guile/2.0/libguile/options.hscm_init_optionsscm_init_optsscm_t_option[]scm_optionsscm_options_tryscm_t_optiondoctypeSCM_OPTION_SCMSCM_OPTION_INTEGERSCM_OPTION_BOOLEANSCM_OPTIONS_H/* SCM_OPTIONS_H *//* Copyright (C) 1995,1996,2000,2001, 2006, 2008 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */optionssdry_run/usr/include/guile/2.0/libguile/print.h"libguile/options.h""libguile/chars.h"scm_init_printscm_valid_oport_value_pscm_get_print_statescm_port_with_print_statescm_printer_applyscm_print_state *scm_write_charscm_newlinescm_simple_formatscm_displayscm_writescm_iprin1scm_prin1scm_print_symbol_namescm_i_print_symbol_namescm_iprlistscm_iprukscm_uintprintscm_intprintscm_i_display_substringscm_i_port_with_print_statescm_free_print_statescm_make_print_statescm_print_optionsscm_print_statehighlight_objectsref_vectceilingtoplist_offsethot_reflengthlevelfancypwritingprevealedhandlescm_tc16_port_with_psscm_print_state_vtableSCM_PRINT_STATE_LAYOUT"sruwuwuwuwuwpwuwuwurprpw"SCM_COERCE_OUTPORT(p)(SCM_PORT_WITH_PS_P (p) ? SCM_PORT_WITH_PS_PORT (p) : p)SCM_PORT_WITH_PS_PS(p)SCM_CDR (SCM_CELL_OBJECT_1 (p))SCM_PORT_WITH_PS_PORT(p)SCM_CAR (SCM_CELL_OBJECT_1 (p))SCM_PORT_WITH_PS_P(p)SCM_TYP16_PREDICATE (scm_tc16_port_with_ps, p)SCM_SET_WRITINGP(pstate,x){ (pstate)->writingp = (x); }SCM_WRITINGP(pstate)((pstate)->writingp)RESET_PRINT_STATE(pstate)do { pstate->list_offset = 0; pstate->top = 0; } while (0)SCM_PRINT_STATE(obj)((scm_print_state *) SCM_STRUCT_DATA (obj))SCM_PRINT_STATE_P(obj)(SCM_STRUCTP(obj) && (scm_is_eq (SCM_STRUCT_VTABLE(obj), scm_print_state_vtable)))SCM_PRINT_HGUILE_DEBUG/* SCM_PRINT_H *//* List of objects to be highlighted *//* Stack of references used during
				   circular reference detection;
				   a simple vector. *//* Max size of reference stack *//* Top of reference stack *//* Hot reference *//* Max number of objects per level *//* Max level *//* Fancy printing? *//* Writing? *//* Has the state escaped to Scheme? *//* Struct handle *//* State information passed around during printing.
 *//* Copyright (C) 1995, 1996, 1998, 2000, 2001, 2003, 2004, 2006, 2008,
 *   2010, 2012 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */portpstateexpobjstrlensymhdrtlrptrradixstartendprint_statesetting/usr/include/guile/2.0/libguile/numbers.h<float.h>"libguile/print.h"<gmp.h>scm_init_numbersscm_is_numberscm_c_anglescm_c_magnitudescm_c_imag_partscm_c_real_partscm_c_make_polarscm_c_make_rectangularscm_is_complexscm_from_doublescm_to_doublescm_is_rationalscm_is_realscm_from_mpzscm_to_mpzscm_from_uint64scm_to_uint64scm_from_int64scm_to_int64scm_from_wcharscm_to_wcharscm_from_uint32scm_to_uint32scm_from_int32scm_to_int32scm_from_uint16scm_to_uint16scm_from_int16scm_to_int16scm_from_uint8scm_to_uint8scm_from_int8scm_to_int8scm_to_unsigned_integerscm_to_signed_integerscm_from_unsigned_integerscm_from_signed_integerscm_is_unsigned_integerscm_is_signed_integerscm_is_exact_integerscm_is_integerscm_i_print_complexscm_i_print_doublescm_i_print_fractionscm_i_fraction_equalpscm_i_fraction2doublescm_denominatorscm_numeratorscm_rationalizescm_i_clonebigscm_i_ulong2bigscm_i_long2bigscm_i_big2dblscm_i_dbl2numscm_i_dbl2bigscm_i_bigcmpscm_i_normbigscm_i_mkbigscm_i_exact_integer_sqrtscm_i_dividescm_i_productscm_i_differencescm_i_sumscm_i_maxscm_i_minscm_exact_integer_sqrtSCM *scm_unused_struct **scm_sqrtscm_expscm_log10scm_logscm_truncscm_inexact_to_exactscm_exact_to_inexactscm_anglescm_magnitudescm_imag_partscm_real_partscm_make_polarscm_make_rectangularscm_sys_atanhscm_sys_acoshscm_sys_asinhscm_atanscm_acosscm_asinscm_tanhscm_coshscm_sinhscm_tanscm_cosscm_sinscm_exptscm_round_numberscm_truncate_numberscm_c_roundscm_c_truncatescm_ceilingscm_floorscm_dividescm_productscm_oneminusscm_differencescm_oneplusscm_sumscm_minscm_maxscm_negative_pscm_positive_pscm_zero_pscm_geq_pscm_leq_pscm_gr_pscm_less_pscm_num_eq_pscm_is_inexactscm_inexact_pscm_exact_integer_pscm_integer_pscm_rational_pscm_real_pscm_complex_pscm_number_pscm_complex_equalpscm_real_equalpscm_bigequalscm_string_to_numberscm_i_string_to_numberscm_c_locale_stringn_to_numberscm_bigprintscm_print_complexscm_print_realscm_number_to_stringscm_iuint2strscm_iint2strscm_i_logxorscm_i_logiorscm_i_logandscm_i_lcmscm_i_gcdscm_i_round_dividescm_i_centered_dividescm_i_truncate_dividescm_i_ceiling_dividescm_i_floor_dividescm_i_euclidean_dividescm_integer_lengthscm_logcountscm_bit_extractscm_round_ashscm_ashscm_integer_exptscm_modulo_exptscm_lognotscm_logbit_pscm_logtestscm_logxorscm_logiorscm_logandscm_lcmscm_gcdscm_round_remainderscm_round_quotientscm_round_dividescm_centered_remainderscm_centered_quotientscm_centered_dividescm_truncate_remainderscm_truncate_quotientscm_truncate_dividescm_ceiling_remainderscm_ceiling_quotientscm_ceiling_dividescm_floor_remainderscm_floor_quotientscm_floor_dividescm_euclidean_remainderscm_euclidean_quotientscm_euclidean_dividescm_moduloscm_remainderscm_quotientscm_absscm_nanscm_infscm_nan_pscm_inf_pscm_finite_pscm_even_pscm_odd_pscm_is_exactscm_exact_pscm_t_complexscm_t_doublescm_t_inumimagrealpadscm_install_gmp_memory_functionsscm_from_ptrdiff_tscm_to_ptrdiff_tscm_from_uintptr_tscm_to_uintptr_tscm_from_size_tscm_to_size_tscm_from_ssize_tscm_to_ssize_tscm_from_ulong_longscm_to_ulong_longscm_from_long_longscm_to_long_longscm_from_uintmaxscm_to_uintmaxscm_from_intmaxscm_to_intmaxscm_from_ulongscm_to_ulongscm_from_longscm_to_longscm_from_uintscm_to_uintscm_from_intscm_to_intscm_from_ushortscm_to_ushortscm_from_shortscm_to_shortscm_from_charscm_to_charscm_from_ucharscm_to_ucharscm_from_scharscm_to_scharSCM_FRACTION_DENOMINATOR(x)(SCM_CELL_OBJECT_2 (x))SCM_FRACTION_NUMERATOR(x)(SCM_CELL_OBJECT_1 (x))SCM_FRACTIONP(x)(!SCM_IMP (x) && SCM_TYP16 (x) == scm_tc16_fraction)SCM_NUMP(x)(!SCM_IMP(x) && ((0x00ff & SCM_CELL_TYPE (x)) == scm_tc7_number))SCM_NUMBERP(x)(SCM_I_INUMP(x) || SCM_NUMP(x))SCM_BIGP(x)(!SCM_IMP (x) && SCM_TYP16 (x) == scm_tc16_big)SCM_I_BIG_MPZ(x)(*((mpz_t *) (SCM_CELL_OBJECT_LOC((x),1))))SCM_COMPLEX_IMAG(x)(((scm_t_complex *) SCM2PTR (x))->imag)SCM_COMPLEX_REAL(x)(((scm_t_complex *) SCM2PTR (x))->real)SCM_REAL_VALUE(x)(((scm_t_double *) SCM2PTR (x))->real)SCM_COMPLEXP(x)(!SCM_IMP (x) && SCM_TYP16 (x) == scm_tc16_complex)SCM_REALP(x)(!SCM_IMP (x) && SCM_TYP16 (x) == scm_tc16_real)SCM_INEXACTP(x)(!SCM_IMP (x) && (0xfeff & SCM_CELL_TYPE (x)) == scm_tc16_real)scm_tc16_fraction(scm_tc7_number + 4 * 256L)scm_tc16_complex(scm_tc7_number + 3 * 256L)scm_tc16_real(scm_tc7_number + 2 * 256L)scm_tc16_big(scm_tc7_number + 1 * 256L)SCM_INTBUFLEN(5 + SCM_CHAR_BIT*sizeof(scm_t_intmax))SCM_FLTMAXFLT_MAXSCM_MAXEXPDBL_MAX_10_EXPSCM_INUM1(SCM_I_MAKINUM (1))SCM_INUM0(SCM_I_MAKINUM (0))SCM_FIXABLE(n)(SCM_POSFIXABLE (n) && SCM_NEGFIXABLE (n))SCM_NEGFIXABLE(n)((n) >= SCM_MOST_NEGATIVE_FIXNUM)SCM_POSFIXABLE(n)((n) <= SCM_MOST_POSITIVE_FIXNUM)SCM_I_MAKINUM(x)(SCM_PACK ((((scm_t_bits) (x)) << 2) + scm_tc2_int))SCM_I_NINUMP(x)(!SCM_I_INUMP (x))SCM_I_INUMP(x)(2 & SCM_UNPACK (x))SCM_I_INUM(x)(SCM_SRS ((scm_t_inum) SCM_UNPACK (x), 2))SCM_SRS(x,y)((x) >> (y))SCM_MOST_POSITIVE_FIXNUM(- (SCM_MOST_NEGATIVE_FIXNUM + 1))SCM_MOST_NEGATIVE_FIXNUM(-1L << (SCM_I_FIXNUM_BIT - 1))SCM_I_FIXNUM_BIT(SCM_LONG_BIT - 2)SCM_NUMBERS_H(-1 >> 2 == -1) && (-4 >> 2 == -1) && (-5 >> 2 == -2) && (-8 >> 2 == -2)GO32__MINGW32__SCM_SIZEOF_CHAR == 1CHAR_MIN == 0SCM_SIZEOF_SHORT == 1SCM_SIZEOF_SHORT == 2SCM_SIZEOF_SHORT == 4SCM_SIZEOF_INT == 4SCM_SIZEOF_INT == 8SCM_SIZEOF_LONG == 4SCM_SIZEOF_LONG == 8SCM_SIZEOF_INTMAX == 4SCM_SIZEOF_INTMAX == 8SCM_SIZEOF_LONG_LONG == 0SCM_SIZEOF_LONG_LONG == 8SCM_SIZEOF_SIZE_T == 4SCM_SIZEOF_SIZE_T == 8SCM_SIZEOF_UINTPTR_T == 4SCM_SIZEOF_UINTPTR_T == 8SCM_SIZEOF_SCM_T_PTRDIFF == 4SCM_SIZEOF_SCM_T_PTRDIFF == 8__SCHAR_MAX__0x7f/* SCM_NUMBERS_H *//* If nonzero, tell gmp to use GC_malloc for its allocations.  *//* conversion functions for complex *//* conversion functions for double *//* The conversion functions for other types are aliased to the
   appropriate ones from above.  We pick the right one based on the
   size of the type.

   Not each and every possibility is covered by the code below, and
   while it is trivial to complete the tests, it might be better to
   just test for the 'sane' possibilities.  When one of the tests
   below fails, chances are good that some silent assumption somewhere
   else will also fail.
*//* conversion functions for integers *//* general internal functions *//* fraction internal functions *//* ratio functions *//* FIXME: not internal *//* bignum internal functions *//* Each bignum is just an mpz_t stored in a double cell starting at word 1. *//* Number subtype 1 to 3 (note the dependency on the predicates SCM_INEXACTP
 * and SCM_NUMP)  *//* Note that scm_tc16_real and scm_tc16_complex are given tc16-codes that only
 * differ in one bit: This way, checking if an object is an inexact number can
 * be done quickly (using the TYP16S macro).  *//* Numbers 
 *//* SCM_INTBUFLEN is the maximum number of characters neccessary for
 * the printed or scm_string representation of an scm_t_intmax in
 * radix 2.  The buffer passed to scm_iint2str and scm_iuint2str must
 * be of this size, for example.
 *//* def FLT_MAX *//* def DBL_MAX_10_EXP *//* IEEE doubles *//* def STDC_HEADERS *//* ndef GO32 *//* __MINGW32__ *//* SCM_MAXEXP is the maximum double precision exponent
 * SCM_FLTMAX is less than or scm_equal the largest single precision float
 *//* A name for 1 *//* A name for 0 *//* SCM_FIXABLE is true if its long argument can be encoded in an SCM_INUM. *//* The first implementation of SCM_I_INUM below depends on behavior that
   is specified by GNU C but not by C standards, namely that when
   casting to a signed integer of width N, the value is reduced modulo
   2^N to be within range of the type.  The second implementation below
   should be portable to all conforming C implementations, but may be
   less efficient if the compiler is not sufficiently clever.

   NOTE: X must not perform side effects.  *//* SCM_SRS (X, Y) is signed right shift, defined as floor (X / 2^Y),
   where Y must be non-negative and less than the width in bits of X.
   It's common for >> to do this, but the C standards do not specify
   what happens when X is negative.

   NOTE: X must not perform side effects.  *//* Immediate Numbers, also known as fixnums
 *
 * Inums are exact integers that fit within an SCM word
 * (along with two tagging bits).
 *
 * In the current implementation, Inums must also fit within a long
 * because that's what GMP's mpz_*_si functions accept.  *//* Copyright (C) 1995, 1996, 1998, 2000-2006, 2008-2011, 2013, 2014,
 *   2016 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */zmagangreimropminmaxsexpsrc_bigsame_sign_pbdakrz1z2memnumradpcountmn1n2q/usr/include/guile/2.0/libguile/array-handle.h"libguile/numbers.h""libguile/error.h"scm_init_array_handlescm_array_handle_setscm_t_array_handle *p < 0 && ((size_t)-p) > h->baseNULLscm_t_array_implementation *scm_array_handle_refscm_array_handle_writable_elementsconst SCMconst SCM *scm_array_handle_elementsscm_array_handle_releasescm_array_handle_element_typescm_array_handle_pos_2scm_array_handle_pos_1scm_array_handle_posscm_array_get_handlescm_i_array_implementation_for_objscm_i_register_array_implementationscm_t_array_handlescm_i_t_array_refscm_t_array_element_typeSCM_ARRAY_ELEMENT_TYPE_SCMSCM_ARRAY_ELEMENT_TYPE_CHARSCM_ARRAY_ELEMENT_TYPE_BITSCM_ARRAY_ELEMENT_TYPE_VU8SCM_ARRAY_ELEMENT_TYPE_U8SCM_ARRAY_ELEMENT_TYPE_S8SCM_ARRAY_ELEMENT_TYPE_U16SCM_ARRAY_ELEMENT_TYPE_S16SCM_ARRAY_ELEMENT_TYPE_U32SCM_ARRAY_ELEMENT_TYPE_S32SCM_ARRAY_ELEMENT_TYPE_U6410SCM_ARRAY_ELEMENT_TYPE_S64SCM_ARRAY_ELEMENT_TYPE_F32SCM_ARRAY_ELEMENT_TYPE_F64SCM_ARRAY_ELEMENT_TYPE_C3214SCM_ARRAY_ELEMENT_TYPE_C64SCM_ARRAY_ELEMENT_TYPE_LASTscm_t_array_dimscm_t_array_implementationscm_i_t_array_setwritable_elementselementselement_typedim0scm_t_array_dim *dimsincubndlbndndimsbaseimplget_handlevsetvrefmasktagarraySCM[]scm_unused_struct *[]scm_i_array_element_typesscm_array_handle_dims(h)((h)->dims)scm_array_handle_rank(h)((h)->ndims)SCM_ARRAY_IMPLEMENTATION(tag_,mask_,vref_,vset_,handle_)SCM_SNARF_INIT ({ scm_t_array_implementation impl; impl.tag = tag_; impl.mask = mask_; impl.vref = vref_; impl.vset = vset_; impl.get_handle = handle_; scm_i_register_array_implementation (&impl); })SCM_ARRAY_HANDLE_HSCM_CAN_INLINE || defined SCM_INLINE_C_IMPLEMENTING_INLINES/* SCM_ARRAY_HANDLE_H *//* perhaps should catch overflow here too *//* catch overflow *//* Either inlining, or being included from inline.c.  *//* ndims == the rank of the array *//* `Base' is an offset into elements or writable_elements, corresponding to
     the first element in the array. It would be nicer just to adjust the
     elements/writable_elements pointer, but we can't because that element might
     not even be byte-addressable, as is the case with bitvectors. A nicer
     solution would be, well, nice.
   *//* packed numeric values *//* SCM values *//* Copyright (C) 1995, 1996, 1997, 1999, 2000, 2001, 2004, 2006,
 *   2008, 2009, 2011, 2013 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */hvidx0idx1indices/usr/include/guile/2.0/libguile/array-map.hscm_array_identityscm_ra_dividescm_ra_productscm_ra_differencescm_ra_sumscm_ra_greqpscm_ra_grpscm_ra_leqpscm_ra_lesspscm_ra_eqpscm_array_fill_intscm_init_array_mapscm_array_equal_pscm_array_index_map_xscm_array_for_eachscm_array_map_xscm_array_copy_xscm_array_fill_xscm_ramapcscm_ra_matchpSCM_ARRAY_MAP_Hdeprecated/* SCM_ARRAY_MAP_H *//* SCM_ENABLE_DEPRECATED == 1 *//* Copyright (C) 1995, 1996, 1997, 2000, 2006, 2008, 2009, 2010,
 *   2011, 2013 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */srcdstra0rasrafillignorera1lracprocdatawhat/usr/include/guile/2.0/libguile/arrays.hscm_init_arraysscm_i_print_arrayscm_i_make_arrayscm_list_to_typed_arrayscm_list_to_arrayscm_array_contentsscm_transpose_arrayscm_make_shared_arrayscm_shared_array_incrementsscm_shared_array_offsetscm_shared_array_rootscm_from_contiguous_typed_arrayscm_make_typed_arrayscm_from_contiguous_arrayscm_make_arrayscm_i_t_arraySCM_I_ARRAY_DIMS(a)((scm_t_array_dim *)((char *) SCM_I_ARRAY_MEM (a) + sizeof (scm_i_t_array)))SCM_I_ARRAY_BASE(a)(SCM_I_ARRAY_MEM (a)->base)SCM_I_ARRAY_V(a)(SCM_I_ARRAY_MEM (a)->v)SCM_I_ARRAY_MEM(a)((scm_i_t_array *) SCM_CELL_WORD_1 (a))SCM_I_ARRAY_CONTP(x)(SCM_CELL_WORD_0 (x) & (SCM_I_ARRAY_FLAG_CONTIGUOUS << 16))SCM_I_ARRAY_NDIM(x)((size_t) (SCM_CELL_WORD_0 (x)>>17))SCM_I_ARRAYP(a)SCM_TYP16_PREDICATE (scm_tc7_array, a)SCM_I_ARRAY_FLAG_CONTIGUOUS(1 << 0)SCM_ARRAY_H/* SCM_ARRAYS_H *//* the contents of the array, e.g., a vector or uniform vector.  *//* internal. *//** Arrays *//* Multidimensional arrays. Woo hoo!
   Also see ....
 *//* Copyright (C) 1995,1996,1997,1999,2000,2001, 2004, 2006, 2008, 2009,
 *   2010, 2012 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */ndimlststrictoldramapfuncboundsbytesbyte_lenelts/usr/include/guile/2.0/libguile/debug.hscm_init_debugscm_debug_optionsscm_procedure_namescm_procedure_sourcescm_reverse_lookupscm_local_evalscm_t_debug_infoideenvscm_debug_modescm_debug_mode_pSCM_DEBUGGINGPCHECK_EXITscm_check_exit_pCHECK_APPLYscm_check_apply_pCHECK_ENTRYscm_check_entry_pSCM_DEBUG_H/* SCM_DEBUG_H *//* Deprecated in guile 1.7.0 on 2004-03-29.  *//*GUILE_DEBUG*//* {Evaluator}
 *//* Copyright (C) 1995,1996,1998,1999,2000,2001,2002,2004,2008,2009,2010,2012
 * Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/throw.hscm_init_throwscm_throwscm_ithrowscm_with_throw_handlerscm_catchscm_catch_with_pre_unwind_handlerscm_exit_statusscm_handle_by_throwscm_handle_by_message_noexitscm_handle_by_messagescm_handle_by_proc_catching_allscm_handle_by_procscm_body_thunkscm_internal_catchscm_c_with_throw_handlerscm_c_catchscm_body_thunk_datascm_t_catch_handlerscm_t_catch_bodybody_procSCM_THROW_H/* SCM_THROW_H *//* The Scheme procedure object constituting the catch body.
     scm_body_by_proc invokes this.  *//* The tag being caught.  We only use it to figure out what
     arguments to pass to the body procedure; see scm_catch_thunk_body for
     details.  *//* The first argument to scm_body_thunk should be a pointer to one of
   these.  See the implementation of catch in throw.c.  *//* Copyright (C) 1995,1996,1998,2000, 2006, 2008, 2010 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */no_returnthunkhandlerlazy_handlerbodybody_datahandler_datalazy_catch_ppre_unwind_handlerpre_unwind_handler_data/usr/include/guile/2.0/libguile/root.h"libguile/throw.h""libguile/debug.h"scm_init_rootscm_apply_with_dynamic_rootscm_dynamic_rootscm_call_with_dynamic_rootscm_internal_cwdrSCM_STACKITEM *SCM_ROOT_H/* SCM_ROOT_H *//* Copyright (C) 1996,1998,2000,2001, 2002, 2006, 2008, 2009 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */stack_start/usr/include/guile/2.0/libguile/procs.hscm_init_procsscm_setterscm_procedurescm_make_procedure_with_setterscm_procedure_with_setter_pscm_procedure_documentationscm_thunk_pscm_procedure_pscm_sym_documentationSCM_PROCS_H/* SCM_PROCS_H *//* Copyright (C) 1995, 1996, 1998, 1999, 2000, 2001, 2006, 2008, 2009,
 *   2012 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */proceduresetter/usr/include/guile/2.0/libguile/iselect.hscm_std_selectfd_set *SELECT_TYPEfd_setSCM_ISELECT_H/* SCM_ISELECT_H *//* Needed for FD_SET on some systems.  *//* Copyright (C) 1997,1998,2000,2001, 2002, 2006, 2013 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */fdsrfdswfdsefdstimeout/usr/include/guile/2.0/libguile/dynwind.hscm_dynwind_freescm_dynwind_rewind_handler_with_scmscm_dynwind_unwind_handler_with_scmscm_dynwind_rewind_handlerscm_dynwind_unwind_handlerscm_dynwind_endscm_dynwind_beginscm_swap_bindingsscm_init_dynwindscm_i_dowindsscm_dowindsscm_dynamic_windscm_t_wind_flagsSCM_F_WIND_EXPLICITLY1 << 0scm_t_dynwind_flagsSCM_F_DYNWIND_REWINDABLEscm_t_guardSCM_DYNWIND_H/* SCM_DYNWIND_H *//* Copyright (C) 1995,1996,1998,1999,2000,2003,2004, 2006, 2008, 2011 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */funcvarsvalstodeltaturn_functhunk1thunk2thunk3/usr/include/guile/2.0/libguile/continuations.hscm_init_continuationsscm_i_with_continuation_barrierscm_with_continuation_barrierscm_c_with_continuation_barrierscm_i_contregs_vm_contscm_i_contregs_vmscm_i_continuation_to_framescm_i_call_with_current_continuationscm_i_reinstate_continuationscm_i_check_continuationscm_i_make_continuationscm_t_contregsSCM_STACKITEM[1]long[1]stackoffsetvm_contvmrootnum_stack_itemsdynenvjmpbufSCM_CONTINUATIONP(x)(SCM_PROGRAM_P (x) && SCM_PROGRAM_IS_CONTINUATION (x))SCM_CONTINUATIONS_H__ia64__/* SCM_CONTINUATIONS_H *//* copied stack of size num_stack_items.  *//* The offset from the live stack location to this copy.  This is
     used to adjust pointers from within the copied stack to the stack
     itself.

     Thus, when you read a pointer from the copied stack that points
     into the live stack, you need to add OFFSET so that it points
     into the copy.
  *//* vm's stack and regs *//* vm *//* continuation root identifier.  *//* size of the saved stack.  *//* __ia64__ *//* a continuation SCM is a non-immediate pointing to a heap cell with:
   word 0: bits 0-15: smob type tag: scm_tc16_continuation.
           bits 16-31: unused.
   word 1: malloc block containing an scm_t_contregs structure with a
           tail array of SCM_STACKITEM.  the size of the array is stored
	   in the num_stack_items field of the structure.
*//* Copyright (C) 1995,1996,2000,2001, 2006, 2008, 2009, 2010 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */contregscontfirst/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.hoffsetof(TYPE,MEMBER)__builtin_offsetof (TYPE, MEMBER)__need_NULL((void *)0)__need_wchar_t__need_size_t__need_ptrdiff_t(!defined(_STDDEF_H) && !defined(_STDDEF_H_) && !defined(_ANSI_STDDEF_H) \(!defined(__need_wchar_t) && !defined(__need_size_t)	\__sys_stdtypes_hdefined(__NetBSD__)defined (__FreeBSD__)!defined(_SIZE_T_) && !defined(_BSD_SIZE_T_)!defined(_PTRDIFF_T_) && !defined(_BSD_PTRDIFF_T_)!defined(_WCHAR_T_) && !defined(_BSD_WCHAR_T_)_BSD_WCHAR_T_defined (__need_ptrdiff_t) || defined (_STDDEF_H_)defined (__need_size_t) || defined (_STDDEF_H_)defined (__need_wchar_t) || defined (_STDDEF_H_)defined (__sequent__) && defined (_PTRDIFF_T_)defined (_TYPE_ptrdiff_t) && (defined (__need_ptrdiff_t) || defined (_STDDEF_H_))defined (_TYPE_size_t) && (defined (__need_size_t) || defined (_STDDEF_H_))defined (_TYPE_wchar_t) && (defined (__need_wchar_t) || defined (_STDDEF_H_))defined (_STDDEF_H) || defined (__need_ptrdiff_t)_PTRDIFF_T_T_PTRDIFF__T_PTRDIFF__PTRDIFF_T_PTRDIFF_T__BSD_PTRDIFF_T____int_ptrdiff_t_h_GCC_PTRDIFF_T_PTRDIFF_T_DECLARED__PTRDIFF_TYPE__defined (_STDDEF_H) || defined (__need_size_t)__size_t____SIZE_T___SIZE_T_SYS_SIZE_T_H_T_SIZE__T_SIZE__SIZE_T_SIZE_T__BSD_SIZE_T__SIZE_T_DEFINED__SIZE_T_DEFINED_BSD_SIZE_T_DEFINED__SIZE_T_DECLARED___int_size_t_h_GCC_SIZE_T_SIZET___size_tdefined (__FreeBSD__) \__SIZE_TYPE__!(defined (__GNUG__) && defined (size_t))__BEOS__defined (_STDDEF_H) || defined (__need_wchar_t)__wchar_t____WCHAR_T___WCHAR_T_T_WCHAR__T_WCHAR__WCHAR_T_WCHAR_T__BSD_WCHAR_T_DEFINED__BSD_RUNE_T_DEFINED__WCHAR_T_DECLARED_WCHAR_T_DEFINED__WCHAR_T_DEFINED_WCHAR_T_H___int_wchar_t_h__INT_WCHAR_T_H_GCC_WCHAR_T_BSD_RUNE_T_!defined (_ANSI_SOURCE) && !defined (_POSIX_SOURCE)defined (__FreeBSD__) && (__FreeBSD__ < 5)defined (__FreeBSD__) && (__FreeBSD__ >= 5)__BSD_VISIBLE_RUNE_T_DECLARED__WCHAR_TYPE__defined (__need_wint_t)_WINT_T__WINT_TYPE___GCC_PTRDIFF_T__GCC_SIZE_T__GCC_WCHAR_T_defined (_STDDEF_H) || defined (__need_NULL)__GNUG___STDDEF_H(defined (__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) \_GCC_MAX_ALIGN_T__i386__defined(__cplusplus) && __cplusplus >= 201103L_GXX_NULLPTR_T/* !_STDDEF_H && !_STDDEF_H_ && !_ANSI_STDDEF_H && !__STDDEF_H__
	  || __need_XXX was not defined before *//* _STDDEF_H was defined this time *//* C++11.  *//* C11 or C++11.  *//* _Float128 is defined as a basic type, so max_align_t must be
     sufficiently aligned for it.  This code must work in C++, so we
     use __float128 here; that is only available on some
     architectures, but only on i386 is extra alignment needed for
     __float128.  *//* Type whose alignment is supported in every context and is at least
   as great as that of any standard type not using alignment
   specifiers.  *//* Offset of member MEMBER in a struct of type TYPE. *//* NULL not defined and <stddef.h> or need NULL.  *//* G++ *//* C++ *//* in case <stdio.h> has defined it. *//* A null pointer constant.  *//* __sys_stdtypes_h *//* __NetBSD__ *//*  The following ones are the real ones.  *//*  The references to _GCC_PTRDIFF_T_, _GCC_SIZE_T_, and _GCC_WCHAR_T_
    are probably typos and should be removed before 2.8 is released.  *//* _STDDEF_H or __need_wchar_t.  *//* __wchar_t__ *//* __WCHAR_T__ *//* _BSD_RUNE_T_DEFINED_ *//* _WCHAR_T_DECLARED *//* FreeBSD 5 can't be handled well using "traditional" logic above
   since it no longer defines _BSD_RUNE_T_ yet still desires to export
   rune_t in some cases... *//* Why is this file so hard to maintain properly?  In contrast to
   the comment above regarding BSD/386 1.1, on FreeBSD for as long
   as the symbol has existed, _BSD_RUNE_T_ must not stay defined or
   redundant typedefs will occur when stdlib.h is included after this file. *//* Darwin *//* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_, and _BSD_RUNE_T_ (which, unlike the other
   symbols in the _FOO_T_ family, stays defined even after its
   corresponding type is defined).  If we define wchar_t, then we
   must undef _WCHAR_T_; for BSD/386 1.1 (and perhaps others), if
   we undef _WCHAR_T_, then we must also define rune_t, since 
   headers like runetype.h assume that if machine/ansi.h is included,
   and _BSD_WCHAR_T_ is not defined, then rune_t is available.
   machine/ansi.h says, "Note that _WCHAR_T_ and _RUNE_T_ must be of
   the same type." *//* Cray Unicos/Mk *//* BeOS *//* FreeBSD 5 *//* Define this type if we are doing the whole job,
   or if we want this type in particular.  *//* Wide character type.
   Locale-writers should change this as necessary to
   be big enough to hold unique values not between 0 and 127,
   and not (wchar_t) -1, for each defined multibyte character.  *//* _STDDEF_H or __need_size_t.  *//* __size_t__ *//* __SIZE_T__ *//* _SIZE_T *//* _SYS_SIZE_T_H *//* _T_SIZE_ *//* _T_SIZE *//* __SIZE_T *//* _SIZE_T_ *//* _BSD_SIZE_T_ *//* _SIZE_T_DEFINED_ *//* _SIZE_T_DEFINED *//* _BSD_SIZE_T_DEFINED_ *//* _SIZE_T_DECLARED *//* ___int_size_t_h *//* _GCC_SIZE_T *//* _SIZET_ *//* __size_t *//* !(defined (__GNUG__) && defined (size_t)) *//* __BEOS__ *//* __size_t is a typedef, must not trash it.  *//* in case <sys/types.h> has defined it. *//* Unsigned type of `sizeof' something.  *//* _STDDEF_H or __need_ptrdiff_t.  *//* If this symbol has done its job, get rid of it.  *//* _PTRDIFF_T *//* _T_PTRDIFF_ *//* _T_PTRDIFF *//* __PTRDIFF_T *//* _PTRDIFF_T_ *//* _BSD_PTRDIFF_T_ *//* ___int_ptrdiff_t_h *//* _GCC_PTRDIFF_T *//* _PTRDIFF_T_DECLARED *//* DragonFly *//* Signed type of difference of two pointers.  *//* In case nobody has defined these types, but we aren't running under
   GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
   __WCHAR_TYPE__ have reasonable values.  This can happen if the
   parts of GCC is compiled by an older compiler, that actually
   include gstddef.h, such as collect2.  *//* On VxWorks, <type/vxTypesBase.h> may have defined macros like
   _TYPE_size_t which will typedef size_t.  fixincludes patched the
   vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
   not defined, and so that defining this macro defines _GCC_SIZE_T.
   If we find that the macros are still defined at this point, we must
   invoke them so that the type is defined as expected.  *//* Sequent's header files use _PTRDIFF_T_ in some conflicting way.
   Just ignore it.  *//* defined(__NetBSD__) *//* Undef _FOO_T_ if we are supposed to define foo_t.  *//* On BSD/386 1.1, at least, machine/ansi.h defines _BSD_WCHAR_T_
   instead of _WCHAR_T_. *//* This avoids lossage on SunOS but only if stdtypes.h comes first.
   There's no way to win with the other order!  Sun lossage.  *//* snaroff@next.com says the NeXT needs this.  *//* Any one of these symbols __need_* means that GNU libc
   wants us just to define one data type.  So don't define
   the symbols that indicate this file's entire job has been done.  *//*
 * ISO C Standard:  7.17  Common definitions  <stddef.h>
 *//* Copyright (C) 1989-2021 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  *//usr/lib/gcc/x86_64-linux-gnu/11/include/usr/lib/gcc/x86_64-linux-gnu/11/usr/lib/gcc/x86_64-linux-gnu/usr/lib/gcc/usr/lib/usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.hsched_paramsched_priority_BITS_TYPES_STRUCT_SCHED_PARAM/* bits/types/struct_sched_param.h *//* Data structure to describe a process' schedulability.  *//* Sched parameter structure.  Generic version.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library;  if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/sched.h<bits/types/struct_sched_param.h>setnsgetcpuunsigned int *sched_getcpuunsharecloneCLONE_IO0x80000000CLONE_NEWNET0x40000000CLONE_NEWPID0x20000000CLONE_NEWUSER0x10000000CLONE_NEWIPC0x08000000CLONE_NEWUTS0x04000000CLONE_NEWCGROUP0x02000000CLONE_CHILD_SETTID0x01000000CLONE_UNTRACED0x00800000CLONE_DETACHED0x00400000CLONE_CHILD_CLEARTID0x00200000CLONE_PARENT_SETTID0x00100000CLONE_SETTLS0x00080000CLONE_SYSVSEM0x00040000CLONE_NEWNS0x00020000CLONE_THREAD0x00010000CLONE_PARENT0x00008000CLONE_VFORK0x00004000CLONE_PTRACE0x00002000CLONE_PIDFD0x00001000CLONE_SIGHAND0x00000800CLONE_FILES0x00000400CLONE_FS0x00000200CLONE_VM0x00000100CSIGNAL0x000000ffSCHED_RESET_ON_FORKSCHED_DEADLINESCHED_IDLESCHED_ISOSCHED_BATCHSCHED_RRSCHED_FIFOSCHED_OTHER_BITS_SCHED_H_SCHED_H/* bits/sched.h *//* Switch process to namespace of type NSTYPE indicated by FD.  *//* Get currently used CPU and NUMA node.  *//* Get index of currently used CPU.  *//* Unshare the specified resources.  *//* Clone current process.  *//* Clone I/O context.  *//* New network namespace.  *//* New pid namespace.  *//* New user namespace.  *//* New ipcs.  *//* New utsname group.  *//* New cgroup namespace.  *//* Store TID in userlevel buffer in
					  the child.  *//* Set if the tracing process can't
				      force CLONE_PTRACE on this clone.  *//* Create clone detached.  *//* Register exit futex and memory
					    location to clear.  *//* Store TID in userlevel buffer
					   before MM copy.  *//* Set TLS info.  *//* Set to shared SVID SEM_UNDO semantics.  *//* Set to create new namespace.  *//* Set to add to same thread group.  *//* Set if we want to have the same
				     parent as the cloner.  *//* Set if the parent wants the child to
				     wake it up on mm_release.  *//* Set if tracing continues on the child.  *//* Set if a pidfd should be placed
				     in parent.  *//* Set if signal handlers shared.  *//* Set if open files shared between processes.  *//* Set if fs info shared between processes.  *//* Set if VM shared between processes.  *//* Signal mask to be sent at exit.  *//* Cloning flags.  *//* Scheduling algorithms.  *//* Definitions of constants and data structure for POSIX 1003.1b-1993
   scheduling interface.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__nstype__flags__fn__child_stack__arg/usr/include/x86_64-linux-gnu/bits/cpu-set.h__sched_cpufreecpu_set_t *__sched_cpualloc__sched_cpucountconst cpu_set_tconst cpu_set_t *cpu_set_t__cpu_mask__cpu_mask[16]unsigned long[16]1024__CPU_SETSIZE__NCPUBITS__bits__CPU_FREE(cpuset)__sched_cpufree (cpuset)__CPU_ALLOC(count)__sched_cpualloc (count)__CPU_ALLOC_SIZE(count)((((count) + __NCPUBITS - 1) / __NCPUBITS) * sizeof (__cpu_mask))__CPU_OP_S(setsize,destset,srcset1,srcset2,op)(__extension__ ({ cpu_set_t *__dest = (destset); const __cpu_mask *__arr1 = (srcset1)->__bits; const __cpu_mask *__arr2 = (srcset2)->__bits; size_t __imax = (setsize) / sizeof (__cpu_mask); size_t __i; for (__i = 0; __i < __imax; ++__i) ((__cpu_mask *) __dest->__bits)[__i] = __arr1[__i] op __arr2[__i]; __dest; }))__CPU_EQUAL_S(setsize,cpusetp1,cpusetp2)(__builtin_memcmp (cpusetp1, cpusetp2, setsize) == 0)__CPU_COUNT_S(setsize,cpusetp)__sched_cpucount (setsize, cpusetp)__CPU_ISSET_S(cpu,setsize,cpusetp)(__extension__ ({ size_t __cpu = (cpu); __cpu / 8 < (setsize) ? ((((const __cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)] & __CPUMASK (__cpu))) != 0 : 0; }))__CPU_CLR_S(cpu,setsize,cpusetp)(__extension__ ({ size_t __cpu = (cpu); __cpu / 8 < (setsize) ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)] &= ~__CPUMASK (__cpu)) : 0; }))__CPU_SET_S(cpu,setsize,cpusetp)(__extension__ ({ size_t __cpu = (cpu); __cpu / 8 < (setsize) ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)] |= __CPUMASK (__cpu)) : 0; }))__CPU_ZERO_S(setsize,cpusetp)do __builtin_memset (cpusetp, '\0', setsize); while (0)__CPUMASK(cpu)((__cpu_mask) 1 << ((cpu) % __NCPUBITS))__CPUELT(cpu)((cpu) / __NCPUBITS)(8 * sizeof (__cpu_mask))_BITS_CPU_SET_H__GNUC_PREREQ (2, 91)warn_unused_result91/* bits/cpu-set.h *//* Access functions for CPU masks.  *//* Data structure to describe CPU mask.  *//* Basic access functions.  *//* Type for array elements in 'cpu_set_t'.  *//* Size definition for CPU sets.  *//* Definition of the cpu_set_t structure used by the POSIX 1003.1b-1993
   scheduling interface.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__set__count__setsize__setp/usr/include/sched.h<bits/cpu-set.h><bits/sched.h><bits/types/struct_timespec.h>sched_getaffinitysched_setaffinitysched_rr_get_intervaltimespec *sched_get_priority_minsched_get_priority_maxsched_yieldsched_getschedulersched_setschedulerconst sched_paramconst sched_param *sched_param *sched_getparamsched_setparamCPU_FREE(cpuset)__CPU_FREE (cpuset)CPU_ALLOC(count)__CPU_ALLOC (count)CPU_ALLOC_SIZE(count)__CPU_ALLOC_SIZE (count)CPU_XOR_S(setsize,destset,srcset1,srcset2)__CPU_OP_S (setsize, destset, srcset1, srcset2, ^)CPU_OR_S(setsize,destset,srcset1,srcset2)__CPU_OP_S (setsize, destset, srcset1, srcset2, |)CPU_AND_S(setsize,destset,srcset1,srcset2)__CPU_OP_S (setsize, destset, srcset1, srcset2, &)CPU_XOR(destset,srcset1,srcset2)__CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, ^)CPU_OR(destset,srcset1,srcset2)__CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, |)CPU_AND(destset,srcset1,srcset2)__CPU_OP_S (sizeof (cpu_set_t), destset, srcset1, srcset2, &)CPU_EQUAL_S(setsize,cpusetp1,cpusetp2)__CPU_EQUAL_S (setsize, cpusetp1, cpusetp2)CPU_EQUAL(cpusetp1,cpusetp2)__CPU_EQUAL_S (sizeof (cpu_set_t), cpusetp1, cpusetp2)CPU_COUNT_S(setsize,cpusetp)__CPU_COUNT_S (setsize, cpusetp)CPU_ZERO_S(setsize,cpusetp)__CPU_ZERO_S (setsize, cpusetp)CPU_ISSET_S(cpu,setsize,cpusetp)__CPU_ISSET_S (cpu, setsize, cpusetp)CPU_CLR_S(cpu,setsize,cpusetp)__CPU_CLR_S (cpu, setsize, cpusetp)CPU_SET_S(cpu,setsize,cpusetp)__CPU_SET_S (cpu, setsize, cpusetp)CPU_COUNT(cpusetp)__CPU_COUNT_S (sizeof (cpu_set_t), cpusetp)CPU_ZERO(cpusetp)__CPU_ZERO_S (sizeof (cpu_set_t), cpusetp)CPU_ISSET(cpu,cpusetp)__CPU_ISSET_S (cpu, sizeof (cpu_set_t), cpusetp)CPU_CLR(cpu,cpusetp)__CPU_CLR_S (cpu, sizeof (cpu_set_t), cpusetp)CPU_SET(cpu,cpusetp)__CPU_SET_S (cpu, sizeof (cpu_set_t), cpusetp)CPU_SETSIZE__sched_priority/* sched.h *//* Get the CPU affinity for a task *//* Set the CPU affinity for a task *//* Access macros for `cpu_set'.  *//* Get the SCHED_RR interval for the named process.  *//* Get minimum priority value for a scheduler.  *//* Get maximum priority value for a scheduler.  *//* Yield the processor.  *//* Retrieve scheduling algorithm for a particular purpose.  *//* Set scheduling algorithm and/or parameters for a process.  *//* Retrieve scheduling parameters for a particular process.  *//* Set scheduling parameters for a process.  *//* Backward compatibility.  *//* Get system specific constant and data structure definitions.  *//* Get type definitions.  *//* Definitions for POSIX 1003.1b-1993 (aka POSIX.4) scheduling interface.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__cpusetsize__cpuset__t__algorithm__policy__param/usr/include/pthread.h<bits/pthread_stack_min-dynamic.h><bits/types/struct___jmp_buf_tag.h><bits/types/__sigset_t.h><bits/wordsize.h><bits/setjmp.h><bits/pthreadtypes.h><bits/endian.h><sched.h>intpthread_equalpthread_equal (pthread_t __thread1, pthread_t __thread2)pthread_atforkpthread_getcpuclockid__clockid_t *pthread_setspecificpthread_getspecificpthread_key_deletepthread_key_createpthread_key_t *pthread_barrierattr_setpsharedpthread_barrierattr_t *union <unnamed> *pthread_barrierattr_getpsharedconst pthread_barrierattr_tconst pthread_barrierattr_t *const pthread_barrierattr_t *__restrict__int *__restrict__pthread_barrierattr_destroypthread_barrierattr_initpthread_barrier_waitpthread_barrier_t *pthread_barrier_destroypthread_barrier_initpthread_barrier_t *__restrict__pthread_spin_unlockpthread_spinlock_t *pthread_spin_trylockpthread_spin_lockpthread_spin_destroypthread_spin_initpthread_condattr_setclockpthread_condattr_t *pthread_condattr_getclockconst pthread_condattr_tconst pthread_condattr_t *const pthread_condattr_t *__restrict____clockid_t *__restrict__pthread_condattr_setpsharedpthread_condattr_getpsharedpthread_condattr_destroypthread_condattr_initpthread_cond_clockwaitpthread_cond_t *pthread_cond_t *__restrict__pthread_mutex_t *pthread_mutex_t *__restrict__const timespecconst timespec *const timespec *__restrict__pthread_cond_timedwaitpthread_cond_waitpthread_cond_broadcastpthread_cond_signalpthread_cond_destroypthread_cond_initpthread_rwlockattr_setkind_nppthread_rwlockattr_t *pthread_rwlockattr_getkind_npconst pthread_rwlockattr_tconst pthread_rwlockattr_t *const pthread_rwlockattr_t *__restrict__pthread_rwlockattr_setpsharedpthread_rwlockattr_getpsharedpthread_rwlockattr_destroypthread_rwlockattr_initpthread_rwlock_unlockpthread_rwlock_t *pthread_rwlock_clockwrlockpthread_rwlock_t *__restrict__pthread_rwlock_timedwrlockpthread_rwlock_trywrlockpthread_rwlock_wrlockpthread_rwlock_clockrdlockpthread_rwlock_timedrdlockpthread_rwlock_tryrdlockpthread_rwlock_rdlockpthread_rwlock_destroypthread_rwlock_initpthread_mutexattr_setrobust_nppthread_mutexattr_t *pthread_mutexattr_setrobustpthread_mutexattr_getrobust_nppthread_mutexattr_getrobustconst pthread_mutexattr_tconst pthread_mutexattr_t *pthread_mutexattr_setprioceilingpthread_mutexattr_getprioceilingconst pthread_mutexattr_t *__restrict__pthread_mutexattr_setprotocolpthread_mutexattr_getprotocolpthread_mutexattr_settypepthread_mutexattr_gettypepthread_mutexattr_setpsharedpthread_mutexattr_getpsharedpthread_mutexattr_destroypthread_mutexattr_initpthread_mutex_consistent_nppthread_mutex_consistentpthread_mutex_setprioceilingpthread_mutex_getprioceilingconst pthread_mutex_tconst pthread_mutex_t *const pthread_mutex_t *__restrict__pthread_mutex_unlockpthread_mutex_clocklockpthread_mutex_timedlockpthread_mutex_lockpthread_mutex_trylockpthread_mutex_destroypthread_mutex_init__sigsetjmp_cancel__cancel_jmp_buf_tag[1](struct __cancel_jmp_buf_tag __env[1], int __savemask)__sigsetjmp__pthread_unwind_next__pthread_unwind_buf_t *__pthread_unregister_cancel_restore__pthread_register_cancel_defer__pthread_unregister_cancel__pthread_register_cancelpthread_testcancelpthread_cancelpthread_setcanceltypepthread_setcancelstatepthread_oncepthread_once_t *pthread_getaffinity_nppthread_setaffinity_nppthread_yieldpthread_setconcurrencypthread_getconcurrencypthread_setname_nppthread_getname_nppthread_setschedpriopthread_getschedparamsched_param *__restrict__pthread_setschedparampthread_getattr_nppthread_attr_t *pthread_setattr_default_npconst pthread_attr_tconst pthread_attr_t *pthread_attr_getsigmask_np__sigset_t *pthread_attr_setsigmask_npconst __sigset_tconst __sigset_t *pthread_getattr_default_nppthread_attr_getaffinity_nppthread_attr_setaffinity_nppthread_attr_setstackpthread_attr_getstackconst pthread_attr_t *__restrict__void **void **__restrict__size_t *__restrict__pthread_attr_setstacksizepthread_attr_getstacksizepthread_attr_setstackaddrpthread_attr_getstackaddrpthread_attr_setscopepthread_attr_getscopepthread_attr_setinheritschedpthread_attr_getinheritschedpthread_attr_setschedpolicypthread_attr_getschedpolicypthread_attr_setschedparampthread_attr_t *__restrict__const sched_param *__restrict__pthread_attr_getschedparampthread_attr_setguardsizepthread_attr_getguardsizepthread_attr_setdetachstatepthread_attr_getdetachstatepthread_attr_destroypthread_attr_initpthread_selfpthread_detachpthread_clockjoin_nppthread_timedjoin_nppthread_tryjoin_nppthread_joinpthread_exitpthread_createpthread_t *pthread_t *__restrict____pthread_cleanup_frame__pthread_unwind_buf_taligned__cancel_jmp_buf_tagPTHREAD_CANCEL_DEFERREDPTHREAD_CANCEL_ASYNCHRONOUSPTHREAD_CANCEL_ENABLEPTHREAD_CANCEL_DISABLE_pthread_cleanup_bufferPTHREAD_PROCESS_PRIVATEPTHREAD_PROCESS_SHAREDPTHREAD_SCOPE_SYSTEMPTHREAD_SCOPE_PROCESSPTHREAD_INHERIT_SCHEDPTHREAD_EXPLICIT_SCHEDPTHREAD_RWLOCK_PREFER_READER_NPPTHREAD_RWLOCK_PREFER_WRITER_NPPTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NPPTHREAD_RWLOCK_DEFAULT_NPPTHREAD_PRIO_NONEPTHREAD_PRIO_INHERITPTHREAD_PRIO_PROTECTPTHREAD_MUTEX_STALLEDPTHREAD_MUTEX_STALLED_NPPTHREAD_MUTEX_ROBUSTPTHREAD_MUTEX_ROBUST_NPPTHREAD_MUTEX_TIMED_NPPTHREAD_MUTEX_RECURSIVE_NPPTHREAD_MUTEX_ERRORCHECK_NPPTHREAD_MUTEX_ADAPTIVE_NPPTHREAD_MUTEX_NORMALPTHREAD_MUTEX_RECURSIVEPTHREAD_MUTEX_ERRORCHECKPTHREAD_MUTEX_DEFAULTPTHREAD_MUTEX_FAST_NPPTHREAD_CREATE_JOINABLEPTHREAD_CREATE_DETACHED__cancel_type__do_it__cancel_arg__cancel_routinevoid *[4]__pad__cancel_jmp_buf__mask_was_saved_pthread_cleanup_buffer *__prev__canceltype__routinepthread_cleanup_pop_restore_np(execute)do { } while (0); } while (0); __pthread_unregister_cancel_restore (&__cancel_buf); if (execute) __cancel_routine (__cancel_arg); } while (0)pthread_cleanup_push_defer_np(routine,arg)do { __pthread_unwind_buf_t __cancel_buf; void (*__cancel_routine) (void *) = (routine); void *__cancel_arg = (arg); int __not_first_call = __sigsetjmp_cancel (__cancel_buf.__cancel_jmp_buf, 0); if (__glibc_unlikely (__not_first_call)) { __cancel_routine (__cancel_arg); __pthread_unwind_next (&__cancel_buf); } __pthread_register_cancel_defer (&__cancel_buf); do {pthread_cleanup_pop(execute)do { } while (0); } while (0); __pthread_unregister_cancel (&__cancel_buf); if (execute) __cancel_routine (__cancel_arg); } while (0)pthread_cleanup_push(routine,arg)do { __pthread_unwind_buf_t __cancel_buf; void (*__cancel_routine) (void *) = (routine); void *__cancel_arg = (arg); int __not_first_call = __sigsetjmp_cancel (__cancel_buf.__cancel_jmp_buf, 0); if (__glibc_unlikely (__not_first_call)) { __cancel_routine (__cancel_arg); __pthread_unwind_next (&__cancel_buf); } __pthread_register_cancel (&__cancel_buf); do {__cleanup_fct_attributePTHREAD_ATTR_NO_SIGMASK_NPPTHREAD_BARRIER_SERIAL_THREADPTHREAD_ONCE_INITPTHREAD_CANCELED((void *) -1)PTHREAD_COND_INITIALIZER{ { {0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0} } }PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP{ { __PTHREAD_RWLOCK_INITIALIZER (PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP) } }PTHREAD_RWLOCK_INITIALIZER{ { __PTHREAD_RWLOCK_INITIALIZER (PTHREAD_RWLOCK_DEFAULT_NP) } }PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP{ { __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_ADAPTIVE_NP) } }PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP{ { __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_ERRORCHECK_NP) } }PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP{ { __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_RECURSIVE_NP) } }PTHREAD_MUTEX_INITIALIZER{ { __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_TIMED_NP) } }_PTHREAD_Hdefined __USE_UNIX98 || defined __USE_XOPEN2K8defined __USE_POSIX199506 || defined __USE_UNIX98defined __USE_UNIX98 || defined __USE_XOPEN2K__REDIRECTdefined __GNUC__ && defined __EXCEPTIONSSHARED__GNUC_PREREQ (11, 0)(2)access__none__,(1, 2)(1, 2, 4)(1, 2, 3)(1, 3)"pthread_mutexattr_setrobust_np is deprecated, use pthread_mutexattr_setrobust"pthread_mutexattr_setrobust_np is deprecated, use pthread_mutexattr_setrobustchar[78](pthread_mutexattr_t *, int)"pthread_mutexattr_getrobust_np is deprecated, use pthread_mutexattr_getrobust"pthread_mutexattr_getrobust_np is deprecated, use pthread_mutexattr_getrobust(pthread_mutexattr_t *, int *)"pthread_mutex_consistent_np is deprecated, use pthread_mutex_consistent"pthread_mutex_consistent_np is deprecated, use pthread_mutex_consistentchar[72](pthread_mutex_t *)returns_twiceweak(3)"pthread_yield is deprecated, use sched_yield instead"pthread_yield is deprecated, use sched_yield insteadchar[53](void)(2, 3)const"__sigsetjmp"__USER_LABEL_PREFIX__"sched_yield""pthread_mutexattr_setrobust""pthread_mutexattr_getrobust""pthread_mutex_consistent"/* pthread.h *//* Optimizations.  *//* Install handlers to be called when a new process is created with FORK.
   The PREPARE handler is called in the parent process just before performing
   FORK. The PARENT handler is called in the parent process just after FORK.
   The CHILD handler is called in the child process.  Each of the three
   handlers can be NULL, meaning that no handler needs to be called at that
   point.
   PTHREAD_ATFORK can be called several times, in which case the PREPARE
   handlers are called in LIFO order (last added with PTHREAD_ATFORK,
   first called before FORK), and the PARENT and CHILD handlers are called
   in FIFO (first added, first called).  *//* Get ID of CPU-time clock for thread THREAD_ID.  *//* Store POINTER in the thread-specific data slot identified by KEY. *//* Return current value of the thread-specific data slot identified by KEY.  *//* Destroy KEY.  *//* Create a key value identifying a location in the thread-specific
   data area.  Each thread maintains a distinct thread-specific data
   area.  DESTR_FUNCTION, if non-NULL, is called with the value
   associated to that key when the key is destroyed.
   DESTR_FUNCTION is not called if the value associated is NULL when
   the key is destroyed.  *//* Functions for handling thread-specific data.  *//* Set the process-shared flag of the barrier attribute ATTR.  *//* Get the process-shared flag of the barrier attribute ATTR.  *//* Destroy previously dynamically initialized barrier attribute ATTR.  *//* Initialize barrier attribute ATTR.  *//* Wait on barrier BARRIER.  *//* Destroy a previously dynamically initialized barrier BARRIER.  *//* Initialize BARRIER with the attributes in ATTR.  The barrier is
   opened when COUNT waiters arrived.  *//* Functions to handle barriers.  *//* Release spinlock LOCK.  *//* Try to lock spinlock LOCK.  *//* Wait until spinlock LOCK is retrieved.  *//* Destroy the spinlock LOCK.  *//* Initialize the spinlock LOCK.  If PSHARED is nonzero the spinlock can
   be shared between different processes.  *//* Functions to handle spinlocks.  *//* Set the clock selected for the condition variable attribute ATTR.  *//* Get the clock selected for the condition variable attribute ATTR.  *//* Set the process-shared flag of the condition variable attribute ATTR.  *//* Get the process-shared flag of the condition variable attribute ATTR.  *//* Destroy condition variable attribute ATTR.  *//* Initialize condition variable attribute ATTR.  *//* Functions for handling condition variable attributes.  *//* Wait for condition variable COND to be signaled or broadcast until
   ABSTIME measured by the specified clock. MUTEX is assumed to be
   locked before. CLOCK is the clock to use. ABSTIME is an absolute
   time specification against CLOCK's epoch.

   This function is a cancellation point and therefore not marked with
   __THROW. *//* Wait for condition variable COND to be signaled or broadcast until
   ABSTIME.  MUTEX is assumed to be locked before.  ABSTIME is an
   absolute time specification; zero is the beginning of the epoch
   (00:00:00 GMT, January 1, 1970).

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Wait for condition variable COND to be signaled or broadcast.
   MUTEX is assumed to be locked before.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Wake up all threads waiting for condition variables COND.  *//* Wake up one thread waiting for condition variable COND.  *//* Destroy condition variable COND.  *//* Initialize condition variable COND using attributes ATTR, or use
   the default values if later is NULL.  *//* Functions for handling conditional variables.  *//* Set reader/write preference.  *//* Return current setting of reader/writer preference.  *//* Set process-shared attribute of ATTR to PSHARED.  *//* Return current setting of process-shared attribute of ATTR in PSHARED.  *//* Destroy attribute object ATTR.  *//* Initialize attribute object ATTR with default values.  *//* Functions for handling read-write lock attributes.  *//* Unlock RWLOCK.  *//* Try to acquire write lock for RWLOCK or return after specfied time.  *//* Try to acquire write lock for RWLOCK.  *//* Acquire write lock for RWLOCK.  *//* Try to acquire read lock for RWLOCK or return after specfied time.  *//* Try to acquire read lock for RWLOCK.  *//* Acquire read lock for RWLOCK.  *//* Destroy read-write lock RWLOCK.  *//* Initialize read-write lock RWLOCK using attributes ATTR, or use
   the default values if later is NULL.  *//* Functions for handling read-write locks.  *//* Set the robustness flag of the mutex attribute ATTR.  *//* Get the robustness flag of the mutex attribute ATTR.  *//* Set the mutex prioceiling attribute in *ATTR to PRIOCEILING.  *//* Return in *PRIOCEILING the mutex prioceiling attribute in *ATTR.  *//* Set the mutex protocol attribute in *ATTR to PROTOCOL (either
   PTHREAD_PRIO_NONE, PTHREAD_PRIO_INHERIT, or PTHREAD_PRIO_PROTECT).  *//* Return in *PROTOCOL the mutex protocol attribute in *ATTR.  *//* Set the mutex kind attribute in *ATTR to KIND (either PTHREAD_MUTEX_NORMAL,
   PTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_ERRORCHECK, or
   PTHREAD_MUTEX_DEFAULT).  *//* Return in *KIND the mutex kind attribute in *ATTR.  *//* Set the process-shared flag of the mutex attribute ATTR.  *//* Get the process-shared flag of the mutex attribute ATTR.  *//* Destroy mutex attribute object ATTR.  *//* Initialize mutex attribute object ATTR with default attributes
   (kind is PTHREAD_MUTEX_TIMED_NP).  *//* Functions for handling mutex attributes.  *//* Declare the state protected by MUTEX as consistent.  *//* Set the priority ceiling of MUTEX to PRIOCEILING, return old
   priority ceiling value in *OLD_CEILING.  *//* Get the priority ceiling of MUTEX.  *//* Unlock a mutex.  *//* Wait until lock becomes available, or specified time passes. *//* Lock a mutex.  *//* Try locking a mutex.  *//* Destroy a mutex.  *//* Initialize a mutex.  *//* Mutex handling.  *//* Function used in the macros.  Calling __sigsetjmp, with its first
   argument declared as an array, results in a -Wstringop-overflow
   warning from GCC 11 because struct pthread_unwind_buf is smaller
   than jmp_buf.  The calls from the macros have __SAVEMASK set to 0,
   so nothing beyond the common prefix is used and this warning is a
   false positive.  Use an alias with its first argument declared to
   use the type in the macros if possible to avoid this warning.  *//* Internal interface to initiate cleanup.  *//* Empty to allow label before pthread_cleanup_pop.  *//* Remove a cleanup handler as pthread_cleanup_pop does, but also
   restores the cancellation type that was in effect when the matching
   pthread_cleanup_push_defer was called.  *//* NOTREACHED *//* Install a cleanup handler as pthread_cleanup_push does, but also
   saves the current cancellation type and sets it to deferred
   cancellation.  *//* Remove a cleanup handler installed by the matching pthread_cleanup_push.
   If EXECUTE is non-zero, the handler function is called. *//* Install a cleanup handler: ROUTINE will be called with arguments ARG
   when the thread is canceled or calls pthread_exit.  ROUTINE will also
   be called with arguments ARG when the matching pthread_cleanup_pop
   is executed with non-zero EXECUTE argument.

   pthread_cleanup_push and pthread_cleanup_pop are macros and must always
   be used in matching pairs at the same nesting level of braces.  *//* Function called to call the cleanup handler.  As an extern inline
   function the compiler is free to decide inlining the change when
   needed or fall back on the copy which must exist somewhere
   else.  *//* Class to handle cancellation handler invocation.  *//* Structure to hold the cleanup handler information.  *//* No special attributes by default.  *//* Cancellation handling with integration into exception handling.  *//* Test for pending cancellation for the current thread and terminate
   the thread as per pthread_exit(PTHREAD_CANCELED) if it has been
   cancelled.  *//* Cancel THREAD immediately or at the next possibility.  *//* Set cancellation state of current thread to TYPE, returning the old
   type in *OLDTYPE if OLDTYPE is not NULL.  *//* Set cancelability state of current thread to STATE, returning old
   state in *OLDSTATE if OLDSTATE is not NULL.  *//* Functions for handling cancellation.

   Note that these functions are explicitly not marked to not throw an
   exception in C++ code.  If cancellation is implemented by unwinding
   this is necessary to have the compiler generate the unwind information.  *//* Guarantee that the initialization function INIT_ROUTINE will be called
   only once, even if pthread_once is executed several times with the
   same ONCE_CONTROL argument. ONCE_CONTROL must point to a static or
   extern variable initialized to PTHREAD_ONCE_INIT.

   The initialization functions might throw exception which is why
   this function is not marked with __THROW.  *//* Functions for handling initialization.  *//* Get bit set in CPUSET representing the processors TH can run on.  *//* Limit specified thread TH to run only on the processors represented
   in CPUSET.  *//* Set new concurrency level to LEVEL.  *//* Determine level of concurrency.  *//* Set thread name visible in the kernel and its interfaces.  *//* Get thread name visible in the kernel and its interfaces.  *//* Set the scheduling priority for TARGET_THREAD.  *//* Return in *POLICY and *PARAM the scheduling parameters for TARGET_THREAD. *//* Set the scheduling parameters for TARGET_THREAD according to POLICY
   and *PARAM.  *//* Functions for scheduling control.  *//* Initialize thread attribute *ATTR with attributes corresponding to the
   already running thread TH.  It shall be called on uninitialized ATTR
   and destroyed with pthread_attr_destroy when no longer needed.  *//* Set the default attributes to be used by pthread_create in this
   process.  *//* Special return value from pthread_attr_getsigmask_np if the signal
   mask has not been set.  *//* Store the signal mask of *ATTR in *SIGMASK.  If there is no signal
   mask stored, return PTHREAD_ATTR_NOSIGMASK_NP.  Return zero on
   success.  *//* Store *SIGMASK as the signal mask for the new thread in *ATTR.  *//* Get the default attributes used by pthread_create in this process.  *//* Get bit set in CPUSET representing the processors threads created with
   ATTR can run on.  *//* Thread created with attribute ATTR will be limited to run only on
   the processors represented in CPUSET.  *//* The following two interfaces are intended to replace the last two.  They
   require setting the address as well as the size since only setting the
   address will make the implementation on some architectures impossible.  *//* Return the previously set address for the stack.  *//* Add information about the minimum stack size needed for the thread
   to be started.  This size must never be less than PTHREAD_STACK_MIN
   and must also not exceed the system limits.  *//* Return the currently used minimal stack size.  *//* Set the starting address of the stack of the thread to be created.
   Depending on whether the stack grows up or down the value must either
   be higher or lower than all the address in the memory block.  The
   minimal size of the block must be PTHREAD_STACK_MIN.  *//* Set scheduling contention scope in *ATTR according to SCOPE.  *//* Return in *SCOPE the scheduling contention scope of *ATTR.  *//* Set scheduling inheritance mode in *ATTR according to INHERIT.  *//* Return in *INHERIT the scheduling inheritance mode of *ATTR.  *//* Set scheduling policy in *ATTR according to POLICY.  *//* Return in *POLICY the scheduling policy of *ATTR.  *//* Set scheduling parameters (priority, etc) in *ATTR according to PARAM.  *//* Return in *PARAM the scheduling parameters of *ATTR.  *//* Set the size of the guard area created for stack overflow protection.  *//* Get the size of the guard area created for stack overflow protection.  *//* Set detach state attribute.  *//* Get detach state attribute.  *//* Destroy thread attribute *ATTR.  *//* Initialize thread attribute *ATTR with default attributes
   (detachstate is PTHREAD_JOINABLE, scheduling policy is SCHED_OTHER,
    no user-provided stack).  *//* Thread attribute handling.  *//* Compare two thread identifiers.  *//* Obtain the identifier of the current thread.  *//* Indicate that the thread TH is never to be joined with PTHREAD_JOIN.
   The resources of TH will therefore be freed immediately when it
   terminates, instead of waiting for another thread to perform PTHREAD_JOIN
   on it.  *//* Make calling thread wait for termination of the thread TH, but only
   until TIMEOUT measured against the clock specified by CLOCKID.  The
   exit status of the thread is stored in *THREAD_RETURN, if
   THREAD_RETURN is not NULL.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Make calling thread wait for termination of the thread TH, but only
   until TIMEOUT.  The exit status of the thread is stored in
   *THREAD_RETURN, if THREAD_RETURN is not NULL.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Check whether thread TH has terminated.  If yes return the status of
   the thread in *THREAD_RETURN, if THREAD_RETURN is not NULL.  *//* Make calling thread wait for termination of the thread TH.  The
   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN
   is not NULL.

   This function is a cancellation point and therefore not marked with
   __THROW.  *//* Terminate calling thread.

   The registered cleanup handlers are called via exception handling
   so we cannot mark this function with __THROW.*//* Create a new thread, starting with execution of START-ROUTINE
   getting passed ARG.  Creation attributed come from ATTR.  The new
   handle is stored in *NEWTHREAD.  *//* Value returned by 'pthread_barrier_wait' for one of the threads after
   the required number of threads have called this function.
   -1 is distinct from 0 and all errno constants *//* Single execution handling.  *//* Cancellation *//* Chaining of cleanup functions.  *//* Saved cancellation type. *//* Its argument.  *//* Function to call.  *//* Cleanup buffers *//* Conditional variable handling.  *//* Process shared or private flag.  *//* Scope handling.  *//* Scheduler inheritance.  *//* Unix98 or XOpen2K *//* Read-write lock initializers.  *//* Read-write lock types.  *//* Mutex protocols.  *//* Robust mutex or not flags.  *//* For compatibility.  *//* Mutex types.  *//* Detach state.  *//* Copyright (C) 2002-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__thread1__thread2__prepare__parent__child__thread_id__clock_id__key__pointer__destr_function__attr__pshared__barrier__lock__cond__mutex__abstime__cond_attr__pref__rwlock__clockid__robustness__prioceiling__protocol__kind__old_ceiling__mutexattr__env__savemask__buf__th__type__oldtype__state__oldstate__once_control__init_routine__level__target_thread__name__buflen__priosigmask__stackaddr__stacksize__scope__inherit__guardsize__detachstate__thread_return__retval__newthread__start_routine/usr/include/gc/gc_version.hGC_VERSION_MICROGC_TMP_VERSION_MICROGC_VERSION_MINORGC_TMP_VERSION_MINORGC_VERSION_MAJORGC_TMP_VERSION_MAJORdefined(GC_H)GC_TMP_VERSION_MAJOR != GC_VERSION_MAJOR \/* !GC_VERSION_MAJOR *//* 8.0.6 *//* it to keep the old-style build process working.              *//* Eventually this one may become unnecessary.  For now we need *//* The version here should match that in configure/configure.ac *//* release has the biggest "micro" number).                             *//* is prepared incrementing "micro" part to odd value (the most stable  *//* "micro" number still zero), whenever a defect is fixed a new release *//* and a release is prepared, "minor" number is incremented (keeping    *//* "minor" number (and "micro" part is 0); when development is finished *//* The policy regarding version numbers: development code has odd       *//* This should never be included directly; it is included only from gc.h. *//*
 * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.
 * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.
 * Copyright (c) 1998 by Fergus Henderson.  All rights reserved.
 * Copyright (c) 2000-2009 by Hewlett-Packard Development Company.
 * All rights reserved.
 *
 * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
 * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
 *
 * Permission is hereby granted to use or copy this program
 * for any purpose,  provided the above notices are retained on all copies.
 * Permission to modify the code and to distribute modified code is granted,
 * provided the above notices are retained, and a notice that the code was
 * modified is included with the above copyright notice.
 *//usr/include/gc/usr/include/gc/gc_config_macros.hGC_PTHREAD_EXIT_ATTRIBUTE__attribute__((__noreturn__))GC_HAVE_PTHREAD_EXITGC_CAN_SAVE_CALL_STACKSGC_HAVE_BUILTIN_BACKTRACEGC_ATTR_DEPRECATED__attribute__((__deprecated__))GC_ATTR_NONNULL(argnum)__attribute__((__nonnull__(argnum)))GC_ATTR_CALLOC_SIZE(n,s)__attribute__((__alloc_size__(n, s)))GC_ATTR_ALLOC_SIZE(argnum)__attribute__((__alloc_size__(argnum)))GC_ATTR_CALLOC_SIZEGC_ATTR_MALLOC__attribute__((__malloc__))GC_CALLBACKGC_CALLGC_API__GCGC_PTHREADSGC_LINUX_THREADSGC_GNUC_PREREQ(major,minor)((__GNUC__ << 16) + __GNUC_MINOR__ >= ((major) << 16) + (minor))defined(__GNUC__) && defined(__GNUC_MINOR__)defined(SOLARIS_THREADS) || defined(_SOLARIS_THREADS) \GC_SOLARIS_THREADSdefined(IRIX_THREADS)defined(DGUX_THREADS) && !defined(GC_DGUX386_THREADS)defined(AIX_THREADS)defined(HPUX_THREADS)defined(OSF1_THREADS)defined(LINUX_THREADS)defined(WIN32_THREADS)defined(RTEMS_THREADS)defined(USE_LD_WRAP)defined(GC_WIN32_PTHREADS) && !defined(GC_WIN32_THREADS)defined(GC_AIX_THREADS) || defined(GC_DARWIN_THREADS) \GC_THREADSdefined(GC_THREADS)defined(__linux__)defined(__OpenBSD__)defined(_PA_RISC1_1) || defined(_PA_RISC2_0) || defined(hppa) \defined(__HAIKU__)defined(__DragonFly__) || defined(__FreeBSD_kernel__) \defined(__alpha) || defined(__alpha__)(defined(mips) || defined(__mips) || defined(_mips)) \defined(__sparc)defined(__APPLE__) && defined(__MACH__)defined(DGUX) && (defined(i386) || defined(__i386__))defined(_AIX)(defined(_WIN32) || defined(_MSC_VER) || defined(__BORLANDC__) \defined(__rtems__) && (defined(i386) || defined(__i386__))(!defined(GC_WIN32_THREADS) || defined(GC_WIN32_PTHREADS) \!defined(_PTHREADS) && defined(GC_NETBSD_THREADS)defined(GC_DGUX386_THREADS) && !defined(_POSIX4A_DRAFT10_SOURCE)!defined(_REENTRANT) && defined(GC_PTHREADS) && !defined(GC_WIN32_THREADS)!defined(_WIN32_WCE) || defined(__GNUC__)defined(__MINGW32__) && !defined(_WIN32_WCE)_PTRDIFF_T_DEFINED!defined(GC_NOT_DLL) && !defined(GC_DLL) \defined(GC_DLL) && !defined(GC_API)defined(__CEGCC__)defined(GC_BUILD)defined(__MINGW32__)defined(__cplusplus) && defined(GC_BUILD)defined(GC_BUILD) || defined(__MINGW32_DELAY_LOAD__)defined(_MSC_VER) || defined(__DMC__) || defined(__BORLANDC__) \GC_BUILDdefined(__WATCOMC__)defined(__SYMBIAN32__)defined(__GNUC__)defined(GC_BUILD) && !defined(GC_NO_VISIBILITY) \GC_OOM_FUNC_RETURNS_ALIASGC_GNUC_PREREQ(3, 1)defined(_MSC_VER) && (_MSC_VER >= 1900) && !defined(__EDG__)defined(_MSC_VER) && _MSC_VER >= 1400GC_ATTR_ALLOC_SIZE__clang____has_attribute(__alloc_size__)GC_GNUC_PREREQ(4, 3) && !defined(__ICC)GC_ATTR_NONNULLGC_GNUC_PREREQ(4, 0)defined(_MSC_VER) && _MSC_VER >= 1200defined(__sgi) && !defined(__GNUC__) && _COMPILER_VERSION >= 720defined(__linux__) || defined(__GLIBC__)!defined(__native_client__)(__GLIBC__ == 2 && __GLIBC_MINOR__ >= 1 || __GLIBC__ > 2) \defined(__i386__) || defined(__amd64__) || defined(__x86_64__)defined(GC_HAVE_BUILTIN_BACKTRACE) && !defined(GC_CAN_SAVE_CALL_STACKS)defined(__sparc__)(defined(__linux__) || defined(__DragonFly__) || defined(__FreeBSD__) \GC_GNUC_PREREQ(2, 95)GC_GNUC_PREREQ(4, 0) && (defined(__i386__) || defined(__amd64__) \(defined(GC_DARWIN_THREADS) || defined(GC_WIN32_PTHREADS) \defined(__native_client__)GC_PTHREAD_CREATE_CONST!defined(GC_HAVE_PTHREAD_EXIT) \GC_GNUC_PREREQ(2, 7)defined(__NORETURN)(!defined(GC_HAVE_PTHREAD_EXIT) || defined(__native_client__)) \__linux____x86_64____amd64__/* GC_PTHREADS *//* Either there is no pthread_cancel() or no need to intercept it.  *//* used in Solaris *//* Intercept pthread_exit on Linux and Solaris.     *//* does not have "noreturn" attribute.                              *//* "const" for its "attr" argument; also, NaCl pthread_exit() one   *//* At present, NaCl pthread_create() prototype does not have        *//* Either there is no pthread_sigmask() or no need to intercept it. *//* Either there is no dlopen() or we do not need to intercept it.   *//* !GC_CAN_SAVE_CALL_STACKS *//* Just pass 0 for gcc compatibility.       *//* and probably others... *//* how to generate call stacks.                                     *//* gcc knows how to retrieve return address, but we don't know      *//* retrieve the call chain.                                             *//* This may also be desirable if it is possible but expensive to        *//* of compilers.                                                        *//* used, in order to keep the interface consistent, and allow mixing    *//* We make this decision independent of whether gcc is actually being   *//* gcc is normally used, we go ahead and define GC_ADD_CALLER.          *//* If we're on a platform on which we can't save call stacks, but       *//* version 12.0+ (MSVC 6.0+) *//* GLIBC *//* 'alloc_size' attribute improves __builtin_object_size correctness. *//* by using custom GC_oom_func then define GC_OOM_FUNC_RETURNS_ALIAS. *//* when the function returns).  If the client code violates this rule *//* non-NULL pointer it returns cannot alias any other pointer valid   *//* (to tell the compiler that a function may be treated as if any     *//* 'malloc' attribute should be used for all malloc-like functions    *//* GC_DLL *//* Only matters if used in conjunction with -fvisibility=hidden option. *//* _WIN32_WCE *//* ptrdiff_t is not defined *//* size_t is defined here *//* Yet more kludges for WinCE.        *//* as well?                                                         *//* Perhaps this should be included in pure msft environments        *//* We mention uintptr_t.                                            *//* on this were previously included.                                  *//* Better late than never.  This fails if system headers that depend  *//* Posix threads. *//* GC_THREADS *//* Either posix or native Win32 threads. *//* && !Linux *//* && !Linux && !xBSD *//* Using pthreads-win32 library (or other Win32 implementation).  *//* GC_SOLARIS_THREADS now means pthreads.                     *//* We no longer support old style Solaris threads.            *//* will disappear shortly.  Use the GC_ names.                          *//* Some tests for old macros.  These violate our namespace rules and    *//* FALSE *//* Convenient internal macro to test version of GCC.    *//* We separate it only to make gc.h more suitable as documentation.       *//usr/include/x86_64-linux-gnu/bits/dlfcn.h_dl_mcount_wrapper_checkDL_CALL_FCT(fctp,args)(_dl_mcount_wrapper_check ((void *) (fctp)), (*(fctp)) args)RTLD_NODELETE0x01000RTLD_LOCALRTLD_GLOBAL0x00100RTLD_DEEPBIND0x00008RTLD_NOLOAD0x00004RTLD_BINDING_MASK0x3RTLD_NOW0x00002RTLD_LAZY0x00001_DLFCN_H/* This function calls the profiling functions.  *//* To support profiling of shared objects it is a good idea to call
   the function found using `dlsym' using the following macro since
   these calls do not use the PLT.  But this would mean the dynamic
   loader has no chance to find out when the function is called.  The
   macro applies the necessary magic so that profiling is possible.
   Rewrite
	foo = (*fctp) (arg1, arg2);
   into
        foo = DL_CALL_FCT (fctp, (arg1, arg2));
*//* Do not delete object when closed.  *//* Unix98 demands the following flag which is the inverse to RTLD_GLOBAL.
   The implementation does this by default and so we can define the
   value to zero.  *//* If the following bit is set in the MODE argument to `dlopen',
   the symbols of the loaded object and its dependencies are made
   visible as if the object were linked directly into the program.  *//* Use deep binding.  *//* Do not load the object.  *//* Mask of binding time value.  *//* Immediate function call binding.  *//* Lazy function call binding.  *//* The MODE argument to `dlopen' contains one of the following: *//* System dependent definitions for run-time dynamic loading.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__selfpc/usr/include/x86_64-linux-gnu/bits/dl_find_object.hDLFO_EH_SEGMENT_TYPEPT_GNU_EH_FRAMEDLFO_STRUCT_HAS_EH_COUNTDLFO_STRUCT_HAS_EH_DBASE/* x86 definitions for finding objects.
   Copyright (C) 2021-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/dlfcn.h<bits/dl_find_object.h><bits/dlfcn.h>_dl_find_objectdl_find_object *dlinfodladdr1Dl_info *dladdrdlerrordlvsymconst char *__restrict__dlmopendlsymdlclosedlopendl_find_objectlink_mapDl_serinfoDl_serpathRTLD_DI_LMIDRTLD_DI_LINKMAPRTLD_DI_CONFIGADDRRTLD_DI_SERINFORTLD_DI_SERINFOSIZERTLD_DI_ORIGINRTLD_DI_PROFILENAMERTLD_DI_PROFILEOUTRTLD_DI_TLS_MODIDRTLD_DI_TLS_DATARTLD_DI_MAXRTLD_DL_SYMENTRTLD_DL_LINKMAPDl_infoLmid_tunsigned long long[7]__dflo_reserveddlfo_eh_framelink_map *dlfo_link_mapdlfo_map_enddlfo_map_startdlfo_flags(unknown field)dls_cntdls_sizeDl_serpath[1]__dls_serpath_padDl_serpath[0]struct <unnamed>[0]dls_serpathdls_flagsdls_namedli_saddrdli_snamedli_fbasedli_fnameLM_ID_NEWLMLM_ID_BASERTLD_DEFAULT((void *) 0)RTLD_NEXT((void *) -1l)__GNUC_PREREQ (3, 0)__WORDSIZE == 32/* dlfcn.h *//* __USE_GNU *//* If ADDRESS is found in an object, fill in *RESULT and return 0.
   Otherwise, return -1.  *//* Number of exception handling entries.  *//* Base address for DW_EH_PE_datarel.  *//* Exception handling data of the object.  *//* End of mapping.  *//* Beginning of mapping containing address.  *//* Actually longer, dls_cnt elements.  *//* The zero-length array avoids an unwanted array subscript check by
     the compiler, while the surrounding anonymous union preserves the
     historic size of the type.  At the time of writing, GNU C does
     not support structs with flexible array members in unions.  *//* Number of elements in `dls_serpath'.  *//* Size in bytes of the whole buffer.  *//* This is the structure that must be passed (by reference) to `dlinfo' for
   the RTLD_DI_SERINFO and RTLD_DI_SERINFOSIZE requests.  *//* Indicates where this directory came from. *//* Name of library search path directory.  *//* This is the type of elements in `Dl_serinfo', below.
   The `dls_name' member points to space in the buffer passed to `dlinfo'.  *//* Treat ARG as `void **', and store there a pointer to the calling
       thread's TLS block corresponding to this object's PT_TLS segment.
       Store a null pointer if this object does not define a PT_TLS
       segment, or if the calling thread has not allocated a block for it.  *//* Treat ARG as `size_t *', and store there the TLS module ID
       of this object's PT_TLS segment, as used in TLS relocations;
       store zero if this object does not define a PT_TLS segment.  *//* Unsupported, defined by Solaris.  *//* Treat ARG as `char *', and store there the directory name used to
       expand $ORIGIN in this shared object's dependency file names.  *//* Treat ARG as `Dl_serinfo *' (see below), and fill in to describe the
       directories that will be searched for dependencies of this object.
       RTLD_DI_SERINFOSIZE fills in just the `dls_cnt' and `dls_size'
       entries to indicate the size of the buffer that must be passed to
       RTLD_DI_SERINFO to fill in the full information.  *//* Treat ARG as `struct link_map **';
       store the `struct link_map *' for HANDLE there.  *//* Treat ARG as `lmid_t *'; store namespace ID for HANDLE there.  *//* These are the possible values for the REQUEST argument to `dlinfo'.  *//* Get information about the shared object HANDLE refers to.
   REQUEST is from among the values below, and determines the use of ARG.

   On success, returns zero.  On failure, returns -1 and records an error
   message to be fetched with `dlerror'.  *//* The object containing the address (struct link_map *).  *//* Matching symbol table entry (const ElfNN_Sym *).  *//* These are the possible values for the FLAGS argument to `dladdr1'.
   This indicates what extra information is stored at *EXTRA_INFO.
   It may also be zero, in which case the EXTRA_INFO argument is not used.  *//* Same as `dladdr', but additionally sets *EXTRA_INFO according to FLAGS.  *//* Fill in *INFO with the following information about ADDRESS.
   Returns 0 iff no shared object's segments contain that address.  *//* Exact value of nearest symbol.  *//* Name of nearest symbol.  *//* Load address of that object.  *//* File name of defining object.  *//* Structure containing information about object searched using
   `dladdr'.  *//* When any of the above functions fails, call this function
   to return a string describing the error.  Each call resets
   the error string so that a following call returns null.  *//* Find the run-time address in the shared object HANDLE refers to
   of the symbol called NAME with VERSION.  *//* Like `dlopen', but request object to be allocated in a new namespace.  *//* Find the run-time address in the shared object HANDLE refers to
   of the symbol called NAME.  *//* Unmap and close a shared object opened by `dlopen'.
   The handle cannot be used again after calling `dlclose'.  *//* Open the shared object FILE and map it in; return a handle that can be
   passed to `dlsym' to get symbol values from it.  *//* For dlmopen: request new namespace.  *//* Initial namespace.  *//* Special namespace ID values.  *//* Type for namespace indices.  *//* If the first argument to `dlsym' or `dlvsym' is set to RTLD_DEFAULT
   the run-time address of the symbol called NAME in the global scope
   is returned.  *//* If the first argument of `dlsym' or `dlvsym' is set to RTLD_NEXT
   the run-time address of the symbol called NAME in the next shared
   object is returned.  The "next" relation is defined by the order
   the shared objects were loaded.  *//* Collect various system dependent definitions and declarations.  *//* User functions for run-time dynamic loading.
   Copyright (C) 1995-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__address__result__handle__request__info__extra_info__version__nsid__mode/usr/include/gc/gc_pthread_redirects.h<dlfcn.h><pthread.h>GC_pthread_exitGC_pthread_cancelGC_pthread_detachGC_pthread_joinGC_pthread_createGC_pthread_sigmaskconst sigset_tconst sigset_t *sigset_t *GC_dlopenGC_PTHREAD_EXIT_DECLAREDGC_SUSPEND_THREAD_IDpthread_tGC_PTHREAD_REDIRECTS_Hdefined(GC_H) && defined(GC_PTHREADS)GC_PTHREAD_REDIRECTS_ONLYGC_NO_DLOPENGC_NO_PTHREAD_SIGMASKdefined(GC_PTHREAD_SIGMASK_NEEDED) \GC_NO_PTHREAD_CANCELdefined(GC_HAVE_PTHREAD_EXIT) && !defined(GC_PTHREAD_EXIT_DECLARED)!defined(GC_NO_THREAD_REDIRECTS) && !defined(GC_USE_LD_WRAP)/* GC_PTHREAD_REDIRECTS_H *//* !GC_NO_THREAD_REDIRECTS *//* mangled names.  Anyway, it's safe to undef them before redefining. *//* UNIX <pthread.h> redefines some POSIX thread functions to use      *//* Unless the compiler supports #pragma extern_prefix, the Tru64      *//* !GC_PTHREAD_REDIRECTS_ONLY *//* extern "C" *//* retval *//* arg *//* This is used for pthread_create() only.    *//* !GC_NO_PTHREAD_SIGMASK *//* oset *//* how *//* !GC_NO_DLOPEN *//* mode *//* path *//* needed anyway for proper redirection *//* to thread specific data on the thread stack.                         *//* facility in thr_keycreate.  Alternatively, keep a redundant pointer  *//* not the system malloc), which are deallocated using the destructor   *//* uncollectible objects (allocated with GC_malloc_uncollectable,       *//* Thread specific data should generally consist of pointers to         *//* Note also that the collector cannot always see thread specific data. *//* that we can locate thread stacks and stop the world.                 *//* We need to intercept calls to many of the threads primitives, so     *//* Included from gc.h only.  Included only if GC_PTHREADS.              *//* calls.  We arrange to do that here, if appropriate.                  *//* Our pthread support normally needs to intercept a number of thread   *//*
 * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.
 * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.
 * Copyright (c) 1998 by Fergus Henderson.  All rights reserved.
 * Copyright (c) 2000-2010 by Hewlett-Packard Development Company.
 * All rights reserved.
 *
 * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
 * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
 *
 * Permission is hereby granted to use or copy this program
 * for any purpose,  provided the above notices are retained on all copies.
 * Permission to modify the code and to distribute modified code is granted,
 * provided the above notices are retained, and a notice that the code was
 * modified is included with the above copyright notice.
 *//usr/include/gc/gc.h"gc_pthread_redirects.h""gc_config_macros.h""gc_version.h"GC_win32_free_heapGC_get_force_unmap_on_gcollectGC_set_force_unmap_on_gcollectGC_register_has_static_roots_callbackGC_malloc_manyGC_debug_ptr_store_and_dirtyGC_ptr_store_and_dirtyGC_dump_finalizationGC_dump_regionsGC_dump_namedGC_dumpGC_is_valid_displacementGC_is_visibleGC_post_incrGC_pre_incrGC_same_objGC_get_stack_baseGC_stack_base *GC_call_with_gc_activeGC_do_blockingGC_start_world_externalGC_stop_world_externalGC_unregister_my_threadGC_register_altstackGC_thread_is_registeredGC_register_my_threadconst GC_stack_baseconst GC_stack_base *GC_allow_register_threadsGC_start_mark_threadsGC_get_thr_restart_signalGC_get_suspend_signalGC_set_thr_restart_signalGC_set_suspend_signalGC_call_with_stack_baseGC_call_with_alloc_lockGC_abort_on_oomGC_get_abort_funcGC_set_abort_funcGC_set_log_fdGC_ignore_warn_procGC_get_warn_procGC_set_warn_procGC_invoke_finalizersGC_should_invoke_finalizersGC_get_await_finalize_procGC_set_await_finalize_procGC_toggleref_addGC_get_toggleref_funcGC_set_toggleref_funcGC_unregister_long_linkGC_move_long_linkGC_register_long_linkGC_unregister_disappearing_linkGC_move_disappearing_linkGC_general_register_disappearing_linkGC_register_disappearing_linkGC_debug_register_finalizer_unreachableGC_finalization_proc *GC_register_finalizer_unreachableGC_debug_register_finalizer_no_orderGC_register_finalizer_no_orderGC_debug_register_finalizer_ignore_selfGC_register_finalizer_ignore_selfGC_debug_register_finalizerGC_register_finalizerGC_debug_realloc_replacementGC_debug_malloc_replacementGC_debug_end_stubborn_changeGC_debug_change_stubbornGC_debug_reallocGC_debug_freeGC_debug_malloc_atomic_ignore_off_pageGC_debug_malloc_ignore_off_pageGC_debug_malloc_stubbornGC_debug_malloc_uncollectableGC_debug_strndupGC_debug_strdupGC_debug_malloc_atomicGC_debug_mallocGC_debug_malloc_atomic_uncollectableGC_malloc_atomic_uncollectableGC_malloc_atomic_ignore_off_pageGC_malloc_ignore_off_pageGC_collect_a_littleGC_incremental_protection_needsGC_is_incremental_modeGC_enable_incrementalGC_get_manual_vdb_allowedGC_set_manual_vdb_allowedGC_enableGC_is_disabledGC_disableGC_get_memory_useGC_get_size_map_atGC_get_prof_stats_unsafeGC_prof_stats_s *GC_get_prof_statsGC_get_heap_usage_safeGC_word *GC_get_total_bytesGC_get_expl_freed_bytes_since_gcGC_get_bytes_since_gcGC_get_unmapped_bytesGC_get_free_bytesGC_get_heap_sizeGC_get_stop_funcGC_set_stop_funcGC_try_to_collectGC_gcollect_and_unmapGC_gcollectGC_debug_register_displacementGC_register_displacementGC_remove_rootsGC_add_rootsGC_clear_rootsGC_exclude_static_rootsGC_set_max_heap_sizeGC_expand_hpGC_reallocGC_sizeGC_is_heap_ptrGC_baseGC_end_stubborn_changeGC_change_stubbornGC_freeGC_posix_memalignGC_memalignGC_malloc_stubbornGC_malloc_uncollectableGC_strndupGC_strdupGC_malloc_atomicGC_mallocGC_deinitGC_is_init_calledGC_initGC_atfork_childGC_atfork_parentGC_atfork_prepareGC_set_handle_forkGC_get_max_prior_attemptsGC_set_max_prior_attemptsGC_get_rateGC_set_rateGC_get_min_bytes_allocdGC_set_min_bytes_allocdGC_get_pages_executableGC_set_pages_executableGC_get_full_gc_total_timeGC_start_performance_measurementGC_get_time_limitGC_set_time_limitGC_get_dont_precollectGC_set_dont_precollectGC_get_max_retriesGC_set_max_retriesGC_get_free_space_divisorGC_set_free_space_divisorGC_get_no_dlsGC_set_no_dlsGC_get_non_gc_bytesGC_set_non_gc_bytesGC_get_full_freqGC_set_full_freqGC_get_dont_expandGC_set_dont_expandGC_get_finalizer_notifierGC_set_finalizer_notifierGC_get_java_finalizationGC_set_java_finalizationGC_get_finalize_on_demandGC_set_finalize_on_demandGC_get_all_interior_pointersGC_set_all_interior_pointersGC_get_find_leakGC_set_find_leakGC_get_on_thread_eventGC_set_on_thread_eventGC_get_on_collection_eventGC_set_on_collection_eventGC_get_on_heap_resizeGC_set_on_heap_resizeGC_get_oom_fnGC_set_oom_fnGC_get_parallelGC_get_gc_noGC_get_versionGC_has_static_roots_funcGC_stack_base_funcGC_stack_baseGC_fn_typeGC_hidden_pointerGC_abort_funcGC_warn_procGC_await_finalize_procGC_toggleref_funcGC_ToggleRefStatusGC_TOGGLE_REF_DROPGC_TOGGLE_REF_STRONGGC_TOGGLE_REF_WEAKGC_finalization_procGC_prof_stats_sGC_stop_funcGC_finalizer_notifier_procGC_on_thread_event_procGC_on_collection_event_procGC_EventTypeGC_EVENT_STARTGC_EVENT_MARK_STARTGC_EVENT_MARK_ENDGC_EVENT_RECLAIM_STARTGC_EVENT_RECLAIM_ENDGC_EVENT_ENDGC_EVENT_PRE_STOP_WORLDGC_EVENT_POST_STOP_WORLDGC_EVENT_PRE_START_WORLDGC_EVENT_POST_START_WORLDGC_EVENT_THREAD_SUSPENDEDGC_EVENT_THREAD_UNSUSPENDEDGC_on_heap_resize_procGC_oom_funcGC_signed_wordGC_wordGC_PTRmem_baseexpl_freed_bytes_since_gcreclaimed_bytes_before_gcbytes_reclaimed_since_gcmarkers_m1gc_nonon_gc_bytesallocd_bytes_before_gcbytes_allocd_since_gcunmapped_bytesfree_bytes_fullheapsize_fullGC_is_visible_print_procGC_is_valid_displacement_print_procGC_same_obj_print_procGC_time_limitGC_dont_precollectGC_stackbottomGC_max_retriesGC_free_space_divisorGC_no_dlsGC_non_gc_bytesGC_full_freqGC_use_entire_heapGC_dont_expandGC_dont_gcGC_finalizer_notifierGC_java_finalizationGC_finalize_on_demandGC_all_interior_pointersGC_find_leakGC_on_heap_resizeGC_oom_fnGC_parallelGC_gc_noGC_INIT(){ GC_INIT_CONF_DONT_EXPAND; GC_INIT_CONF_FORCE_UNMAP_ON_GCOLLECT; GC_INIT_CONF_MAX_RETRIES; GC_INIT_CONF_FREE_SPACE_DIVISOR; GC_INIT_CONF_FULL_FREQ; GC_INIT_CONF_TIME_LIMIT; GC_INIT_CONF_SUSPEND_SIGNAL; GC_INIT_CONF_THR_RESTART_SIGNAL; GC_INIT_CONF_MAXIMUM_HEAP_SIZE; GC_init(); GC_INIT_CONF_ROOTS; GC_INIT_CONF_IGNORE_WARN; GC_INIT_CONF_INITIAL_HEAP_SIZE; }GC_INIT_CONF_INITIAL_HEAP_SIZEGC_INIT_CONF_IGNORE_WARNGC_INIT_CONF_MAXIMUM_HEAP_SIZEGC_INIT_CONF_THR_RESTART_SIGNALGC_INIT_CONF_SUSPEND_SIGNALGC_INIT_CONF_TIME_LIMITGC_INIT_CONF_FULL_FREQGC_INIT_CONF_FREE_SPACE_DIVISORGC_INIT_CONF_MAX_RETRIESGC_INIT_CONF_FORCE_UNMAP_ON_GCOLLECTGC_INIT_CONF_DONT_EXPANDGC_INIT_CONF_ROOTSGC_NEXT(p)(*(void * *)(p))GC_PTR_STORE(p,q)(*(void **)(p) = (void *)(q))GC_POST_DECR(x)((x)--)GC_POST_INCR(x)((x)++)GC_PRE_INCR(x,n)((x) += (n))GC_PTR_ADD(x,n)((x)+(n))GC_NOT_FOUNDGC_UNIMPLEMENTEDGC_NO_THREADSGC_DUPLICATEGC_SUCCESSGC_REVEAL_POINTER(p)((void *)GC_HIDE_POINTER(p))GC_HIDE_POINTER(p)(~(GC_hidden_pointer)(p))GC_reachable_here(ptr)__asm__ __volatile__(" " : : "X"(ptr) : "memory")GC_NO_MEMORYGC_NEW_UNCOLLECTABLE(t)((t*)GC_MALLOC_UNCOLLECTABLE(sizeof(t)))GC_NEW_ATOMIC(t)((t*)GC_MALLOC_ATOMIC(sizeof(t)))GC_NEW(t)((t*)GC_MALLOC(sizeof(t)))GC_REGISTER_DISPLACEMENT(n)GC_register_displacement(n)GC_REGISTER_LONG_LINK(link,obj)GC_register_long_link(link, obj)GC_GENERAL_REGISTER_DISAPPEARING_LINK(link,obj)GC_general_register_disappearing_link(link, obj)GC_PTR_STORE_AND_DIRTY(p,q)GC_ptr_store_and_dirty(p, q)GC_END_STUBBORN_CHANGE(p)GC_end_stubborn_change(p)GC_REGISTER_FINALIZER_UNREACHABLE(p,f,d,of,od)GC_register_finalizer_unreachable(p, f, d, of, od)GC_REGISTER_FINALIZER_NO_ORDER(p,f,d,of,od)GC_register_finalizer_no_order(p, f, d, of, od)GC_REGISTER_FINALIZER_IGNORE_SELF(p,f,d,of,od)GC_register_finalizer_ignore_self(p, f, d, of, od)GC_REGISTER_FINALIZER(p,f,d,of,od)GC_register_finalizer(p, f, d, of, od)GC_FREE(p)GC_free(p)GC_MALLOC_ATOMIC_IGNORE_OFF_PAGE(sz)GC_malloc_atomic_ignore_off_page(sz)GC_MALLOC_IGNORE_OFF_PAGE(sz)GC_malloc_ignore_off_page(sz)GC_MALLOC_UNCOLLECTABLE(sz)GC_malloc_uncollectable(sz)GC_MALLOC_ATOMIC_UNCOLLECTABLE(sz)GC_malloc_atomic_uncollectable(sz)GC_STRNDUP(s,sz)GC_strndup(s, sz)GC_STRDUP(s)GC_strdup(s)GC_MALLOC_ATOMIC(sz)GC_malloc_atomic(sz)GC_REALLOC(old,sz)GC_realloc(old, sz)GC_MALLOC(sz)GC_malloc(sz)GC_EXTRA_PARAMSconst char * s, int iGC_EXTRAS__FILE__, __LINE__GC_PROTECTS_NONEGC_PROTECTS_STACKGC_PROTECTS_STATIC_DATAGC_PROTECTS_PTRFREE_HEAPGC_PROTECTS_POINTER_HEAPGC_CHANGE_STUBBORN(p)GC_change_stubborn(p)GC_NEW_STUBBORN(t)GC_MALLOC_STUBBORN(sz)GC_TIME_UNLIMITED999999GC_H(defined(WIN64) && !defined(_WIN64)) && defined(_MSC_VER)_WIN64defined(__int64) && !defined(CPPCHECK)defined(GC_THREADS) || (defined(GC_BUILD) && defined(NN_PLATFORM_CTR))GC_DONT_GCGC_ADD_CALLER!defined(CPPCHECK)GC_DEBUG_REPLACEMENTdefined(GC_DEBUG)GC_DEBUGGC_REQUIRE_WCSDUPdefined(__GNUC__) && !defined(__INTEL_COMPILER)LINT2defined(I_HIDE_POINTERS) || defined(GC_I_HIDE_POINTERS)defined(__ia64) || defined(__ia64__) || defined(_M_IA64)defined(GC_DARWIN_THREADS) || defined(GC_WIN32_THREADS)defined(GC_DEBUG) && defined(__GNUC__)!defined(CPPCHECK) && !defined(GC_WINDOWS_H_INCLUDED) && defined(WINAPI)defined(GC_WIN32_THREADS) \(!defined(GC_NO_THREAD_DECLS) || defined(GC_BUILD)) \!defined(_WIN32_WCE) && !defined(__CEGCC__)defined(GC_BUILD) || !defined(GC_DONT_INCLUDE_WINDOWS_H)GC_UNDERSCORE_STDCALLDECLSPEC_NORETURNGC_WINDOWS_H_INCLUDED!defined(_UINTPTR_T) && !defined(_UINTPTR_T_DEFINED) \defined(GC_WINDOWS_H_INCLUDED)GC_INSIDE_DLLGC_WINMAIN_REDIRECTGC_NO_THREAD_REDIRECTSdefined(__CYGWIN32__) || defined(__CYGWIN__)(defined(HOST_ANDROID) || defined(__ANDROID__)) \GC_DONT_EXPANDGC_FORCE_UNMAP_ON_GCOLLECTdefined(GC_MAX_RETRIES) && !defined(CPPCHECK)defined(GC_FREE_SPACE_DIVISOR) && !defined(CPPCHECK)defined(GC_FULL_FREQ) && !defined(CPPCHECK)defined(GC_TIME_LIMIT) && !defined(CPPCHECK)defined(GC_SIG_SUSPEND) && defined(GC_THREADS) && !defined(CPPCHECK)defined(GC_SIG_THR_RESTART) && defined(GC_THREADS) && !defined(CPPCHECK)defined(GC_MAXIMUM_HEAP_SIZE) && !defined(CPPCHECK)GC_IGNORE_WARNdefined(GC_INITIAL_HEAP_SIZE) && !defined(CPPCHECK)defined(_AMIGA) && !defined(GC_AMIGA_MAKINGLIB)mallocalloc_size/* GC_H *//* _AMIGA && !GC_AMIGA_MAKINGLIB *//* Allocation really goes through GC_amiga_allocwrapper_do.   *//* This explicitly deallocates the heap.                *//* win32S may not free all resources on process exit.   *//* post-init *//* real GC initialization *//* pre-init *//* primordial thread.  Multiple invocations are harmless.               *//* over, some platforms require this call to be done strictly from the  *//* Portable clients should call this at the program start-up.  More     *//* Set heap size to the desired value at start-up *//* Turn off all warnings at start-up (after GC initialization) *//* corresponding API function call.                                   *//* the similar environment variable or anytime later by the           *//* The limit could be overridden either at the program start-up by    *//* Limit the heap size to the desired value (useful for debugging).   *//* Set GC_time_limit to the desired value at start-up *//* Set GC_full_freq to the desired value at start-up *//* Set GC_free_space_divisor to the desired value at start-up *//* Set GC_max_retries to the desired value at start-up *//* unsupported); cannot call GC_disable as goes before GC_init.       *//* This is for debugging only (useful if environment variables are    *//* Turn on "unmap as much as possible on explicit GC" mode at start-up *//* Set GC_dont_expand to TRUE at start-up *//*up*//* up *//* start *//* client shared library if the GC dynamic loading support is off.    *//* This is ugly but seems the only way to register data roots of the  *//* Required at least if GC is in a DLL.  And doesn't hurt. *//* For blacklisting. *//* !__x86_64__ *//* Cygwin/x64 does not add leading underscore to symbols anymore.   *//* main program, as does AIX.                                         *//* Similarly gnu-win32 DLLs need explicit initialization from the     *//* to GC_malloc() or GC_malloc_atomic().                                *//* THREAD_LOCAL_ALLOC defined and the initial allocation call is not    *//* A GC_INIT call is required if the collector is built with            *//* platforms make that too hard.                                        *//* no-op and the collector self-initializes.  But a number of           *//* before making any other GC_ calls.  On most platforms this is a      *//* Fully portable code should call GC_INIT() from the main program      *//* getter are unsynchronized.                                           *//* value is controlled by GC_FORCE_UNMAP_ON_GCOLLECT.  The setter and   *//* Has no effect on implicitly-initiated garbage collections.  Initial  *//* mode on(1) and off(0).  Has no effect unless unmapping is turned on. *//* Public setter and getter for switching "unmap as much as possible"   *//* GC_WIN32_THREADS *//* #define _beginthread { > "Please use _beginthreadex instead of _beginthread" < } *//* For compatibility only. *//* collector.                                                       *//* a new thread to call GC_WinMain() after initializing the garbage *//* win32_threads.c implements the real WinMain(), which will start  *//* !GC_NO_THREAD_DECLS *//* !_WIN32_WCE *//* VC++ and MinGW headers, so we don't mark it neither.           *//* Note: _endthreadex() is not currently marked as no-return in   *//* thrdaddr *//* initflag *//* arglist *//* stack_size *//* security *//* dwExitCode *//* lpThreadId *//* dwCreationFlags *//* lpParameter *//* lpStartAddress *//* dwStackSize *//* lpThreadAttributes *//* so that the thread is properly unregistered.                     *//* terminate normally, or call GC_endthreadex() or GC_ExitThread,   *//* Currently the collector expects all threads to fall through and  *//* registers all created threads, but appears to be less robust.    *//* defined, and to call GC_use_threads_discovery.  This implicitly  *//* compatibility, it is possible to build the GC with GC_DLL        *//* that they will be recorded in the thread table.  For backward    *//* (and call GC_unregister_my_thread before thread termination), so *//* GC_beginthreadex, or must explicitly call GC_register_my_thread  *//* All threads must be created using GC_CreateThread or             *//* GC_INSIDE_DLL *//* reserved *//* reason *//* inst *//* Export GC DllMain to be invoked from client DllMain.   *//* Typically defined in winnt.h. *//* with '_' (underscore).  Might be useful if MinGW/x86 is used.  *//* Explicitly prefix exported/imported WINAPI (__stdcall) symbols *//* For _beginthreadex, _endthreadex *//* Including windows.h in an extern "C" context no longer works. *//* unless windows.h is included before gc.h.            *//* Note: for Cygwin and pthreads-win32, this is skipped *//* windows.h is included before gc.h *//* platforms (if the filtering is unimplemented or inappropriate).      *//* callback.  May be 0 (means no filtering).  May be unused on some     *//* scanning of dynamic libraries.  Replaces any previously registered   *//* Register a new callback (a user-supplied filter) to control the      *//* section_size *//* section_start *//* dlpi_name *//* platform, might be called with the "world" stopped.                  *//* Always called with the allocation lock held.  Depending on the       *//* This routine should return nonzero if that region should be scanned. *//* address and the length of the memory region (section) are passed.    *//* a last reason not to register).  The filename of the library, the    *//* (discovered by GC) section as a static data root (called only as     *//* If implemented, called by GC before registering a dynamic library    *//* A filter function to control the scanning of dynamic libraries.      *//* in returned list.            *//* Retrieve the next element    *//* lb *//* allocation lock can be acquired and released many fewer times.       *//* Its use can greatly reduce lock contention problems, since the       *//* This returns a list of objects, linked through their first word.     *//* thread library calls.  We do that here by macro defining them.     *//* For pthread support, we generally need to intercept a number of    *//* q *//* p *//* Functions called to report pointer checking errors *//* (assuming p and q do not have side effects).                         *//* followed by GC_END_STUBBORN_CHANGE(p) and GC_reachable_here(q)       *//* GC_PTR_STORE_AND_DIRTY(p,q) is equivalent to GC_PTR_STORE(p,q)       *//* Safer assignment of a pointer to a non-stack location.       *//* !GC_DEBUG || !__GNUC__ *//* TODO: This should eventually support C++0x decltype. *//* sufficiently useful.  Without it we resort to the non-debug version. *//* We can't do this right without typeof, which ANSI decided was not    *//* Note that GC_PTR_ADD evaluates the first argument more than once.    *//* documentation than as part of the API.                               *//* Even then, these are probably more useful as                         *//* arithmetic expressions.                                              *//* by clients.  These are designed to model the available C pointer     *//* Only the macros without trailing digits are meant to be used         *//* a preprocessor.  Useful only for heap pointers.                      *//* Safer, but slow, pointer addition.  Probably useful mainly with      *//* Defined only if the library has been compiled without NO_DEBUGGING.  *//* finalizable object.                                                  *//* Dump information about every registered disappearing link and        *//* Dump information about each block of every GC memory section.        *//* name *//* number is used as the name.                                          *//* identifying individual dumps.  Otherwise the current collection      *//* not acquire the lock.  If name is non-NULL, it is printed to help    *//* The same as GC_dump but allows to specify the name of dump and does  *//* Acquires the GC lock to avoid data races.                            *//* The current collection number is printed in the header of the dump.  *//* but it may be useful to call it from client code during debugging.   *//* debugger, or by setting the GC_DUMP_REGULARLY environment variable,  *//* Explicitly dump the GC state.  This is most often called from the    *//* Always returns its argument.                                         *//* Uninteresting with GC_all_interior_pointers.                         *//* Fail conspicuously if this property does not hold.                   *//* a valid displacement within a heap object.                           *//* Check that if p is a pointer to a heap page, then it points to       *//* Currently useless for multi-threaded worlds.                         *//* slow, to add such a call to all indirect pointer stores.)            *//* untyped allocations.  The idea is that it should be possible, though *//* in hard cases.  (This is intended for debugging use with             *//* Returns the argument in all cases.  May erroneously succeed          *//* If it isn't fail conspicuously.                                      *//* to the collector as a possibly pointer containing location.          *//* Check that p is visible                                              *//* how_much *//* call should be automatically generated.                              *//* object size.  This should either be invoked from a macro, or the     *//* the second argument is in units of bytes, not multiples of the       *//* Checked pointer pre- and post- increment operations.  Note that      *//* May succeed if both p and q point to between heap objects.   *//* Succeeds if neither p nor q points to the heap.              *//* Returns the first argument.                                  *//* Fail conspicuously if they don't.                            *//* Check that p and q point to the same object.                 *//* They indicate failure by invoking the corresponding _print_proc.     *//* preprocessor which inserts calls to check C pointer arithmetic.      *//* The following routines are primarily intended for use with a         *//* GC lock on some platforms.                                           *//* Returns GC_SUCCESS or GC_UNIMPLEMENTED.  This function acquires the  *//* It is also unfortunately hard to implement well on many platforms.   *//* threads are not automatically registered with the collector.         *//* like the JNI AttachCurrentThread in an environment in which new      *//* for this thread.  This appears to be required to implement anything  *//* Attempt to fill in the GC_stack_base structure with the stack base   *//* client_data *//* fn *//* provide a sufficiently accurate stack base.                          *//* GC_do_blocking.  GC_call_with_gc_active() often can be used to       *//* the collector thread's state temporarily to "inactive" one by using  *//* initialized and the current thread is registered.  fn may toggle     *//* GC_do_blocking() one.  It is assumed that the collector is already   *//* heap).  GC_call_with_gc_active() has the functionality opposite to   *//* GC function and/or manipulate pointers to the garbage collected      *//* the current thread (i.e. the user function is allowed to call any    *//* Call a function switching to the "active" state of the collector for *//* memory and/or manipulate pointers to the garbage collected heap).    *//* scan only stack frames of functions that allocate garbage collected  *//* technique might be used to make stack scanning more precise (i.e.    *//* toggling the collector's state back to "active".  The latter         *//* GC_call_with_gc_active() (even recursively), thus temporarily        *//* thread is registered.  It is allowed for fn to call                  *//* assumed that the collector is already initialized and the current    *//* "inactive" state are not scanned during garbage collections).  It is *//* the thread's stack frames "belonging" to the functions in the        *//* the current thread (this means that the thread is not suspended and  *//* is running, the collector is said to be in the "inactive" state for  *//* garbage collected heap) for an appreciable length of time.  While fn *//* allocate garbage collected memory and/or manipulate pointers to the  *//* Wrapper for functions that are likely to block (or, at least, do not *//* Stop/start the world explicitly.  Not recommended for general use. *//* GC_call_with_stack_base() one).                                    *//* be called inside a GC callback function (except for                *//* most probably by saving it in a global data structure.  Must not   *//* thread, it must do this before calling GC_unregister_my_thread,    *//* communicate a pointer to the garbage-collected heap to another     *//* this call.  Specifically, if it wants to return or otherwise       *//* manipulate pointers to the garbage collected heap after making     *//* The thread may no longer allocate garbage collected memory or      *//* exception, it is also allowed to once unregister the main thread.) *//* is allowed (and required) to call this function.  (As a special    *//* thread (i.e. for which GC_register_my_thread() returns GC_SUCCESS) *//* Unregister the current thread.  Only an explicitly registered      *//* altstack_size *//* altstack_base *//* stack_start *//* boundaries when a thread is suspended while it is on an alt-stack. *//* current thread.  stack_start/size is used to determine the stack   *//* Notify the collector about the stack and the alt-stack of the      *//* registered with the garbage collector.                             *//* Return non-zero (TRUE) if and only if the calling thread is        *//* Returns GC_SUCCESS on success, GC_DUPLICATE if already registered. *//* A manually registered thread requires manual unregistering.        *//* created by third-party libraries.                                  *//* latter case, the explicit call is normally required for threads    *//* GC_use_threads_discovery() is called at start-up.  Except for the  *//* It is also always done implicitly on some platforms if             *//* objects are manipulated inside.                                    *//* registering (and unregistering) if pointers to GC-allocated        *//* (e.g., pthread key destructor) typically require manual thread     *//* thread creation function.  Nonetheless, thread cleanup routines    *//* (which redefines some system functions) before calling the system  *//* functions are called to create the thread, e.g. by including gc.h  *//* always done implicitly.  This is normally done implicitly if GC_   *//* This should never be called from the main thread, where it is      *//* This call must be previously enabled (see above).                  *//* stopped during garbage collections.                                *//* to the garbage collected heap.  Once registered, a thread will be  *//* thread can allocate garbage collected memory, or assign pointers   *//* is not implicitly called by the GC, this must be called before a   *//* a new thread whose stack(s) should be traced by the GC.  If it     *//* Register the current thread, with the indicated stack base, as     *//* registering of a thread (it should be called as late as possible). *//* between the collector initialization and the first explicit        *//* must be called from the main (or any previously registered) thread *//* compiled with GC_ALWAYS_MULTITHREADED defined).  Otherwise, it     *//* implicit thread registration is activated, or the collector is     *//* Done implicitly if a GC thread-creation function is called (or     *//* Explicitly enable GC_register_my_thread() invocation.              *//* other situations.  Should not be called if fork followed by exec.  *//* Restart marker threads after POSIX fork in child.  Meaningless in  *//* systems.  Return -1 otherwise.                                     *//* the garbage collector to restart (resume) threads on POSIX         *//* Return the signal number (constant after initialization) used by   *//* the GC to suspend threads on POSIX systems.  Return -1 otherwise.  *//* Has no effect after GC_init and on non-POSIX systems.              *//* Suggest the GC to use the specific signal to resume threads.       *//* Suggest the GC to use the specific signal to suspend threads.      *//* called instead.  Disables parallelized GC on Win32.                *//* GC_pthread_create, GC_beginthreadex (or GC_CreateThread) could be  *//* GC_INIT() and other GC routines.  Should be avoided if             *//* or Darwin task_threads).  Deprecated.  Must be called before       *//* Use implicit thread registration and processing (via Win32 DllMain *//* by GC_move_disappearing_link).       *//* Requested link not found (returned   *//* Not yet implemented on this platform.     *//* GC_NO_THREADS is not returned by any GC function anymore.    *//* No thread support in GC.             *//* Was already registered.              *//* implement it everywhere.                                             *//* be used to provide a sufficiently accurate stack base.  And we       *//* somewhere in the GC_call_with_stack_base frame.  This often can      *//* Call a function with a stack base structure corresponding to         *//* sb *//* Base of separate register stack. *//* Base of memory stack. *//* platforms this contains just a single address.                       *//* Structure representing the base of a thread stack.  On most          *//* stacks on all platforms.                                             *//* ever be able to automatically determine the stack base for thread    *//* The interface is complicated by the fact that we probably will not   *//* this is being implemented a platform at a time.                      *//* is to always make redundant registration safe.  In the short run,    *//* defines, or linker-based interception.  In the long run the intent   *//* is implicitly intercepted by the collector, using header-file        *//* of new threads.  Often this is unnecessary because thread creation   *//* These routines are intended to explicitly notify the collector       *//* preferred for new code).                                           *//* This exists only for compatibility (the GC-prefixed symbols are    *//* allocator lock to avoid a race with the collector.                   *//* that the object still exists.  This involves acquiring the           *//* Converting a hidden pointer to a real pointer requires verifying     *//* disguising them in this way, and may have other advantages.  *//* non-pointer slots of "typed" objects is equivalent to        *//* Note that putting pointers in atomic objects or in           *//* Should not be used in the leak-finding mode.                 *//* have been collected.                                         *//* disappear.  Otherwise objects can be accessed after they     *//* that finalization code will arrange for hidden pointers to   *//* (e.g. Java-like) finalization facility.  It is expected      *//* The following is intended to be used by a higher level       *//* A portable way to abort the application because of not enough memory.*//* msg *//* compiled without SMALL_CONFIG.                                       *//* Both the setter and getter are defined only if the library has been  *//* before abort).  Both the setter and getter acquire the GC lock.      *//* invoked before exit(1) otherwise msg is non-NULL (i.e., if invoked   *//* outputs msg to stderr provided msg is non-NULL.  msg is NULL if      *//* abort or exit(1) is called).  Must be non-NULL.  The default one     *//* abort_func is invoked on GC fatal aborts (just before OS-dependent   *//* Change file descriptor of GC log.  Unavailable on some targets.      *//* to suppress all warnings (unless statistics printing is turned on).  *//* GC_ignore_warn_proc may be used as an argument for GC_set_warn_proc  *//* GC_get_warn_proc returns the current warn_proc.                      *//* returned the old warn_proc value.                                    *//* lock (to avoid data races).  In version 7.1 (and before), the setter *//* match the format).  Both the setter and the getter acquire the GC    *//* p may not be a NULL pointer.  msg is printf format string (arg must  *//* GC_set_warn_proc can be used to redirect or filter warning messages. *//* The expression matches the one of COVERT_DATAFLOW(). *//* settings.                                                    *//* The function is sometimes called keep_alive in other         *//* associated external resource is still in use.                *//* needed to prevent finalizers from running while the          *//* absence of finalizers or disappearing links.  But it may be  *//* longer needed.  It should have no visible effect in the      *//* pointer from being optimized away, even it is otherwise no   *//* at a particular program point.  This prevents the argument   *//* Explicitly tell the collector that an object is reachable    *//* explicitly.                                          *//* GC_finalize_on_demand is nonzero, it must be called  *//* implicitly during some allocations.  If              *//* that were run.  Normally this is also called         *//* be finalized.  Return the number of finalizers       *//* Run finalizers for all objects that are ready to     *//* Does not use any synchronization.                            *//* Returns !=0 if GC_invoke_finalizers has something to do.     *//* and getter acquire the lock too.     *//* Zero means no callback.  The setter  *//* obj *//* enqueued for finalization.                                   *//* the allocation lock held) for each unreachable object        *//* Finalizer callback support.  Invoked by the collector (with  *//* is_strong *//* it failed for lack of memory.                                *//* succeeded (or no callback registered yet), GC_NO_MEMORY if   *//* a weak one otherwise.  Returns GC_SUCCESS if registration    *//* is true then the object is registered with a strong ref,     *//* GC_TOGGLE_REF_DROP or the object is collected.  If is_strong *//* invoked on the object until the callback returns             *//* be stored internally and the toggle-ref callback will be     *//* Register a given object for toggle-ref processing.  It will  *//* races).                                                      *//* and the getter acquire the allocation lock (to avoid data    *//* The argument may be 0 (means no callback).  Both the setter  *//* object (by, probably, inspecting its native state).          *//* Set (register) a callback that decides the state of a given  *//* held (but the "world" is running).                           *//* for toggle-ref processing.  Invoked with the allocation lock *//* object.  Invoked by the collector for all objects registered *//* The callback is to decide (return) the new state of a given  *//* has no interest in the object, and a strong otherwise.       *//* reference; a weak reference is used when the external peer   *//* an object is kept and it can be either a strong or weak      *//* The idea of toggle-ref is that an external reference to      *//* without hooking up to the host retain/release machinery.     *//* Support of toggle-ref style of external memory management    *//* registration by either of the above two routines.    *//* Similar to GC_unregister_disappearing_link but for a *//* link *//* previously registered via GC_register_long_link.     *//* Similar to GC_move_disappearing_link but for a link  *//* new_link *//* long weak pointers easily and safely.                *//* traceable from root).  This can be used to implement *//* finalizer (e.g. by assigning itself to a pointer     *//* when it can no longer be resurrected from its        *//* inaccessible.  An object becomes truly inaccessible  *//* *link only gets cleared when obj becomes truly       *//* Similar to GC_general_register_disappearing_link but *//* registered (otherwise returns 1).                    *//* routines.  Returns 0 if link was not actually        *//* Undoes a registration by either of the above two     *//* if no link is registered at the original location.   *//* returned if new_link is equal to link), GC_NOT_FOUND *//* disappearing link at the new location (never         *//* GC_DUPLICATE if there is already another             *//* been registered).  Returns GC_SUCCESS on success,    *//* new_link equal to link (to check whether link has    *//* change (*new_link) content.  May be called with      *//* target object of the weak reference.  Does not       *//* GC_register_disappearing_link).  Does not change the *//* GC_general_register_disappearing_link (or            *//* Moves a link previously registered via               *//* GC_UNIMPLEMENTED if GC_find_leak is true.            *//* memory (and GC_oom_fn did not handle the problem),   *//* GC_NO_MEMORY if registration failed for lack of      *//* if link was already registered (with some object),   *//* succeeded (a new link is registered), GC_DUPLICATE   *//* cleared.  Returns GC_SUCCESS if registration         *//* decides to reclaim the object and the link is        *//* could be recreated between the time the collector    *//* pointer is accessed.  Otherwise a strong pointer     *//* GC_call_with_alloc_lock() below) when the disguised  *//* requires that the allocation lock is held (see       *//* of weak pointers.  Note, however, this generally     *//* This function can be used to implement certain types *//* No-op in the leak-finding mode.                      *//* link to eventually be cleared.                       *//* Explicit deallocation of obj may or may not cause    *//* explicitly deallocate the object containing link.    *//* this link is garbage collected.  It is unsafe to     *//* (*link) is cleared, or when the object containing    *//* disappears when it is unregistered manually, or when *//* allocated by GC_malloc or friends.   A link          *//* obj must be a pointer to the first word of an object *//* link must be non-NULL (and be properly aligned).     *//* email discussion with John Ellis.                    *//* with) are ignored.  This was added after a long      *//* i.e. all objects but the last one (link registered   *//* Each link may be registered only with one obj value, *//* object reachable from them gets finalized.           *//* In this way, weak pointers are broken before any     *//* inside an "atomic" object is effectively disguised.) *//* holding a disguised pointer to obj.  (A pointer      *//* safely. Typically link will point to a location      *//* can be used to implement weak pointers easily and    *//* cleared when obj first becomes inaccessible.  This   *//* A slight generalization of the above. *link is       *//* Only exists for backward compatibility.  See below:  *//* memory, and GC_oom_fn did not handle the problem.    *//* succeeded, GC_NO_MEMORY if it failed for lack of     *//* was already registered, GC_SUCCESS if registration   *//* examines connectivity.  Returns GC_DUPLICATE if link *//* But this causes problems if that action alters, or   *//* be allowed here, instead of just clearing a pointer. *//* There's an argument that an arbitrary action should  *//* be visible to non-finalization code.                 *//* finalizer, and thus the clearing of *link may        *//* Note that obj may be resurrected by another          *//* finalization.  This may avoid finalization cycles.   *//* some pointers are not essential for proper           *//* This is useful in telling the finalizer that         *//* decisions about finalization order are made.         *//* finalization code is invoked, and BEFORE any         *//* found to be inaccessible.  This happens BEFORE any   *//* object obj.  *link will be cleared when obj is       *//* Link should point to a field of a heap allocated     *//* finalization order.                                          *//* code, and should not be considered in determining            *//* where p is a pointer that is not followed by finalization    *//* use involves calling GC_register_disappearing_link(&p),      *//* objects to be finalized in the correct order.  Standard      *//* finalizable objects, thus causing cyclic finalizable         *//* The following routine may be used to break cycles between    *//* Failure due to lack of memory.       *//* ocd *//* ofn *//* cd *//* unordered finalization (e.g. Java, C#).                      *//* of interest when implementing a language that requires       *//* Only works if GC_java_finalization is set.  Probably only    *//* finalizers.                                                  *//* object can still be brought back to life by other            *//* as to release resources that must not be released while an   *//* This can be used in combination with finalizer_no_order so   *//* the unordered finalization request.                          *//* indirectly, from an unordered finalizable object to override *//* Effectively it allows an object referenced, possibly         *//* other objects specifying unordered finalization.             *//* finalizer is not run while the object is reachable from      *//* It behaves like "normal" finalization, except that the       *//* longer reachable, not even from other finalizable objects.   *//* finalizer must be run when the object is known to be no      *//* This is a special finalizer that is useful when an object's  *//* refers to the object itself.                                 *//* Note that cd will still be viewed as accessible, even if it  *//* It should probably only be used by Java implementations.     *//* Another version of the above.  It ignores all cycles.        *//* avoid cycles.                                                *//* case.  And it helps if finalizable objects are split to      *//* silently introduce these.  It's also benign in that specific *//* but it's unavoidable for C++, since the compiler may         *//* itself.  There is a stylistic argument that this is wrong,   *//* self-cycles, i.e. pointers from a finalizable object to      *//* Another versions of the above follow.  It ignores            *//* finalizer is invoked.                                *//* by cd will be considered accessible until the        *//* Note that any garbage collectible object referenced  *//* case, fn is ignored, *ofn and *ocd are set to NULL). *//* NULL or point to something outside GC heap (in this  *//* allocated by GC_malloc or friends. Obj may also be   *//* Obj should be the starting address of an object      *//* finalizer were NULL.                                 *//* finalization, even if neither the old nor new        *//* a signal, the object may be left with no             *//* If GC_register_finalizer is aborted as a result of   *//* routines.                                            *//* such conversions are not performed by finalization   *//* pointers only if the allocation lock is held, and    *//* provided hidden pointers are converted to real       *//* Fn is never invoked on an accessible object,         *//* new finalizer), *ofn and *ocd remain unchanged.)     *//* updated.  In case of error (no memory to register    *//* The allocation lock is held while *ofn and *ocd are  *//* *ofn and *ocd.  (ofn and/or ocd may be NULL.         *//* The old finalizer and client data are stored in      *//* finalized).                                          *//* enqueued for finalization (i.e. become ready to be   *//* Finalizers are implicitly unregistered when they are *//* Finalization may be removed by passing 0 as fn.      *//* is ignored.                                          *//* All but the last finalizer registered for an object  *//* be avoided, or broken by disappearing links.         *//* Thus cycles involving finalizable objects should     *//* pointers will not be finalized (or collected).       *//* is reachable from itself by following one or more    *//* next collection.)  Any finalizable object that       *//* pointers to b, then b will be finalized after the    *//* finalized.  (If this does not create any new         *//* made to disappear), then only a will be              *//* a points to b (after disappearing links have been    *//* (*fn)(obj, cd).  If a and b are inaccessible, and    *//* When obj is no longer accessible, invoke             *//* probably nobody else agrees with it.     Hans-J. Boehm  3/13/92      *//* Christian Jacobi, and Russ Atkinson.  It's not perfect, and          *//* with Alan Demers, Dan Greene, Carl Hauser, Barry Hayes,              *//* The interface represents my conclusions from a long discussion       *//* a safer layer, closer to Modula-3, Java, or PCedar finalization.     *//* The idea is to make them both cheap, and sufficient to build         *//* Finalization.  Some of these primitives are grossly unsafe.          *//* GC_REQUIRE_WCSDUP *//* wchar_t should be defined in stddef.h *//* This might be unavailable on some targets (or not needed). *//* may return NULL (if out of memory).                                  *//* type expression.  Note that, unlike C++ new operator, these ones     *//* expand to something syntactically incorrect if t is a complicated    *//* reduce the chance for a misspecified size argument.  But calls may   *//* The following are included because they are often convenient, and    *//* !GC_DEBUG *//* no const *//* !GC_DEBUG_REPLACEMENT && !GC_DEBUG *//* size_in_bytes *//* object_addr *//* 'realloc' attr *//*    linker to replace malloc/realloc with these.                      *//*    leak detection.  This can be accomplished by instructing the      *//*    platforms it may be more convenient not to recompile, e.g. for    *//*    since it can be reconstructed from a stack trace.  On such        *//* 2) On some platforms, the file and line information is redundant,    *//*    that can't be recompiled.                                         *//*    even if some allocation calls come from 3rd party libraries       *//* 1) It allows the collector to be built with DBG_HDRS_ALL defined     *//* can be useful for two reasons:                                       *//* Thus they can serve as drop-in malloc/realloc replacements.  This    *//* above), but just fill in dummy file and line number information.     *//* Routines that allocate objects with debug information (like the      *//* new_size_in_bytes *//* old_object *//* objects allocated in this way for overwrites, etc.                   *//* Debugging (annotated) allocation.  GC_gcollect will check            *//* compiled:                                                            *//* The following is only defined if the library has been suitably       *//* pointers, the threshold is normally much higher.                     *//* or if the collector is not configured to recognize all interior      *//* for arrays likely to be larger than 100K or so.  For other systems,  *//* reference.)  On a SunOS 4.X or MS Windows system this is recommended *//* an array, since it will try hard to avoid introducing such a false   *//* it reduces the chance of the allocator not finding space for such    *//* integer that happens to be an address inside the array.  (Actually,  *//* accidentally retaining such an array as a result of scanning an      *//* if a large array is being allocated.  It reduces the chance of       *//* from invalidating this assertion.)  This routine is only useful      *//* (This should normally be declared volatile to prevent the compiler   *//* that points to somewhere within the first 256 bytes of the object.   *//* as long as the object is live, it will be referenced by a pointer    *//* Allocate an object of size lb bytes.  The client guarantees that     *//* until it returns 0.                                          *//* disabled.  It is reasonable to call this in a wait loop      *//* progress requires it, e.g. if incremental collection is      *//* to marking from one page.  May do more work if further       *//* Typically performs an amount of work corresponding roughly   *//* case when garbage collection is not appropriate).            *//* Return 0 if there is no more work to be done (including the  *//* Perform some garbage collection work, if appropriate.        *//* The collector is assumed to be initialized before this call.         *//* Probably impractical.            *//* Currently never.                 *//* May protect non-atomic objects.  *//* more of the following, or'ed together:                       *//* Does incremental mode write-protect pages?  Returns zero or  *//* Does not acquire the lock.                                           *//* Return non-zero (TRUE) if and only if the incremental mode is on.    *//* Safe to call before GC_INIT().  Includes a  GC_init() call.          *//* adverse effects.                                                     *//* early as possible.  On some platforms, calling it later may have     *//* GC_gcj_malloc() calls.  For best performance, should be called as    *//* to revert to locked allocation.  Must be called before any such      *//* GC_TIME_UNLIMITED.  Causes thread-local variant of GC_gcj_malloc()   *//* functional if GC_parallel is non-zero or if GC_time_limit is         *//* GC_dont_gc is non-zero.  Only the generational piece of this is      *//* (atomic) or immutable.  Don't use in leak finding mode.  Ignored if  *//* dirty bits are available or most heap objects are pointer-free       *//* Enable incremental/generational collection.  Not advisable unless    *//* are not synchronized, and are defined only if the library has been   *//* calls (to ensure proper write barriers).  Both the setter and getter *//* and GC_reachable_here (or, alternatively, GC_PTR_STORE_AND_DIRTY)    *//* used only if the client has the appropriate GC_END_STUBBORN_CHANGE   *//* compiled with MANUAL_VDB defined.  The manual VDB mode should be     *//* collection.  The default value is off unless the collector is        *//* collection.  Has no effect if called after enabling the incremental  *//* Select whether to use the manual VDB mode for the incremental        *//* both functions is equal.                                             *//* calls nest.  Garbage collection is enabled if the number of calls to *//* Try to re-enable garbage collection.  GC_disable() and GC_enable()   *//* (i.e., GC_dont_gc value is non-zero).  Does not acquire the lock.    *//* Return non-zero (TRUE) if and only if garbage collection is disabled *//* ineffective.                                                         *//* Disable garbage collection.  Even GC_gcollect calls will be          *//* the lock.                                                            *//* Count total memory use in bytes by all allocated blocks.  Acquires   *//* to avoid data races on multiprocessors.                              *//* thus clients should call it using GC_call_with_alloc_lock typically  *//* index is out of size_map table bounds. Does not use synchronization, *//* mapping.  Assumes the collector is initialized.  Returns -1 if the   *//* size_map table which provides requested-to-actual allocation size    *//* Get the element value (converted to bytes) at a given index of       *//* stats_sz *//* avoid data races on multiprocessors.                               *//* lock).  Clients should call it using GC_call_with_alloc_lock to    *//* Same as above but unsynchronized (i.e., not holding the allocation *//* unknown fields, if any).                                             *//* (in bytes) of the filled in part of the structure (excluding all     *//* unsupported (unknown) fields are filled in with -1.  Return the size *//* structure) than that of the linked libgc binary; in the latter case, *//* client could use newer gc.h (with more entries declared in the       *//* versions, an old client could have fewer fields, and vice versa,     *//* in the values - this is for interoperability between different GC    *//* should pass the size of the buffer (of GC_prof_stats_s type) to fill *//* Atomically get GC statistics (various global counters).  Clients     *//* Same as returned by GC_get_expl_freed_bytes_since_gc().  *//* Number of bytes freed explicitly since the recent GC.    *//* garbage collection.  The value may wrap.                 *//* Approximate number of bytes reclaimed before the recent  *//* Approximate number of reclaimed bytes after recent GC.   *//* collector is single-threaded).                           *//* Same as returned by GC_get_parallel (or 0 if the         *//* Number of marker threads (excluding the initiating one). *//* (and could be -1).  Same as returned by GC_get_gc_no().  *//* Garbage collection cycle number.  The value may wrap     *//* collection.  Same as returned by GC_get_non_gc_bytes().  *//* Number of bytes not considered candidates for garbage    *//* GC_get_total_bytes() - GC_get_bytes_since_gc().          *//* collection.  The value may wrap.  Same as the result of  *//* Number of bytes allocated before the recent garbage      *//* Same as returned by GC_get_bytes_since_gc().             *//* Number of bytes allocated since the recent collection.   *//* returned by GC_get_unmapped_bytes().                     *//* Amount of memory unmapped to OS.  Same as the value      *//* Same as GC_get_free_bytes() + GC_get_unmapped_bytes().   *//* Total bytes contained in free and unmapped blocks.       *//* Same as GC_get_heap_size() + GC_get_unmapped_bytes().    *//* Heap size in bytes (including the area unmapped to OS).  *//* should be removed from.                                              *//* new fields should be added only to the end, and no deprecated fields *//* More fields could be added in the future.  To preserve compatibility *//* Structure used to query GC statistics (profiling information).       *//* ptotal_bytes *//* pbytes_since_gc *//* punmapped_bytes *//* pfree_bytes *//* pheap_size *//* when GC_get_heap_size and the friends were made lock-free again.)    *//* (This API function was introduced in GC v7.2alpha7 at the same time  *//* argument.  Returned (filled in) values are of word type.             *//* consistent result.)  Passing NULL pointer is allowed for any         *//* the allocator lock thus preventing data racing and returning the     *//* alternative for the five above getters.   (This function acquires    *//* Return the heap usage information.  This is a thread-safe (atomic)   *//* getter (see GC_get_heap_size comment regarding thread-safety).       *//* Never decreases, except due to wrapping.  This is an unsynchronized  *//* Return the total number of bytes allocated in this process.          *//* the recent collection.  This is an unsynchronized getter.            *//* Return the number of explicitly deallocated bytes of memory since    *//* regarding thread-safety).                                            *//* This is an unsynchronized getter (see GC_get_heap_size comment       *//* Return the number of bytes allocated since the last collection.      *//* the OS runs out of system/virtual memory). This is an unsynchronized *//* to the OS but could be remapped back by the collector later unless   *//* Return the size (in bytes) of the unmapped memory (which is returned *//* (excluding the unmapped memory space).  This is an unsynchronized    *//* Return a lower bound on the number of free bytes in the heap         *//* reverted back in v7.2alpha7 for the reason described.)               *//* four ones below were made thread-safe in GC v7.2alpha1 and          *//* holding the allocator lock.  (This API function and the following    *//* reason since some existing clients call it from a GC callback        *//* This getter remains lock-free (unsynchronized) for compatibility     *//* API calls instead).                                                  *//* alternative is to use GC_get_heap_usage_safe or GC_get_prof_stats    *//* with the GC lock held to avoid data races on multiprocessors (the    *//* This is an unsynchronized getter, so it should be called typically   *//* that were allocated but never written.                               *//* Includes empty blocks and fragmentation loss.  Includes some pages   *//* data structures.  Excludes the unmapped memory (returned to the OS). *//* Return the number of bytes in the heap.  Excludes collector private  *//* stop_func *//* Both the setter and getter acquire the GC lock to avoid data races.  *//* case when handling out of memory).  Must not be 0.                   *//* GC_gcollect() and by implicitly trigged collections (except for the  *//* Set and get the default stop_func.  The default stop_func is used by *//* collections are disabled), 1 if it succeeded.                        *//* GC_try_to_collect() returns 0 if the collection was aborted (or the  *//* to start from the beginning.  stop_func must not be 0.               *//* aborted collections do no useful work; the next collection needs     *//* than normal pause times for incremental collection.  However,        *//* available for this architecture.  Collections can be aborted faster  *//* if virtual dirty bits, and hence incremental collection is not       *//* collected heap or call most of GC functions.)  This works even       *//* it's not allowed for stop_func to manipulate pointers to the garbage *//* called with the allocation lock held and the world might be stopped; *//* called frequently, and should be reasonably fast.  (stop_func is     *//* and when stop_func returns a nonzero value.  Stop_func will be       *//* Trigger a full world-stopped collection.  Abort the collection if    *//* the system is running out of resources.                              *//* low-memory event; before retrying a system call failed because of    *//* switch setting).  The recommended usage: on receiving a system       *//* unmap as much memory as possible (regardless of the corresponding    *//* Same as above but ignores the default stop_func setting and tries to *//* Explicitly trigger a full, world-stop collection.    *//* n *//* being done.                                                          *//* The following version should be used if any debugging allocation is  *//* arbitrary interior pointers enabled, which is now the default.       *//* This is a no-op if the collector has recognition of                  *//* retention.                                                           *//* Calling it later adds to the probability of excess memory            *//* Preferably, this should be called before any other GC procedures.    *//* static data.)                                                        *//* considered valid in any case.  This applies to heap objects and      *//* (All pointers to the interior of objects from the stack are          *//* pointer to p.  N must be small and less than the size of p.          *//* by GC_malloc, then (char *)p + n will be considered to be a valid    *//* collector.  GC_register_displacement(n) means that if p was returned *//* Add a displacement to the set of those considered valid by the       *//* high_address_plus_1 *//* low_address *//* May be unimplemented on some platforms.                              *//* Remove a root segment.  Wizards only.                                *//* low_address must not be greater than high_address_plus_1.            *//* Both segment start and end are not needed to be pointer-aligned.     *//* Add a root segment.  Wizards only.                                   *//* Clear the set of root segments.  Wizards only.                       *//* Both section start and end are not needed to be pointer-aligned.     *//* mistaken for dynamic library data segments on some systems.          *//* maps large read/write files into the address space, which could be   *//* need not be scanned.  This is sometimes important if the application *//* memory contains no pointers to garbage collected memory.  Thus it    *//* Inform the collector that a certain section of statically allocated  *//* data races).                                                         *//* unsynchronized (so it might require GC_call_with_alloc_lock to avoid *//* n == 0 ==> unbounded.  This is the default.  This setter function is *//* especially on systems that don't handle running out of memory well.  *//* Limit the heap size to n bytes.  Useful when you're debugging,       *//* number_of_bytes *//* Returns 0 on failure, 1 on success.  *//* Explicitly increase the heap size.   *//* allocated memory.                                                    *//* case of the allocation failure or zero new size) or pointer to the   *//* them are non-NULL then old_object is freed.  Returns either NULL (in *//* If the returned pointer is not the same as old_object and both of    *//* memory pointed by old_object is untouched (and not freed).           *//* GC_malloc* or GC_realloc.  In case of the allocation failure, the    *//* is non-NULL, it must have been returned by an earlier call to        *//* call is equivalent to GC_free (and NULL is returned).  If old_object *//* size).  If new size is zero (and old_object is non-NULL) then the    *//* NULL old_object (i.e., equivalent to GC_malloc regardless of new     *//* for atomic object type).  The function follows ANSI conventions for  *//* case of object size growth is initialized to zero (not guaranteed    *//* the minimum of old size and new_size_in_bytes; the content above in  *//* It does not change the content of the object from its beginning to   *//* It is an error to have changes enabled for the original object.      *//* The resulting object has the same kind as the original.              *//* opinion, it shouldn't have been invented, but now we're stuck. -HB   *//* or with the standard C library, your code is broken.  In my          *//* a malloc followed by a bcopy.  But if you rely on that, either here  *//* For compatibility with C library.  This is occasionally faster than  *//* obj_addr *//* requested.                                                           *//* The returned size may be slightly larger than what was originally    *//* Given a pointer to the base of an object, return its size in bytes.  *//* or not.  It is assumed that the collector is already initialized.    *//* GC_base to check whether the pointed object is allocated by GC       *//* somewhere in GC heap.  Primary use is as a fast alternative to       *//* Return non-zero (TRUE) if and only if the argument points to         *//* displaced_pointer *//* GC_free.                                                             *//* may be considered valid, even if it has been deallocated with        *//* Note that a deallocated object in the garbage collected heap         *//* object.                                                              *//* Return 0 if displaced_pointer doesn't point to within a valid        *//* the base of the user object.                                         *//* actual base of the object, i.e. the debug information, not to        *//* Note that with debugging allocation, this returns a pointer to the   *//* I.e., map an interior pointer to the corresponding base pointer.     *//* a pointer to a location within the object.                           *//* Return a pointer to the base (lowest address) of an object given     *//* of the stored pointers.                                              *//* Should be followed typically by GC_reachable_here called for each    *//* the manual VDB mode (otherwise the function does nothing).           *//* changes.  Matters only if the incremental collection is enabled in   *//* Only non-NULL pointer stores into the object are considered to be    *//* Inform the collector that the object has been changed.               *//* only for the backward compatibility.                                 *//* The "stubborn" objects allocation is not supported anymore.  Exists  *//* GC_free(0) is a no-op, as required by ANSI C for free.               *//* explicitly deallocated.                                              *//* contain registered disappearing links of any kind) when it is        *//* An object should not be enabled for finalization (and it should not  *//* Requires a pointer to the base of an object.                         *//* Explicitly deallocate an object.  Dangerous if used incorrectly.     *//* align *//* memptr *//* GC_memalign() is not well tested.                                    *//* GC_non_gc_bytes appropriately.                                       *//* GC_free called on the resulting object implicitly update             *//* if it does not appear to be reachable.  GC_malloc_uncollectable and  *//* objects, but is not itself collectible.  The object is scanned even  *//* an object that is scanned for pointers to collectible                *//* new object is cleared.  GC_malloc_uncollectable allocates            *//* contained in the object.  The non-atomic versions guarantee that the *//* conv.  The atomic versions promise that no relevant pointers are     *//* General purpose allocation routines, with roughly malloc calling     *//* not be called after the shutdown.  See also GC_win32_free_heap().    *//* Win32 target.)  A duplicate invocation is a no-op.  GC_INIT should   *//* Perform the collector shutdown.  (E.g. dispose critical sections on  *//* (or, at least, the initialization is in progress).                   *//* Returns non-zero (TRUE) if and only if the collector is initialized  *//* from the main program instead.                                       *//* Initialize the collector.  Portable clients should call GC_INIT()    *//* should, of course, precede GC_start_mark_threads call (if any).      *//* branch (i.e., fork result is 0). Note that GC_atfork_child() call    *//* non-zero); GC_atfork_child is to be called immediately in the child  *//* the branch that corresponds to parent process (i.e., fork result is  *//* before fork(); GC_atfork_parent should be invoked just after fork in *//* automatically).  GC_atfork_prepare should be called immediately      *//* Routines to handle POSIX fork() manually (no-op if handled           *//* each fork() with the relevant GC_atfork_prepare/parent/child calls.  *//* of GC_set_handle_fork(-1) at application start-up and surrounding    *//* missing (or failed) pthread_atfork() could be avoided by invocation  *//* abort at GC initialization.  Starting from 7.3alpha3, problems with  *//* the latter might fail (or, even, absent on some targets) causing     *//* instructs GC_init to setup GC fork handlers using pthread_atfork,    *//* activities are not fully POSIX-compliant.)  GC_set_handle_fork       *//* in the forked child.  (Note that such client and atfork handlers     *//* with non-zero argument if going to use fork with GC functions called *//* called before GC_INIT.  Clients should invoke GC_set_handle_fork     *//* should install proper pthread_atfork handlers.  Has effect only if   *//* Overrides the default handle-fork mode.  Non-zero value means GC     *//* marking.  Not synchronized.                                          *//* Set/get the maximum number of prior attempts at the world-stop       *//* The value should not be zero.  Not synchronized.                     *//* Set/get the size in pages of units operated by GC_collect_a_little.  *//* is one.  Not synchronized.                                           *//* min_bytes_allocd().  The value should not be zero; the default value *//* The setter and getter of the minimum value returned by the internal  *//* use or need synchronization (i.e. acquiring the allocator lock).     *//* GC_INIT) unless the former has no effect on the platform.  Does not  *//* mode.  The mode could be changed by GC_set_pages_executable (before  *//* Returns non-zero value if the GC is set to the allocate-executable   *//* going to execute code on any of the GC-allocated memory objects.     *//* GC_set_pages_executable(1) call (before GC_INIT) provided they are   *//* the flag is off).  Portable clients should have                      *//* value is controlled by NO_EXECUTE_PERMISSION macro (if present then  *//* initialized.  May have no effect on some platforms.  The default     *//* the executable flag on.  Must be called before the collector is      *//* A non-zero argument instructs the collector to allocate memory with  *//* Set whether the GC will allocate executable memory pages or not.     *//* library has been compiled without NO_CLOCK.                          *//* The function does not use any synchronization.  Defined only if the  *//* Note that the returned value wraps around on overflow.               *//* performance measurements.  The measurement unit is one millisecond.  *//* Get the total time of all full collections since the start of the    *//* of now.  And, currently, there is no way to stop the measurements.   *//* Only the total time taken by full collections is calculated, as      *//* Tell the collector to start various performance measurements.        *//* Public procedures *//* after the GC is put to multi-threaded mode). *//* avoid data races (if the value is modified   *//* GC_call_with_alloc_lock() is required to     *//* The setter and getter are unsynchronized, so *//* tests.                                *//* will disable the "pause time exceeded"*//* Setting GC_time_limit to this value   *//* enabled.                              *//* leaving generational collection       *//* disable incremental collection while  *//* GC_TIME_UNLIMITED will essentially    *//* hard time bound.  Setting this to     *//* after this many milliseconds.  Not a  *//* We try to terminate collections       *//* If incremental collection is enabled, *//* accessed at GC initialization only). *//* locking is needed since the value is *//* are unsynchronized (and no external  *//* Wizards only.  The setter and getter *//* Interferes with blacklisting.        *//* before the first collection.         *//* manually initialize the root set     *//* if the client wants a chance to      *//* initialization.  Should be set only  *//* Do not collect as part of GC         *//* GC_register_my_thread() instead.     *//* GC_call_with_gc_active() and         *//* should use GC_get_stack_base(),      *//* primordial thread.  Portable clients *//* cold end of the stack for the        *//* For multi-threaded code, this is the *//* automatically.                       *//* collector attempts to set it         *//* confuse debuggers.  Otherwise the    *//* potentially some signals that can    *//* avoids some overhead, and            *//* calling any GC_ routines.  This      *//* May be set in the client prior to    *//* Cool end of user stack.              *//* expansion fails.  Initially 0.               *//* reporting out of memory after heap           *//* The maximum number of GCs attempted before   *//* returned the old value.                      *//* In version 7.1 (and before), the setter      *//* at the expense of space.                     *//* will appreciably decrease collection time    *//* but more collection time.  Decreasing it     *//* Increasing its value will use less space     *//* The initial value is GC_FREE_SPACE_DIVISOR.  *//* N approximates GC tracing work per GC.       *//* a rough estimate of the root set size.       *//* bytes (bytes in "atomic" objects), plus      *//* of traced bytes, plus the number of untraced *//* collections, where N is twice the number     *//* least N/GC_free_space_divisor bytes between  *//* We try to make sure that we allocate at      *//* The setter and getter are unsynchronized.     *//* of the root set.)                             *//* registration of the main data segment as part *//* and Apple's Darwin, this may also prevent     *//* (In some environments like Microsoft Windows  *//* application explicitly registers all roots.   *//* Wizards only.  Should be used only if the     *//* Don't register dynamic library data segments. *//* Wizards only.                                *//* GC_malloc_uncollectable and GC_free.         *//* of collections.  Updated by                  *//* collection.  Used only to control scheduling *//* Bytes not considered candidates for          *//* earlier GC versions.                     *//* perfectly reasonable, unlike for         *//* blocks.  Values in the tens are now      *//* increase in the number of in-use heap    *//* the collector detects a substantial      *//* Full collections are also triggered if   *//* GC_is_incremental_mode().                *//* full collections.  Matters only if       *//* Number of partial collections between    *//* in the collector.                                    *//* frequencies, and hence fewer instructions executed   *//* larger working set, but lower collection             *//* during each GC cycle.  It is likely to result in a   *//* very large blocks will tend to get broken up         *//* results in more large block fragmentation, since     *//* option for GC versions < 5.0.  This sometimes        *//* entire heap before collecting.  This was the only    *//* Causes the non-incremental collector to use the      *//* getter are unsynchronized.                   *//* requested or forced to.  The setter and      *//* Do not expand the heap unless explicitly     *//* preferred for new code.                      *//* GC is disabled, GC_is_disabled() is          *//* GC_dont_gc is deprecated.  To check whether  *//* GC_disable() calls.  Direct assignment to    *//* normally be updated with GC_enable() and     *//* and disabling work correctly.  Should        *//* Used as a counter, so that nested enabling   *//* this overrides explicit GC_gcollect() calls. *//* != 0 ==> Don't collect.  In versions 6.2a1+, *//* acquire the GC lock (to avoid data races).   *//* Both the supplied setter and the getter      *//* in response.  May be 0 (means no notifier).  *//* thread, which will call GC_invoke_finalizers *//* Typically this will notify a finalization    *//* GC_finalize_on_demand is set.                *//* once per GC cycle.  Never invoked unless     *//* objects to be finalized.  Invoked at most    *//* Invoked by the collector when there are      *//* The setter and getter are unsynchronized.    *//* work correctly.                              *//* Enables register_finalizer_unreachable to    *//* determined by JAVA_FINALIZATION macro.       *//* ordered finalization.  Default value is      *//* it a bit safer to use non-topologically-     *//* objects in a separate post-pass.  This makes *//* Mark objects reachable from finalizable      *//* when the collector is built.                 *//* the FINALIZE_ON_DEMAND macro is defined      *//* call.  The default is determined by whether  *//* response to an explicit GC_invoke_finalizers *//* If nonzero, finalizers will only be run in   *//* pointer recognition.  Must be only 0 or 1.   *//* at least a byte to allow "off the end"       *//* also affects whether sizes are increased by  *//* Unless DONT_ADD_BYTE_AT_END is defined, this *//* ALL_INTERIOR_POINTERS macro defined or not.  *//* depends on whether the GC is built with      *//* (to avoid data races).  The initial value    *//* initialized, the setter acquires the GC lock *//* case of calling it after the GC is           *//* not be changed after GC initialization (in   *//* be recognized as valid.  Typically should    *//* Arrange for pointers to object interiors to  *//* not use or need synchronization).            *//* after GC initialization (and, thus, it does  *//* The value should not typically be modified   *//* is determined by FIND_LEAK macro.            *//* deallocated with GC_FREE).  Initial value    *//* report inaccessible memory that was not      *//* (do not actually garbage collect, but simply *//* Set to true to turn on the leak-finding mode *//* partially).  May be 0 (means no notifier).   *//* GC lock held (and the world stopped          *//* resumed during collection.  Called with the  *//* Invoked when a thread is suspended or        *//* thread_id *//* stopped).  May be 0 (means no notifier).     *//* the GC lock held (or, even, the world        *//* suspend/resume notifications.  Called with   *//* collection process.  Not used for thread     *//* Invoked to indicate progress through the     *//* STARTWORLD_END *//* STARTWORLD_BEGIN *//* STOPWORLD_END *//* STOPWORLD_BEGIN *//* COLLECTION *//* allocation lock held).  May be 0.            *//* Called with the world stopped (and the       *//* Invoked when the heap grows or shrinks.      *//* new_size *//* object.  GC_oom_fn must not be 0.            *//* pointer to a previously allocated heap       *//* If it returns, it must return 0 or a valid   *//* returns NULL.                                *//* (*GC_oom_fn)(size).  By default this just    *//* an allocation request, we return             *//* When there is insufficient memory to satisfy *//* bytes_requested *//* The supplied setter and getter functions are preferred for new code. *//* Public R/W variables *//* excluding the initiating one).               *//* number of existing parallel marker threads   *//* number of marker threads minus one (i.e.     *//* GC v7.3, GC_parallel value is equal to the   *//* acquiring the GC lock).  Starting from       *//* not use or need synchronization (i.e.        *//* and may not be desirable.  The getter does   *//* collection is only partially functional,     *//* If GC_parallel is on (non-zero), incremental *//* (processors) are available.                  *//* variable is set to > 1, or multiple cores    *//* GC_MARKERS (or GC_NPROCS) environment        *//* PARALLEL_MARK defined, and if either         *//* only implicitly if collector is built with   *//* multiprocessors.  Set to a non-zero value    *//* GC is parallelized for performance on        *//* avoid data races on multiprocessors.         *//* it requires GC_call_with_alloc_lock() to     *//* GC_get_gc_no() is unsynchronized, so         *//* Includes empty GCs at startup.               *//* Counter incremented per collection.          *//* The supplied getter functions are preferred for new code.            *//* Public read-only variables *//* form: ((version_major<<16) | (version_minor<<8) | version_micro).    *//* Get the GC library version. The returned value is a constant in the  *//* systems.  Notably "typedef int size_t" is WRONG.                     *//* better choices.  But those had incorrect definitions on some older   *//* The ANSI standard suggests that size_t and ptrdiff_t might be        *//* than almost anything else.                                           *//* even semi-portably.  The following is probably no better/worse       *//* size as char * or void *.  There seems to be no way to do this       *//* Define word and signed_word to be unsigned and signed types of the   *//* preserved only for backward compatibility    *//* the latter.                                                  *//* dynamic library.  GC_get_version() can be used to obtain     *//* version number, which may or may not match that of the       *//* for cross-builds.  Note that this defines the header         *//* Define version numbers here to allow test on build machine   *//* Help debug mixed up preprocessor symbols.    *//*
 * Note that this defines a large number of tuning hooks, which can
 * safely be ignored in nearly all cases.  For normal use it suffices
 * to call only GC_MALLOC and perhaps GC_REALLOC.
 * For better performance, also look at GC_MALLOC_ATOMIC, and
 * GC_enable_incremental.  If you need an action to be performed
 * immediately before an object is collected, look at GC_register_finalizer.
 * Everything else is best ignored unless you encounter performance
 * problems.
 *//*
 * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers
 * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.
 * Copyright 1996-1999 by Silicon Graphics.  All rights reserved.
 * Copyright 1999 by Hewlett-Packard Company.  All rights reserved.
 * Copyright (C) 2007 Free Software Foundation, Inc
 * Copyright (c) 2000-2011 by Hewlett-Packard Development Company.
 * Copyright (c) 2009-2018 Ivan Maidanski
 *
 * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED
 * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
 *
 * Permission is hereby granted to use or copy this program
 * for any purpose,  provided the above notices are retained on all copies.
 * Permission to modify the code and to distribute modified code is granted,
 * provided the above notices are retained, and a notice that the code was
 * modified is included with the above copyright notice.
 */i/usr/include/guile/2.0/libguile/bdw-gc.h<gc/gc.h>SCM_I_REGISTER_DISAPPEARING_LINK(link,obj)((SCM_I_IS_POINTER_TO_THE_HEAP (obj)) ? GC_GENERAL_REGISTER_DISAPPEARING_LINK ((link), (obj)) : 0)SCM_I_IS_POINTER_TO_THE_HEAP(ptr)(GC_base (ptr) != NULL)GC_REDIRECT_TO_LOCALSCM_BDW_GC_H(! ((defined GC_VERSION_MAJOR) && (GC_VERSION_MAJOR >= 7)))/* SCM_BDW_GC_H *//* Register a disappearing link for the object pointed to by OBJ such that
   the pointer pointed to be LINK is cleared when OBJ is reclaimed.  Do so
   only if OBJ actually points to the heap.  See
   http://thread.gmane.org/gmane.comp.programming.garbage-collection.boehmgc/2563
   for details.  *//* Return true if PTR points to the heap.  *//* This was needed with `libgc' 6.x.  *//* Rely on pthreads-w32.  *//* Don't #define pthread routines to their GC_pthread counterparts.
   Instead we will be careful inside Guile to use the GC_pthread
   routines.  *//* When pthreads are used, let `libgc' know about it and redirect allocation
   calls such as `GC_MALLOC ()' to (contention-free, faster) thread-local
   allocation.  *//* Correct header inclusion.  *//* Copyright (C) 2006, 2008, 2009, 2011, 2012, 2013 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/pthread-threads.h"libguile/bdw-gc.h"pthread_mutexattr_t[1]union <unnamed>[1]scm_i_pthread_mutexattr_recursivescm_i_scm_pthread_cond_timedwaitscm_pthread_cond_timedwaitscm_i_scm_pthread_cond_waitscm_pthread_cond_waitscm_i_dynwind_pthread_mutex_lockscm_dynwind_pthread_mutex_lockscm_i_scm_pthread_mutex_lockscm_pthread_mutex_lockscm_i_pthread_getspecificscm_i_pthread_setspecificscm_i_pthread_key_createscm_i_pthread_key_tpthread_key_tSCM_I_PTHREAD_ONCE_INITscm_i_pthread_oncescm_i_pthread_once_tpthread_once_tscm_i_pthread_cond_timedwaitscm_i_pthread_cond_waitscm_i_pthread_cond_broadcastscm_i_pthread_cond_signalscm_i_pthread_cond_destroyscm_i_pthread_cond_initscm_i_pthread_cond_tpthread_cond_tSCM_I_PTHREAD_COND_INITIALIZERscm_i_pthread_mutex_unlockscm_i_pthread_mutex_lockscm_i_pthread_mutex_trylockscm_i_pthread_mutex_destroyscm_i_pthread_mutex_initscm_i_pthread_mutex_tpthread_mutex_tSCM_I_PTHREAD_MUTEX_INITIALIZERscm_i_pthread_sigmaskscm_i_sched_yieldscm_i_pthread_cleanup_poppthread_cleanup_popscm_i_pthread_cleanup_pushpthread_cleanup_pushscm_i_pthread_cancelscm_i_pthread_exitscm_i_pthread_detachscm_i_pthread_createscm_i_pthread_selfscm_i_pthread_tSCM_PTHREADS_THREADS_H/* SCM_PTHREADS_THREADS_H *//* Convenience functions
 *//* Thread specific storage
 *//* Onces
 *//* Condition variables
 *//* Mutexes
 *//* Signals
 *//* Threads 
*//* `libgc' defines wrapper procedures for pthread calls.  *//* The pthreads-threads implementation.  This is a direct mapping.
*//* Copyright (C) 2002, 2005, 2006, 2011 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/threads.h"libguile/pthread-threads.h""libguile/continuations.h""libguile/dynwind.h""libguile/iselect.h""libguile/root.h""libguile/procs.h"scm_current_processor_countscm_total_processor_countscm_std_usleepscm_std_sleepconst scm_t_timespecconst scm_t_timespec *scm_dynwind_critical_sectionscm_thread_exited_pscm_c_thread_exited_pscm_all_threadsscm_current_threadscm_condition_variable_pscm_broadcast_condition_variablescm_signal_condition_variablescm_timed_wait_condition_variablescm_wait_condition_variablescm_make_condition_variablescm_mutex_levelscm_mutex_ownerscm_mutex_locked_pscm_mutex_pscm_unlock_mutex_timedscm_unlock_mutexscm_try_mutexscm_dynwind_lock_mutexscm_lock_mutex_timedscm_lock_mutexscm_make_mutex_with_flagsscm_make_recursive_mutexscm_make_mutexscm_thread_pscm_join_thread_timedscm_join_threadscm_thread_cleanupscm_set_thread_cleanup_xscm_cancel_threadscm_yieldscm_call_with_new_threadscm_i_dynwind_pthread_mutex_lock_block_asyncsscm_init_threads_default_dynamic_statescm_init_thread_procsscm_init_threadsscm_threads_prehistoryscm_i_reset_fluidscm_with_guilescm_without_guilescm_spawn_threadscm_i_threadcritical_section_levelregscontinuation_basecontinuation_rootpending_asyncsblock_asyncsactive_asyncsdynwindsdynamic_statecurrent_mark_stack_limitcurrent_mark_stack_ptrint[2]sleep_pipesleep_fdsleep_condsleep_mutexsleep_objectguile_modeexitedcanceledresultheld_mutexmutexesadmin_mutexjoin_queuecleanup_handlerpthreadscm_i_thread *next_threadscm_i_misc_mutexscm_tc16_condvarscm_tc16_mutexscm_tc16_threadSCM_THREAD_SWITCHING_CODEdo { } while (0)SCM_VALIDATE_CONDVAR(pos,a)scm_assert_smob_type (scm_tc16_condvar, (a))SCM_VALIDATE_MUTEX(pos,a)scm_assert_smob_type (scm_tc16_mutex, (a))SCM_VALIDATE_THREAD(pos,a)scm_assert_smob_type (scm_tc16_thread, (a))SCM_I_THREAD_DATA(x)((scm_i_thread *) SCM_SMOB_DATA (x))SCM_I_IS_THREAD(x)SCM_SMOB_PREDICATE (scm_tc16_thread, x)SCM_THREADS_H/* SCM_THREADS_H *//* More convenience functions.
 *//* Convenience functions for working with the pthread API in guile
   mode.
*//* !SCM_HAVE_THREAD_STORAGE_CLASS *//* Though we don't need the key for SCM_I_CURRENT_THREAD if we have TLS,
   we do use it for cleanup purposes.  *//* Whether this thread is in a critical section. *//* For keeping track of the stack and registers. *//* The current continuation root and the stack base for it.

     The continuation root is an arbitrary but unique object that
     identifies a dynamic extent.  Continuations created during that
     extent can also only be invoked during it.

     We use pairs where the car is the thread handle and the cdr links
     to the previous pair.  This might be used for better error
     messages but is not essential for identifying continuation roots.

     The continuation base is the far end of the stack upto which it
     needs to be copied.
  *//* Non-zero means that asyncs might be pending.
				 *//* Non-zero means that asyncs should
                                   not be run. *//* The thunks to be run at the next
                                   safe point *//* For system asyncs.
   *//* Other thread local things.
   *//* XXX: These two fields used to hold information about the BDW-GC
     mark stack during the mark phase.  They are no longer used.  *//* Boolean indicating whether the thread is in guile mode.  *//* smob tags for the thread datatypes *//* Copyright (C) 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2006,
 *   2007, 2008, 2009, 2011, 2013 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */condmutexabstimethreadoownerflagsttimeoutval/usr/include/guile/2.0/libguile/async.h"libguile/threads.h"scm_mask_signalsscm_unmask_signalsscm_system_asyncscm_init_asyncscm_critical_section_endscm_critical_section_startscm_dynwind_unblock_asyncsscm_dynwind_block_asyncsscm_c_call_with_unblocked_asyncsscm_c_call_with_blocked_asyncsscm_call_with_unblocked_asyncsscm_call_with_blocked_asyncsscm_noopscm_run_asyncsscm_i_reset_sleepscm_i_setup_sleepscm_i_queue_async_cellscm_system_async_mark_for_threadscm_system_async_markscm_async_markscm_asyncscm_switchscm_async_clickscm_i_critical_section_mutexSCM_CRITICAL_SECTION_ENDscm_critical_section_end ()SCM_CRITICAL_SECTION_STARTscm_critical_section_start ()SCM_ASYNC_H/* SCM_ASYNC_H *//* Defined in threads.c. *//* XXX - every critical section needs to be examined whether the
   requirements for SCM_CRITICAL_SECTION_START/END are fulfilled.  See
   the manual.
*//* Critical sections *//* Copyright (C) 1995-1998, 2000-2002, 2004-2006, 2008, 2009,
 *   2014 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */list_of_afdcell/usr/include/guile/2.0/libguile/boolean.hscm_init_booleanscm_boolean_pscm_notscm_to_boolscm_is_boolscm_is_lisp_false(x)(SCM_MATCHES_BITS_IN_COMMON ((x), SCM_BOOL_F, SCM_EOL))SCM_BOOL_NOT(x)(scm_not (x))SCM_NEGATE_BOOL(f)(scm_from_bool (!(f)))SCM_BOOL(x)(scm_from_bool (x))SCM_BOOLP(x)(scm_is_bool (x))SCM_NFALSEP(x)(scm_is_true (x))SCM_FALSEP(x)(scm_is_false (x))scm_from_bool(x)((x) ? SCM_BOOL_T : SCM_BOOL_F)scm_is_bool(x)(scm_is_bool_or_nil (x))scm_is_bool_and_not_nil(x)(SCM_MATCHES_BITS_IN_COMMON ((x), SCM_BOOL_F, SCM_BOOL_T))scm_is_bool_or_nil(x)(SCM_MATCHES_BITS_IN_COMMON ((x), SCM_BOOL_T, SCM_ELISP_NIL))scm_is_true(x)(!scm_is_false (x))scm_is_false(x)(scm_is_false_or_nil (x))scm_is_true_and_not_nil(x)(!scm_is_false_or_nil (x))scm_is_false_or_nil(x)(SCM_MATCHES_BITS_IN_COMMON ((x), SCM_ELISP_NIL, SCM_BOOL_F))scm_is_true_assume_not_nil(x)(!scm_is_eq ((x), SCM_BOOL_F))scm_is_false_assume_not_nil(x)(scm_is_eq ((x), SCM_BOOL_F))scm_is_true_or_nil(x)scm_is_false_and_not_nil(x)SCM_BOOLEAN_H/* SCM_BOOLEAN_H *//*
 * The following macros efficiently implement boolean truth testing as
 * expected by most lisps, which treat '() aka SCM_EOL as false.
 *
 * Since we know SCM_ELISP_NIL and SCM_BOOL_F differ by exactly one
 * bit, and that SCM_ELISP_NIL and SCM_EOL differ by exactly one bit,
 * and that they of course can't be the same bit (or else SCM_BOOL_F
 * and SCM_EOL be would equal), it follows that SCM_BOOL_F and SCM_EOL
 * differ by exactly two bits, and these are the bits which will be
 * ignored by SCM_MATCHES_BITS_IN_COMMON below.
 *
 * See the comments preceeding the definitions of SCM_BOOL_F and
 * SCM_MATCHES_BITS_IN_COMMON in tags.h for more information.
 *
 * scm_is_lisp_false(x) returns 1 if and only if x is one of the
 * following: SCM_BOOL_F, SCM_ELISP_NIL, SCM_EOL or
 * SCM_XXX_ANOTHER_LISP_FALSE_DONT_USE.  Otherwise, it returns 0.
 *//* Older spellings for the above routines, kept around for
   compatibility. *//*
 * Since we know SCM_BOOL_F and SCM_BOOL_T differ by exactly one bit,
 * and that SCM_BOOL_F and SCM_ELISP_NIL differ by exactly one bit,
 * and that they of course can't be the same bit (or else SCM_BOOL_T
 * and SCM_ELISP_NIL be would equal), it follows that SCM_BOOL_T and
 * SCM_ELISP_NIL differ by exactly two bits, and these are the bits
 * which will be ignored by SCM_MATCHES_BITS_IN_COMMON below.
 *
 * See the comments preceeding the definitions of SCM_BOOL_F and
 * SCM_MATCHES_BITS_IN_COMMON in tags.h for more information.
 *
 * If SCM_ENABLE_ELISP is true, then scm_is_bool_or_nil(x)
 * returns 1 if and only if x is one of the following: SCM_BOOL_F,
 * SCM_BOOL_T, SCM_ELISP_NIL, or SCM_XXX_ANOTHER_BOOLEAN_DONT_USE_0.
 * Otherwise, it returns 0.
 *//* #nil is false. *//*
 * See the comments preceeding the definitions of SCM_BOOL_F and
 * SCM_MATCHES_BITS_IN_COMMON in tags.h for more information on
 * how the following macro works.
 *//*
 * Use these macros if #nil will never be tested,
 * for increased efficiency.
 *//*
 * Use these macros if it's important (for correctness)
 * that #nil MUST be considered true
 *//* Boolean Values. Obviously there are #t and #f, but there is also nil to deal
 * with. We choose to treat nil as a false boolean. All options might silently
 * break existing code, but this one seems most responsible.
 *
 *//* Copyright (C) 1995,1996,2000, 2006, 2008, 2009, 2010 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/bitvectors.h"libguile/array-handle.h"scm_init_bitvectorsscm_i_bitvector_equal_pscm_i_print_bitvectorscm_t_uint32 *scm_bitvector_writable_elementsssize_t *const scm_t_uint32const scm_t_uint32 *scm_bitvector_elementsscm_array_handle_bit_elements_offsetscm_array_handle_bit_writable_elementsscm_array_handle_bit_elementsscm_c_bitvector_set_xscm_c_bitvector_refscm_c_bitvector_lengthscm_c_make_bitvectorscm_is_bitvectorscm_istr2bvescm_bit_invert_xscm_bit_count_starscm_bit_set_star_xscm_bit_positionscm_bit_countscm_bitvector_fill_xscm_bitvector_to_listscm_list_to_bitvectorscm_bitvector_set_xscm_bitvector_refscm_bitvector_lengthscm_make_bitvectorscm_bitvectorscm_bitvector_pSCM_BITVECTORS_H/* SCM_BITVECTORS_H *//** Bit vectors *//* Bitvectors. Exciting stuff, maybe!
 *//* Copyright (C) 1995,1996,1997,1999,2000,2001, 2004, 2006, 2008, 2009 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */vec1vec2vecoffplenpincpidxkvitemseqlistbits/usr/include/guile/2.0/libguile/bytevectors.hscm_i_bytevector_generalized_set_xscm_c_shrink_bytevectorscm_i_print_bytevectorscm_c_take_gc_bytevectorsigned char *scm_init_bytevectorsscm_bootstrap_bytevectorsscm_c_take_typed_bytevectorscm_i_make_typed_bytevectorscm_utf32_to_stringscm_utf16_to_stringscm_utf8_to_stringscm_string_to_utf32scm_string_to_utf16scm_string_to_utf8scm_bytevector_ieee_double_native_set_xscm_bytevector_ieee_double_set_xscm_bytevector_ieee_double_native_refscm_bytevector_ieee_double_refscm_bytevector_ieee_single_native_set_xscm_bytevector_ieee_single_set_xscm_bytevector_ieee_single_native_refscm_bytevector_ieee_single_refscm_bytevector_s64_set_xscm_bytevector_u64_set_xscm_bytevector_s32_set_xscm_bytevector_u32_set_xscm_bytevector_s16_set_xscm_bytevector_u16_set_xscm_bytevector_sint_set_xscm_bytevector_uint_set_xscm_bytevector_s8_set_xscm_bytevector_u8_set_xscm_bytevector_s64_native_set_xscm_bytevector_u64_native_set_xscm_bytevector_s32_native_set_xscm_bytevector_u32_native_set_xscm_bytevector_s16_native_set_xscm_bytevector_u16_native_set_xscm_bytevector_s64_refscm_bytevector_u64_refscm_bytevector_s32_refscm_bytevector_u32_refscm_bytevector_s16_refscm_bytevector_u16_refscm_bytevector_sint_refscm_bytevector_uint_refscm_bytevector_s8_refscm_bytevector_u8_refscm_bytevector_s64_native_refscm_bytevector_u64_native_refscm_bytevector_s32_native_refscm_bytevector_u32_native_refscm_bytevector_s16_native_refscm_bytevector_u16_native_refscm_bytevector_to_sint_listscm_sint_list_to_bytevectorscm_bytevector_to_uint_listscm_uint_list_to_bytevectorscm_u8_list_to_bytevectorscm_bytevector_to_u8_listscm_uniform_array_to_bytevectorscm_bytevector_copyscm_bytevector_copy_xscm_bytevector_fill_xscm_bytevector_eq_pscm_bytevector_lengthscm_bytevector_pscm_native_endiannessscm_make_bytevectorscm_c_bytevector_set_xscm_c_bytevector_refscm_c_bytevector_lengthscm_is_bytevectorscm_c_make_bytevectorscm_null_bytevectorscm_i_native_endiannessscm_endianness_littlescm_endianness_bigSCM_GC_BYTEVECTOR"bytevector"SCM_BYTEVECTOR_CONTIGUOUS_P(_bv)(SCM_BYTEVECTOR_FLAGS (_bv) >> 8UL)SCM_BYTEVECTOR_ELEMENT_TYPE(_bv)(SCM_BYTEVECTOR_FLAGS (_bv) & 0xffUL)SCM_SET_BYTEVECTOR_FLAGS(_bv,_f)SCM_SET_CELL_TYPE ((_bv), scm_tc7_bytevector | ((scm_t_bits)(_f) << 7UL))SCM_BYTEVECTOR_FLAGS(_bv)(SCM_CELL_TYPE (_bv) >> 7UL)SCM_BYTEVECTOR_P(x)(!SCM_IMP (x) && SCM_TYP7(x) == scm_tc7_bytevector)SCM_BYTEVECTOR_CONTENTS(_bv)((signed char *) SCM_CELL_WORD_2 (_bv))SCM_BYTEVECTOR_LENGTH(_bv)((size_t) SCM_CELL_WORD_1 (_bv))SCM_BYTEVECTOR_HEADER_SIZE3USCM_BYTEVECTORS_H/* SCM_BYTEVECTORS_H *//* Hint that is passed to `scm_gc_malloc ()' and friends.  *//* Internal API.  *//* The size in words of the bytevector header (type tag and flags, length,
   and pointer to the underlying buffer).  *//* R6RS bytevectors.  *//* Copyright (C) 2009, 2011 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/dynl.hscm_init_dynamic_linkingscm_dynamic_callscm_dynamic_funcscm_dynamic_pointerscm_dynamic_object_pscm_dynamic_unlinkscm_dynamic_linkSCM_DYNL_H/* SCM_DYNL_H *//* Copyright (C) 1996,1998,2000,2001, 2006, 2008, 2010 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */symbdobjfname/usr/include/guile/2.0/libguile/eq.hscm_init_eqscm_equal_pscm_eqv_pscm_eq_pSCM_EQ_P(x,y)(scm_is_eq (x, y))SCM_EQ_H/* SCM_EQ_H *//* An older spelling for scm_is_eq. *//* scm_is_eq is defined in tags.h for some reason. *//* Copyright (C) 1995,1996,2000, 2006, 2008, 2010 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/struct.hscm_init_structscm_i_struct_inherit_vtable_magicscm_i_alloc_structscm_t_bits *scm_i_struct_hashscm_struct_ihashqscm_i_struct_equalpscm_print_structscm_set_struct_vtable_name_xscm_struct_vtable_namescm_struct_vtablescm_struct_set_xscm_struct_refscm_make_vtable_vtablescm_i_make_vtable_vtablescm_make_vtablescm_c_make_structvscm_t_bits[]unsigned long[]scm_c_make_structscm_make_structscm_struct_vtable_pscm_struct_pscm_make_struct_layoutscm_t_struct_finalizescm_applicable_struct_with_setter_vtable_vtablescm_applicable_struct_vtable_vtablescm_standard_vtable_vtableSCM_SET_STRUCT_SETTER(X,P)(SCM_STRUCT_SLOT_SET (X, scm_applicable_struct_index_setter, P))SCM_STRUCT_SETTER(X)(SCM_STRUCT_SLOT_REF (X, scm_applicable_struct_index_setter))SCM_SET_STRUCT_PROCEDURE(X,P)(SCM_STRUCT_SLOT_SET (X, scm_applicable_struct_index_procedure, P))SCM_STRUCT_PROCEDURE(X)(SCM_STRUCT_SLOT_REF (X, scm_applicable_struct_index_procedure))SCM_STRUCT_SETTER_P(X)(SCM_STRUCT_VTABLE_FLAG_IS_SET ((X), SCM_VTABLE_FLAG_SETTER))SCM_STRUCT_APPLICABLE_P(X)(SCM_STRUCT_VTABLE_FLAG_IS_SET ((X), SCM_VTABLE_FLAG_APPLICABLE))SCM_STRUCT_VTABLE_FLAG_IS_SET(X,F)(SCM_STRUCT_VTABLE_DATA (X)[scm_vtable_index_flags]&(F))SCM_STRUCT_VTABLE_FLAGS(X)(SCM_STRUCT_VTABLE_DATA (X)[scm_vtable_index_flags])SCM_STRUCT_FINALIZER(X)((scm_t_struct_finalize)SCM_STRUCT_VTABLE_DATA (X)[scm_vtable_index_instance_finalize])SCM_STRUCT_PRINTER(X)(SCM_STRUCT_VTABLE_SLOTS (X)[scm_vtable_index_instance_printer])SCM_STRUCT_LAYOUT(X)(SCM_STRUCT_VTABLE_SLOTS (X)[scm_vtable_index_layout])SCM_STRUCT_VTABLE(X)(SCM_STRUCT_VTABLE_SLOTS(X)[scm_vtable_index_self])SCM_STRUCT_VTABLE_SLOTS(X)((SCM*)(SCM_CELL_WORD_0 (X) - scm_tc3_struct))SCM_STRUCT_VTABLE_DATA(X)((scm_t_bits*)(SCM_CELL_WORD_0 (X) - scm_tc3_struct))SCM_SET_VTABLE_NAME(X,V)(SCM_STRUCT_SLOT_SET (X, scm_vtable_index_name, V))SCM_VTABLE_NAME(X)(SCM_STRUCT_SLOT_REF (X, scm_vtable_index_name))SCM_SET_VTABLE_INSTANCE_PRINTER(X,P)(SCM_STRUCT_SLOT_SET (X, scm_vtable_index_instance_printer, (P)))SCM_VTABLE_INSTANCE_PRINTER(X)(SCM_STRUCT_SLOT_REF (X, scm_vtable_index_instance_printer))SCM_SET_VTABLE_INSTANCE_FINALIZER(X,P)(SCM_STRUCT_DATA_SET (X, scm_vtable_index_instance_finalize, (scm_t_bits)(P)))SCM_VTABLE_INSTANCE_FINALIZER(X)((scm_t_struct_finalize)SCM_STRUCT_DATA_REF (X, scm_vtable_index_instance_finalize))SCM_VTABLE_FLAG_IS_SET(X,F)(SCM_STRUCT_DATA_REF (X, scm_vtable_index_flags) & (F))SCM_CLEAR_VTABLE_FLAGS(X,F)(SCM_STRUCT_DATA_REF (X, scm_vtable_index_flags) &= (~(F)))SCM_SET_VTABLE_FLAGS(X,F)(SCM_STRUCT_DATA_REF (X, scm_vtable_index_flags) |= (F))SCM_VTABLE_FLAGS(X)(SCM_STRUCT_DATA_REF (X, scm_vtable_index_flags))SCM_SET_VTABLE_LAYOUT(X,L)(SCM_STRUCT_SLOT_SET ((X), scm_vtable_index_layout, L))SCM_VTABLE_LAYOUT(X)(SCM_STRUCT_SLOT_REF ((X), scm_vtable_index_layout))SCM_STRUCT_DATA_SET(X,I,V)SCM_STRUCT_DATA (X)[(I)]=(V)SCM_STRUCT_DATA_REF(X,I)(SCM_STRUCT_DATA (X)[(I)])SCM_STRUCT_DATA(X)((scm_t_bits*)SCM_CELL_WORD_1 (X))SCM_STRUCT_SLOT_SET(X,I,V)SCM_STRUCT_SLOTS (X)[(I)]=(V)SCM_STRUCT_SLOT_REF(X,I)(SCM_STRUCT_SLOTS (X)[(I)])SCM_STRUCT_SLOTS(X)((SCM*)SCM_CELL_WORD_1 ((X)))SCM_STRUCTP(X)(!SCM_IMP(X) && (SCM_TYP3(X) == scm_tc3_struct))SCM_VTABLE_USER_FLAG_SHIFTSCM_VTABLE_FLAG_GOOPS_3(1L << 15)SCM_VTABLE_FLAG_GOOPS_2(1L << 14)SCM_VTABLE_FLAG_GOOPS_1(1L << 13)SCM_VTABLE_FLAG_GOOPS_0(1L << 12)SCM_VTABLE_FLAG_SMOB_0(1L << 11)SCM_VTABLE_FLAG_RESERVED_2(1L << 10)SCM_VTABLE_FLAG_RESERVED_1(1L << 9)SCM_VTABLE_FLAG_RESERVED_0(1L << 8)SCM_VTABLE_FLAG_SIMPLE_RW(1L << 7)SCM_VTABLE_FLAG_SIMPLE(1L << 6)SCM_VTABLE_FLAG_SETTER(1L << 5)SCM_VTABLE_FLAG_SETTER_VTABLE(1L << 4)SCM_VTABLE_FLAG_APPLICABLE(1L << 3)SCM_VTABLE_FLAG_APPLICABLE_VTABLE(1L << 2)SCM_VTABLE_FLAG_VTABLE(1L << 1)SCM_VTABLE_FLAG_VALIDATED(1L << 0)scm_applicable_struct_index_setterscm_applicable_struct_index_procedureSCM_APPLICABLE_WITH_SETTER_BASE_LAYOUT"pw" "pw"SCM_APPLICABLE_BASE_LAYOUT"pw"scm_vtable_offset_userscm_vtable_index_reserved_7scm_vtable_index_sizescm_vtable_index_namescm_vtable_index_instance_printerscm_vtable_index_instance_finalizescm_vtable_index_selfscm_vtable_index_flagsscm_vtable_index_layoutSCM_VTABLE_BASE_LAYOUT"pr" "uh" "sr" "uh" "pw" "ph" "uh" "uh"SCM_STRUCT_H/* SCM_STRUCT_H *//* But often we just need to access the vtable's data; we can do that without
   the data->self->data indirection. *//* Structs hold a pointer to their vtable's data, not the vtable itself. To get
   the vtable we have to do an indirection through the self slot. *//* The SCM_VTABLE_* macros assume that you're passing them a struct which is a
   valid vtable. *//* instances of this vtable have only "pw" fields and no tail array *//* instances of this vtable have only "p" fields and no tail array*//* instances of this vtable are applicable-with-setters? *//* instances of this vtable are applicable-with-setter vtables? *//* instances of this vtable are applicable? *//* instances of this vtable are applicable vtables? *//* instances of this vtable are themselves vtables? *//* the layout of this vtable been validated? *//* The setter of an applicable
                                                   struct. Only valid if the
                                                   struct's vtable has the
                                                   setter flag set. *//* The procedure of an applicable
                                                   struct. Only valid if the
                                                   struct's vtable has the
                                                   applicable flag set. *//* setter *//* procedure *//* All applicable structs have the following fields. *//* Where do user fields start in the vtable? *//* Number of fields, for simple structs.  *//* Name of this vtable. *//* A printer for this struct type. *//* Finalizer for instances of this struct type. *//* A pointer to the vtable itself *//* Class flags *//* A symbol describing the physical arrangement of this type. *//* size *//* name (hidden from make-struct for back-compat reasons) *//* printer *//* finalizer *//* self *//* flags *//* layout *//* All vtables have the following fields. *//* The relationship between a struct and its vtable is a bit complicated,
   because we want structs to be used as GOOPS' native representation -- which
   in turn means we need support for changing the "class" (vtable) of an
   "instance" (struct). This necessitates some indirection and trickery.

   To summarize, structs are laid out this way:

                  .-------.
                  |       |
     .----------------+---v------------- -
     | vtable | data  | slot0 | slot1 |
     `----------------+----------------- -
         |        .-------.
         |        |       |
     .---v------------+---v------------- -
     | vtable | data  | slot0 | slot1 |
     `----------------+----------------- -
         |
         v

        ...
                  .-------.
         |        |       |
     .---v------------+---v------------- -
   .-| vtable | data  | slot0 | slot1 |
   | `----------------+----------------- -
   |     ^
   `-----'

   The DATA indirection (which corresponds to `SCM_STRUCT_DATA ()') is necessary
   to implement class redefinition.

   For more details, see:

     http://wingolog.org/archives/2009/11/09/class-redefinition-in-guile

 *//* Copyright (C) 1995,1997,1999,2000,2001, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */vtablevtable_datan_wordsdepths1s2extra_fieldstail_array_sizeinitfieldsprintern_tailn_inits/usr/include/guile/2.0/libguile/memoize.hscm_init_memoizescm_memoized_pscm_memoize_variable_access_xscm_memoized_typecodescm_memoized_expression_datascm_memoized_expression_typecodescm_unmemoize_expressionscm_memoize_expressionSCM_M_BEGINSCM_M_IFSCM_M_LAMBDASCM_M_LETSCM_M_QUOTESCM_M_DEFINESCM_M_DYNWINDSCM_M_WITH_FLUIDSSCM_M_APPLYSCM_M_CONTSCM_M_CALL_WITH_VALUESSCM_M_CALLSCM_M_LEXICAL_REFSCM_M_LEXICAL_SETSCM_M_TOPLEVEL_REFSCM_M_TOPLEVEL_SETSCM_M_MODULE_REFSCM_M_MODULE_SET17SCM_M_PROMPT18scm_tc16_memoizedscm_sym_argsscm_sym_set_xscm_sym_applyscm_sym_elsescm_sym_arrowscm_sym_eval_whenscm_sym_at_dynamic_windscm_sym_delayscm_sym_at_promptscm_sym_at_call_with_valuesscm_sym_atcall_ccscm_sym_atapplyscm_sym_atatscm_sym_atscm_sym_with_fluidsscm_sym_uq_splicingscm_sym_unquotescm_sym_quasiquotescm_sym_quotescm_sym_letrecscm_sym_letstarscm_sym_letscm_sym_lambdascm_sym_ifscm_sym_doscm_sym_definescm_sym_condscm_sym_casescm_sym_beginscm_sym_andSCM_MEMOIZED_ARGS(x)(SCM_SMOB_OBJECT (x))SCM_MEMOIZED_TAG(x)(SCM_SMOB_FLAGS (x))SCM_MEMOIZED_P(x)(SCM_SMOB_PREDICATE (scm_tc16_memoized, (x)))SCM_MEMOIZE_H/* SCM_MEMOIZE_H *//* {Memoized Source}
 *//* Copyright (C) 1995,1996,1998,1999,2000,2001,2002,2004,2008,2009,2010
 * Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */memoizedmodule/usr/include/guile/2.0/libguile/eval.h"libguile/memoize.h""libguile/struct.h"scm_init_evalscm_evalscm_primitive_evalscm_for_eachscm_mapscm_applyscm_nconc2lastscm_apply_3scm_apply_2scm_apply_1scm_apply_0scm_callscm_call_nscm_call_9scm_call_8scm_call_7scm_call_6scm_call_5scm_call_4scm_call_3scm_call_2scm_call_1scm_call_0scm_t_trampoline_2scm_t_trampoline_1scm_t_trampoline_0scm_eval_x(exp,module)scm_eval (exp, module)scm_primitive_eval_x(exp)scm_primitive_eval (exp)scm_dapply(proc,arg1,args)scm_apply (proc, arg1, args)SCM_EXTEND_ENVSCM_ILOCP(n)(SCM_ITAG8(n)==scm_tc8_iloc)SCM_EVAL_H/* SCM_EVAL_H *//* {Ilocs}
 *
 * Ilocs are relative pointers into local environment structures.
 * 
 *//* {Options}
 *//* Copyright (C) 1995,1996,1998,1999,2000,2001,2002,2003,2004,2008,2009,2010,2011,2012
 * Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */arg1arg2arg3argvnargsarg4arg5arg6arg7arg8arg9/usr/include/guile/2.0/libguile/evalext.hscm_init_evalextscm_self_evaluating_pscm_defined_pscm_definedpSCM_EVALEXT_H/* SCM_EVALEXT_H *//* Copyright (C) 1998,1999,2000, 2003, 2006, 2008 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/extensions.hscm_init_extensionsscm_load_extensionscm_c_load_extensionscm_c_register_extensionscm_t_extension_init_funcSCM_EXTENSIONS_H/* SCM_EXTENSIONS_H *//* Copyright (C) 2001, 2006, 2008 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */lib/usr/include/guile/2.0/libguile/feature.hscm_init_featurescm_set_program_arguments_scmscm_set_program_argumentsscm_program_argumentsscm_add_featurescm_program_arguments_fluidSCM_FEATURE_H/* SCM_FEATURE_H *//* Copyright (C) 1995, 1996, 1999, 2000, 2001, 2006, 2007, 2008,
 *   2011 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */argc/usr/include/guile/2.0/libguile/filesys.hscm_init_filesysscm_i_relativize_pathscm_sendfilescm_canonicalize_pathscm_basenamescm_dirnamescm_copy_filescm_lstatscm_readlinkscm_symlinkscm_fsyncscm_fcntlscm_selectscm_getcwdscm_chdirscm_closedirscm_rewinddirscm_readdirscm_opendirscm_directory_stream_pscm_rmdirscm_mkdirscm_delete_filescm_renamescm_linkscm_statscm_close_fdesscm_closescm_openscm_open_fdesscm_umaskscm_chmodscm_chownscm_tc16_dirSCM_DIR_OPEN_P(x)(SCM_SMOB_FLAGS (x) & SCM_DIR_FLAG_OPEN)SCM_DIRP(x)(!SCM_IMP (x) && (SCM_TYP16 (x) == scm_tc16_dir))SCM_DIR_FLAG_OPENSCM_FILESYS_H/* SCM_FILESYS_H *//* Copyright (C) 1995, 1997, 1998, 1999, 2000, 2001, 2006, 2008, 2009,
 *   2010, 2013 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */pathin_pathoutinfilenamesuffixoldfilenewfileoldpathnewpathobjectcmdvaluereadswritesexceptssecsmsecsdirnamemodeoldnamenewnameexception_on_errorfd_or_portgroup/usr/include/guile/2.0/libguile/finalizers.hscm_init_finalizersscm_run_finalizersscm_set_automatic_finalization_enabledscm_i_add_resuscitatorscm_i_add_finalizerscm_i_set_finalizerscm_t_finalizer_procSCM_FINALIZERS_H/* SCM_FINALIZERS_H *//* Copyright (C) 2012, 2014 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */enabled_p/usr/include/guile/2.0/libguile/vectors.hscm_init_vectorsscm_i_make_weak_vector_from_listscm_i_make_weak_vectorscm_i_vector_equal_pscm_vector_writable_elementsscm_vector_elementsscm_c_vector_set_xscm_c_vector_refscm_c_vector_lengthscm_c_make_vectorscm_is_simple_vectorscm_is_vectorscm_vector_copyscm_vector_move_right_xscm_vector_move_left_xscm_vector_fill_xscm_vector_to_listscm_make_vectorscm_vector_set_xscm_vector_refscm_vectorscm_vector_lengthscm_vector_pSCM_I_SET_WVECT_EXTRA(x,t)(SCM_SET_CELL_WORD_1 ((x),(t)))SCM_I_WVECT_EXTRA(x)(SCM_CELL_WORD_1 (x))SCM_I_WVECT_GC_WVELTSSCM_I_VECTOR_WELTSSCM_I_WVECT_VELTSSCM_I_VECTOR_ELTSSCM_I_WVECT_LENGTHSCM_I_VECTOR_LENGTHSCM_I_WVECTP(x)(!SCM_IMP (x) && SCM_TYP7 (x) == scm_tc7_wvect)SCM_I_VECTOR_LENGTH(x)(((size_t) SCM_CELL_WORD_0 (x)) >> 8)SCM_I_VECTOR_WELTS(x)(SCM_CELL_OBJECT_LOC (x, SCM_I_VECTOR_HEADER_SIZE))SCM_I_VECTOR_ELTS(x)((const SCM *) SCM_I_VECTOR_WELTS (x))SCM_I_IS_NONWEAK_VECTOR(x)(!SCM_IMP(x) && (SCM_TYP7(x)==scm_tc7_vector))SCM_I_IS_VECTOR(x)(!SCM_IMP(x) && (SCM_TYP7S(x)==scm_tc7_vector))SCM_I_VECTOR_HEADER_SIZE2USCM_SIMPLE_VECTOR_SET(x,idx,val)((SCM_I_VECTOR_WELTS(x))[idx]=(val))SCM_SIMPLE_VECTOR_REF(x,idx)((SCM_I_VECTOR_ELTS(x))[idx])SCM_SIMPLE_VECTOR_LENGTH(x)SCM_VECTORS_H/* SCM_VECTORS_H *//* Weak vectors share implementation details with ordinary vectors,
   but no one else should.  *//* Vectors have a 2-word header: 1 for the type tag, and 1 for the weak
   vector extra data (see below.)  *//* Internals *//* Fast, non-checking accessors for simple vectors.
 *//* Copyright (C) 1995,1996,1998,2000,2001,2002,2004,2005, 2006, 2008, 2009 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */sizestart1end1start2fill_xl/usr/include/guile/2.0/libguile/fluids.h"libguile/vectors.h"scm_init_fluidsscm_i_with_fluids_printscm_i_dynamic_state_printscm_i_fluid_printscm_i_make_initial_dynamic_statescm_with_dynamic_statescm_c_with_dynamic_statescm_dynwind_current_dynamic_statescm_set_current_dynamic_statescm_current_dynamic_statescm_is_dynamic_statescm_dynamic_state_pscm_make_dynamic_statescm_dynwind_fluidscm_with_fluidscm_with_fluidsscm_c_with_fluidscm_c_with_fluidsscm_i_swap_with_fluidsscm_i_make_with_fluidsscm_fluid_bound_pscm_fluid_unset_xscm_fluid_set_xscm_fluid_refscm_fluid_pscm_is_fluidscm_make_unbound_fluidscm_make_fluid_with_defaultscm_make_fluidSCM_FLUID_P(x)(!SCM_IMP (x) && SCM_TYP7 (x) == scm_tc7_fluid)SCM_WITH_FLUIDS_SET_NTH_VAL(x,n,v)(SCM_SET_CELL_OBJECT ((x), 2 + (n)*2, (v)))SCM_WITH_FLUIDS_NTH_VAL(x,n)(SCM_CELL_OBJECT ((x), 2 + (n)*2))SCM_WITH_FLUIDS_NTH_FLUID(x,n)(SCM_CELL_OBJECT ((x), 1 + (n)*2))SCM_WITH_FLUIDS_LEN(x)(SCM_CELL_WORD ((x), 0) >> 8)SCM_WITH_FLUIDS_P(x)(!SCM_IMP (x) && SCM_TYP7(x) == scm_tc7_with_fluids)SCM_FLUIDS_H/* SCM_FLUIDS_H *//* Fluids.

   Fluids are objects of a certain type that can hold one SCM value per
   dynamic state. That is, modifications to this value are only visible
   to code that executes with the same dynamic state as the modifying
   code. When a new dynamic state is constructed, it inherits the
   values from its parent. Because each thread executes with its own
   dynamic state, you can use fluids for thread local storage.

   Each fluid is identified by a small integer. This integer is used to
   index a vector that holds the values of all fluids. A dynamic state
   consists of this vector, wrapped in an object so that the vector can
   grow.
 *//* These "with-fluids" objects live on the dynamic stack, and record previous
   values of fluids. Guile uses shallow binding, so the current fluid values are
   always in the same place for a given thread, in the dynamic-state vector.
 *//* Copyright (C) 1996,2000,2001, 2006, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */stateparentfluidfluidscdatawith_fluidsfldflt/usr/include/guile/2.0/libguile/foreign.hscm_register_foreignscm_i_foreign_callscm_procedure_to_pointerscm_pointer_to_procedure_with_errnoscm_pointer_to_procedurescm_pointer_to_stringscm_string_to_pointerscm_dereference_pointerscm_i_pointer_printscm_make_pointerscm_pointer_pscm_bytevector_to_pointerscm_set_pointer_finalizer_xscm_pointer_to_bytevectorscm_pointer_addressscm_sizeofscm_alignofscm_from_pointerscm_to_pointerscm_t_pointer_finalizerscm_t_foreign_typeSCM_FOREIGN_TYPE_VOIDSCM_FOREIGN_TYPE_FLOATSCM_FOREIGN_TYPE_DOUBLESCM_FOREIGN_TYPE_UINT8SCM_FOREIGN_TYPE_INT8SCM_FOREIGN_TYPE_UINT16SCM_FOREIGN_TYPE_INT16SCM_FOREIGN_TYPE_UINT32SCM_FOREIGN_TYPE_INT32SCM_FOREIGN_TYPE_UINT64SCM_FOREIGN_TYPE_INT64SCM_FOREIGN_TYPE_LASTSCM_POINTER_VALUE(x)((void *) SCM_CELL_WORD_1 (x))SCM_VALIDATE_POINTER(pos,x)SCM_MAKE_VALIDATE (pos, x, POINTER_P)SCM_POINTER_P(x)(!SCM_IMP (x) && SCM_TYP7(x) == scm_tc7_pointer)SCM_FOREIGN_H/* SCM_FOREIGN_H *//* The goal is to make it so that calling a foreign function doesn't cause any
   heap allocation. That means we need native Scheme formats for all kinds of
   arguments.

   For "value" types like s64 or f32, we just use native Scheme value types.
   (Note that in both these cases, allocation is possible / likely, as the
   value might need to be boxed, but perhaps we won't worry about that. Hmm.)

   For everything else, we use foreign pointers. This includes arrays, pointer
   arguments and return vals, struct args and return vals, and out and in/out
   arguments.
 *//* Foreign functions *//* A "foreign pointer" is a wrapped C pointer.  It is represented by a
   cell whose second word is a pointer.  The first word has the
   `scm_tc7_pointer' type code.

   The basic idea is that we can help the programmer to avoid cutting herself,
   but we won't take away her knives.  *//* Copyright (C) 2010, 2011, 2012, 2016  Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */foreignreturn_typefunc_ptrarg_typespointerencodingstringaddressfinalizerbv/usr/include/guile/2.0/libguile/strings.hscm_init_stringsscm_i_deprecated_string_lengthscm_i_deprecated_string_charsscm_i_deprecated_stringpscm_sys_symbol_dumpscm_sys_string_dumpscm_i_get_substring_specscm_i_allocate_string_pointersscm_decoding_errorscm_encoding_errorscm_i_symbol_refscm_i_symbol_substringscm_i_try_narrow_stringscm_i_is_narrow_symbolscm_i_symbol_lengthconst scm_t_wcharconst scm_t_wchar *signed int *scm_i_symbol_wide_charsscm_i_symbol_charsscm_i_c_make_symbolscm_i_make_symbolscm_i_string_set_xscm_i_string_strcmpscm_i_string_contains_charscm_i_string_refscm_i_is_narrow_stringscm_i_string_stop_writingscm_i_string_start_writingscm_i_string_datascm_i_string_wide_charsscm_i_string_writable_charsscm_i_string_charsscm_i_string_lengthscm_i_substring_copyscm_i_substring_sharedscm_i_substring_read_onlyscm_i_substringscm_i_set_string_read_only_xscm_i_make_wide_stringscm_t_wchar *scm_t_wchar **signed int **scm_i_make_stringscm_makfromstrsscm_string_normalize_nfkcscm_string_normalize_nfcscm_string_normalize_nfkdscm_string_normalize_nfdscm_to_locale_stringbufscm_to_stringnscm_from_utf32_stringnscm_from_utf32_stringscm_to_utf32_stringnscm_to_utf32_stringscm_from_utf8_stringnscm_from_utf8_stringscm_to_utf8_stringnscm_to_utf8_stringscm_to_latin1_stringnscm_to_latin1_stringscm_from_latin1_stringnscm_from_latin1_stringscm_to_locale_stringnscm_to_locale_stringscm_take_locale_stringnscm_take_locale_stringscm_from_locale_stringnscm_from_locale_stringscm_c_substring_copyscm_c_substring_sharedscm_c_substring_read_onlyscm_c_substringscm_c_string_set_xscm_c_string_refscm_c_symbol_lengthscm_c_string_utf8_lengthscm_c_string_lengthscm_c_make_stringscm_from_stringnscm_string_appendscm_substring_copyscm_substring_sharedscm_substring_read_onlyscm_substringscm_string_set_xscm_string_refscm_string_bytes_per_charscm_string_utf8_lengthscm_string_lengthscm_make_stringscm_stringscm_string_pscm_t_string_failed_conversion_handlerSCM_FAILED_CONVERSION_ERRORSCM_FAILED_CONVERSION_QUESTION_MARKSCM_FAILED_CONVERSION_ESCAPE_SEQUENCEscm_nullstrSCM_STRING_UCHARS(str)((unsigned char *)SCM_STRING_CHARS (str))SCM_STRING_LENGTH(x)scm_i_deprecated_string_length(x)SCM_STRING_CHARS(x)scm_i_deprecated_string_chars(x)SCM_STRINGP(x)scm_i_deprecated_stringp(x)SCM_I_STRINGBUF_F_WIDE0x400SCM_I_STRINGBUF_F_SHARED0x100scm_tc7_ro_string(scm_tc7_string + 0x200)SCM_STRINGS_HSCM_STRING_LENGTH_HISTOGRAM/* SCM_STRINGS_H *//* deprecated stuff *//* Debugging functions *//* internal utility functions. *//* internal functions related to symbols. *//* internal accessor functions.  Arguments must be valid. *//* Flags for shared and wide strings.  *//* Type tag for read-only strings.  *//* internal constants *//* Use locale encoding for user input, user output, or interacting with
   the C library.  Use latin1 for ASCII, and for literals in source
   code.  Use utf8 for interaction with modern libraries which deal in
   UTF-8.  Otherwise use scm_to_stringn or scm_from_stringn with a
   specific encoding. *//* A type indicating what strategy to take when string locale
   conversion is unsuccessful.  *//* String representation.

   A string is a piece of a stringbuf.  A stringbuf can be used by
   more than one string.  When a string is written to and the
   stringbuf of that string is used by more than one string, a new
   stringbuf is created.  That is, strings are copy-on-write.  This
   behavior can be used to make the substring operation quite
   efficient.

   The implementation is tuned so that mutating a string is costly,
   but just reading it is cheap and lock-free.

   There are also mutation-sharing strings.  They refer to a part of
   an ordinary string.  Writing to a mutation-sharing string just
   writes to the ordinary string.


   Internal, low level interface to the character arrays

   - Use scm_is_narrow_string to determine is the string is narrow or
     wide.

   - Use scm_i_string_chars or scm_i_string_wide_chars to get a
     pointer to the byte or scm_t_wchar array of a string for reading.
     Use scm_i_string_length to get the number of characters in that
     array.  The array is not null-terminated.

   - The array is valid as long as the corresponding SCM object is
     protected but only until the next SCM_TICK.  During such a 'safe
     point', strings might change their representation.

   - Use scm_i_string_start_writing to get a version of the string
     ready for reading and writing.  This is a potentially costly
     operation since it implements the copy-on-write behavior.  When
     done with the writing, call scm_i_string_stop_writing.  You must
     do this before the next SCM_TICK.  (This means, before calling
     almost any other scm_ function and you can't allow throws, of
     course.)

   - New strings can be created with scm_i_make_string or
     scm_i_make_wide_string.  This gives access to a writable pointer
     that remains valid as long as nobody else makes a copy-on-write
     substring of the string.  Do not call scm_i_string_stop_writing
     for this pointer.

   - Alternately, scm_i_string_ref and scm_i_string_set_x can be used
     to read and write strings without worrying about whether the
     string is narrow or wide.  scm_i_string_set_x still needs to be
     bracketed by scm_i_string_start_writing and
     scm_i_string_stop_writing.

   Legacy interface

   - SCM_STRINGP is just scm_is_string.

   - SCM_STRING_CHARS uses scm_i_string_writable_chars and immediately
     calls scm_i_stop_writing, hoping for the best.  SCM_STRING_LENGTH
     is the same as scm_i_string_length.  SCM_STRING_CHARS will throw
     an error for strings that are not null-terminated.  There is
     no wide version of this interface.
*//* Copyright (C) 1995-1998, 2000, 2001, 2004-2006, 2008-2011,
 *   2015 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */cstartcendhashpropssstrstart_xcstrdatapread_only_pbufmax_lenchrs/usr/include/guile/2.0/libguile/ports.h"libguile/strings.h"<unistd.h>scm_i_dynwind_current_load_portscm_i_mode_bitsscm_t_port *scm_add_to_port_tablescm_init_portsscm_sys_make_void_portscm_void_portscm_print_port_modescm_port_printscm_set_port_conversion_strategy_xscm_port_conversion_strategyscm_slow_peek_byte_or_eofscm_slow_get_byte_or_eofscm_i_set_default_port_conversion_handlerscm_i_default_port_conversion_handlerscm_set_port_encoding_xscm_port_encodingscm_i_set_port_encoding_xscm_i_set_default_port_encodingscm_i_default_port_encodingscm_i_set_port_property_xscm_i_port_propertyscm_set_port_filename_xscm_port_filenamescm_set_port_column_xscm_port_columnscm_set_port_line_xscm_port_linescm_truncate_filescm_seekscm_unread_stringscm_unread_charscm_peek_charscm_ungetsscm_ungetcscm_unget_bytescm_unget_bytesscm_fill_inputscm_end_inputscm_flushscm_lfwrite_substrscm_lfwritescm_c_writescm_c_readscm_getcscm_read_charscm_flush_all_portsscm_force_outputscm_eof_object_pscm_port_closed_pscm_port_pscm_output_port_pscm_input_port_pscm_c_port_for_eachscm_port_for_eachscm_close_portscm_close_output_portscm_close_input_portscm_port_modescm_mode_bitsscm_set_port_revealed_xscm_port_revealedscm_revealed_countscm_port_non_bufferscm_pt_memberscm_pt_sizescm_grow_port_cbufscm_new_port_table_entryscm_dynwind_current_error_portscm_dynwind_current_output_portscm_dynwind_current_input_portscm_set_current_warning_portscm_set_current_error_portscm_set_current_output_portscm_set_current_input_portscm_current_load_portscm_current_warning_portscm_current_error_portscm_current_output_portscm_current_input_portscm_drain_inputscm_take_from_input_buffersscm_char_ready_pscm_set_port_input_waitingscm_set_port_truncatescm_set_port_seekscm_set_port_end_inputscm_set_port_flushscm_set_port_closescm_set_port_equalpscm_set_port_printscm_set_port_freescm_set_port_markscm_make_port_typescm_markstreamscm_t_ptob_descriptorscm_t_portscm_t_port_rw_activeSCM_PORT_NEITHERSCM_PORT_READSCM_PORT_WRITEtruncateseekinput_waitingfill_inputend_inputflushwritecloseequalpprintfreemarkoutput_cdinput_cdputback_buf_sizeputback_bufrw_activerw_randomshortbufwrite_buf_sizewrite_endwrite_poswrite_bufsaved_read_buf_sizesaved_read_endsaved_read_possaved_read_bufread_buf_sizeread_endread_posread_bufilseq_handlercolumn_numberline_numberfile_namestreamscm_numptobscm_t_ptob_descriptor *scm_ptobsscm_i_port_weak_hashscm_i_port_table_mutexSCM_PTOBNAME(ptobnum)scm_ptobs[ptobnum].nameSCM_PTOBNUM(x)(SCM_TC2PTOBNUM (SCM_CELL_TYPE (x)))SCM_TC2PTOBNUM(x)(0x0ff & ((x) >> 8))SCM_I_MAX_PORT_TYPE_COUNT256SCM_TABCOL(port)do {SCM_COL (port) += 8 - SCM_COL (port) % 8;} while (0)SCM_DECCOL(port)do {if (SCM_COL (port) > 0) SCM_COL (port) -= 1;} while (0)SCM_INCCOL(port)do {SCM_COL (port) += 1;} while (0)SCM_ZEROCOL(port)do {SCM_COL (port) = 0;} while (0)SCM_INCLINE(port)do {SCM_LINUM (port) += 1; SCM_COL (port) = 0;} while (0)SCM_SETREVEALED(x,s)(SCM_PTAB_ENTRY(x)->revealed = (s))SCM_REVEALED(x)(SCM_PTAB_ENTRY(x)->revealed)SCM_COL(x)(SCM_PTAB_ENTRY(x)->column_number)SCM_LINUM(x)(SCM_PTAB_ENTRY(x)->line_number)SCM_SET_FILENAME(x,n)(SCM_PTAB_ENTRY(x)->file_name = (n))SCM_FILENAME(x)(SCM_PTAB_ENTRY(x)->file_name)SCM_SETSTREAM(x,s)(SCM_PTAB_ENTRY(x)->stream = (scm_t_bits) (s))SCM_STREAM(x)(SCM_PTAB_ENTRY(x)->stream)SCM_SETPTAB_ENTRY(x,ent)(SCM_SET_CELL_WORD_1 ((x), (scm_t_bits) (ent)))SCM_PTAB_ENTRY(x)((scm_t_port *) SCM_CELL_WORD_1 (x))SCM_CLR_PORT_OPEN_FLAG(p)SCM_SET_CELL_WORD_0 ((p), SCM_CELL_WORD_0 (p) & ~SCM_OPN)SCM_CLOSEDP(x)(!SCM_OPENP(x))SCM_OPENP(x)(!SCM_IMP(x) && (SCM_OPN & SCM_CELL_WORD_0 (x)))SCM_OUTPUT_PORT_P(x)(!SCM_IMP(x) && (((0x7f | SCM_WRTNG) & SCM_CELL_WORD_0(x))==(scm_tc7_port | SCM_WRTNG)))SCM_INPUT_PORT_P(x)(!SCM_IMP(x) && (((0x7f | SCM_RDNG) & SCM_CELL_WORD_0(x)) == (scm_tc7_port | SCM_RDNG)))SCM_OPOUTPORTP(x)(!SCM_IMP(x) && (((0x7f | SCM_OPN | SCM_WRTNG) & SCM_CELL_WORD_0(x))==(scm_tc7_port | SCM_OPN | SCM_WRTNG)))SCM_OPINPORTP(x)(!SCM_IMP(x) && (((0x7f | SCM_OPN | SCM_RDNG) & SCM_CELL_WORD_0(x))==(scm_tc7_port | SCM_OPN | SCM_RDNG)))SCM_OPPORTP(x)(!SCM_IMP(x) && (((0x7f | SCM_OPN) & SCM_CELL_WORD_0(x))==(scm_tc7_port | SCM_OPN)))SCM_PORTP(x)(!SCM_IMP (x) && (SCM_TYP7 (x) == scm_tc7_port))SCM_BUFLINE(64L<<16)SCM_BUF0(8L<<16)SCM_WRTNG(4L<<16)SCM_RDNG(2L<<16)SCM_OPN(1L<<16)SCM_EOF_OBJECT_P(x)(scm_is_eq ((x), SCM_EOF_VAL))SCM_READ_BUFFER_EMPTY_P(c_port)(c_port->read_pos >= c_port->read_end)SCM_INITIAL_PUTBACK_BUF_SIZESCM_PORTS_HSCM_ENABLE_DEPRECATED==1/* SCM_PORTS_H *//* internal *//* GUILE_DEBUG *//* Use HANDLER as the default conversion strategy for future ports.  *//* Hey you!  Yes you, reading the header file!  We're going to deprecate
   scm_ptobs in 2.2, so please don't write any new code that uses it.
   Thanks.  *//* SCM_PTOBNAME can be 0 if name is missing *//* port-type description.  *//* Maximum number of port types.  *//* Is it line-buffered? *//* Is it unbuffered? *//* Is it writable? *//* Is it a readable port? *//* Is the port open? *//* PORT FLAGS
 * A set of flags characterizes a port.
 * Note that we reserve the bits 1 << 24 and above for use by the
 * routines in the port's scm_ptobfuns structure.
 *//* XXX actually unused *//* XXX actually a pointer to scm_t_port_internal *//* IMPORTANT: 'input_cd' and 'output_cd' used to be pointers to the
     input and output iconv descriptors, but those have been moved to
     the internal-only port structure defined in ports-internal.h.

     Given that we must preserve ABI compatibility in 2.0, we cannot
     safely change this public structure without running afoul of C
     strict aliasing rules.  We cannot even change the member names.

     To work around this, in this public structure, 'input_cd' has been
     repurposed to be a pointer to the internal port structure (see
     ports-internal.h), and 'output_cd' is now unused.

     This will be cleaned up in 2.2.  *//* allocated size of putback_buf.  *//* a buffer for un-read chars and strings.  *//* for random access ports,
                                     indicates which of the buffers
                                     is currently in use.  can be
                                     SCM_PORT_WRITE, SCM_PORT_READ,
                                     or SCM_PORT_NEITHER.  *//* true if the port is random access.
				   implies that the buffers must be
				   flushed before switching between
				   reading and writing, seeking, etc.  *//* buffer for "unbuffered" streams.  *//* size of the buffer.  *//* pointer to end of buffer + 1.  *//* pointer to last buffered char + 1.  *//* buffer start.  *//* write requests are saved into this buffer at write_pos until it
     reaches write_buf + write_buf_size, then the ptob flush is
     called.  *//* when chars are put back into the buffer, e.g., using peek-char or
     unread-string, the read-buffer pointers are switched to cbuf.
     the original pointers are saved here and restored when the put-back
     chars have been consumed.  *//* the next unread char.  *//* this buffer is filled from read_buf to read_end using the ptob 
     buffer_fill.  then input requests are taken from read_pos until
     it reaches read_end.  *//* port buffers.  the buffer(s) are set up for all ports.  
     in the case of string ports, the buffer is the string itself.
     in the case of unbuffered file ports, the buffer is a
     single char: shortbuf.  *//* Character encoding support  *//* debugging support.  *//* data for the underlying port implementation as a raw C value. *//* 0 not revealed, > 1 revealed.
				 * Revealed ports do not get GC'd.
				 *//* Link back to the port object.  *//* C representation of a Scheme port.  *//* values for the rw_active flag.  *//* Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2006,
 *   2008, 2009, 2010, 2011, 2012, 2013 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */modesmode_strbehaviorlinewhencecobjbufferrcountptmemberrequesteddestread_lentc/usr/include/guile/2.0/libguile/fports.h"libguile/ports.h"scm_i_fdes_to_portscm_init_fportsscm_init_fports_keywordsscm_file_port_pscm_fdes_to_portscm_open_filescm_open_file_with_encodingscm_i_mode_to_open_flagsscm_evict_portsscm_setvbufscm_setbuf0scm_t_fportfdesscm_tc16_fportSCM_FDES_RANDOM_P(fdes)((lseek (fdes, 0, SEEK_CUR) == -1) ? 0 : 1)SCM_OPOUTFPORTP(x)(SCM_OPFPORTP (x) && (SCM_CELL_WORD_0 (x) & SCM_WRTNG))SCM_OPINFPORTP(x)(SCM_OPFPORTP (x) && (SCM_CELL_WORD_0 (x) & SCM_RDNG))SCM_OPFPORTP(x)(SCM_FPORTP (x) && (SCM_CELL_WORD_0 (x) & SCM_OPN))SCM_FPORTP(x)(!SCM_IMP (x) && (SCM_TYP16 (x) == scm_tc16_fport))SCM_FPORT_FDES(x)(SCM_FSTREAM (x)->fdes)SCM_FSTREAM(x)((scm_t_fport *) SCM_STREAM (x))SCM_FPORTS_H/* SCM_FPORTS_H *//* internal functions *//* test whether fdes supports random access.  *//* file descriptor.  *//* struct allocated for each buffered FPORT.  *//* Copyright (C) 1995,1996,1997,1998,1999,2000,2001, 2006, 2008, 2009 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */mode_bitsguess_encodingis_binaryFUNC_NAME/usr/include/guile/2.0/libguile/hooks.hscm_init_hooksscm_hook_to_listscm_c_run_hooknscm_c_run_hookscm_run_hookscm_reset_hook_xscm_remove_hook_xscm_add_hook_xscm_hook_empty_pscm_hook_pscm_make_hookscm_c_hook_runscm_t_c_hook *scm_c_hook_removescm_c_hook_addscm_c_hook_initscm_t_c_hookscm_t_c_hook_entryscm_t_c_hook_functionscm_t_c_hook_typeSCM_C_HOOK_NORMALSCM_C_HOOK_ORSCM_C_HOOK_ANDscm_t_c_hook_entry *nextscm_tc16_hookSCM_SET_HOOK_PROCEDURES(hook,procs)SCM_SET_SMOB_OBJECT ((hook), (procs))SCM_HOOK_PROCEDURES(hook)SCM_SMOB_OBJECT (hook)SCM_HOOK_ARITY(hook)SCM_SMOB_FLAGS (hook)SCM_HOOKP(x)SCM_SMOB_PREDICATE (scm_tc16_hook, x)SCM_HOOKS_H/* SCM_HOOKS_H *//*
 * Scheme level hooks
 *//*
 * The interface is designed for and- and or-type hooks which
 * both may want to indicate success/failure and return a result.
 *//*
 * C level hooks
 *//* Copyright (C) 1995,1996,1999,2000,2001, 2006, 2008, 2009 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */hookappendpn_argsfn_datahook_data/usr/include/guile/2.0/libguile/gc.h"libguile/hooks.h"scm_must_freescm_done_freescm_done_mallocscm_must_strndupscm_must_strdupscm_must_reallocscm_must_mallocscm_deprecated_newcell2scm_deprecated_newcellscm_init_gcscm_init_gc_protect_objectscm_storage_prehistoryscm_gc_unregister_rootsscm_gc_register_rootsscm_gc_unregister_rootscm_gc_register_rootscm_gc_unprotect_objectscm_gc_protect_objectscm_permanent_objectscm_return_first_intscm_return_firstscm_remember_upto_herescm_remember_upto_here_2scm_remember_upto_here_1scm_wordsSCM_GC_MALLOC (sizeof (scm_t_bits) * n_words)scm_gc_malloc (sizeof (scm_t_bits) * n_words, ((void *)0))sizeof (scm_t_bits) * n_words(scm_t_bits) (scm_gc_malloc (sizeof (scm_t_bits) * n_words, ((void *)0)))car(z)(0)SCM_PACK (car)((SCM) (car))volatile SCMvolatile SCM *scm_t_cell *scm_double_cellSCM_GC_MALLOC (2 * sizeof (scm_t_cell))scm_gc_malloc (2 * sizeof (scm_t_cell), ((void *)0))2 * sizeof (scm_t_cell)(scm_t_bits) (scm_gc_malloc (2 * sizeof (scm_t_cell), ((void *)0)))32cbrSCM_PACK (cbr)((SCM) (cbr))ccrSCM_PACK (ccr)((SCM) (ccr))cdrSCM_PACK (cdr)((SCM) (cdr))scm_cellSCM_GC_MALLOC (sizeof (scm_t_cell))scm_gc_malloc (sizeof (scm_t_cell), ((void *)0))sizeof (scm_t_cell)(scm_t_bits) (scm_gc_malloc (sizeof (scm_t_cell), ((void *)0)))(cell)scm_gc_strndupscm_gc_strdupscm_gc_freescm_gc_reallocscm_gc_mallocscm_gc_callocscm_gc_malloc_pointerlessscm_gc_unregister_collectable_memoryscm_gc_register_collectable_memoryscm_strndupscm_strdupscm_reallocscm_callocscm_mallocscm_gc_register_allocationscm_gc_sweepscm_gc_markscm_i_gcscm_gcscm_gc_statsscm_gc_dumpscm_gc_disablescm_gc_enablescm_object_addressscm_set_debug_cell_accesses_xscm_t_cellword_1word_0scm_protectsscm_after_gc_c_hookscm_after_sweep_c_hookscm_before_sweep_c_hookscm_before_mark_c_hookscm_before_gc_c_hookscm_after_gc_hookscm_gc_ports_collectedscm_default_max_segment_sizescm_default_min_yield_2scm_default_init_heap_size_2scm_default_min_yield_1scm_default_init_heap_size_1scm_i_sweep_mutexscm_i_gc_admin_mutexSCM_NEWCELL2(_into)do { _into = scm_deprecated_newcell2 (); } while (0)SCM_NEWCELL(_into)do { _into = scm_deprecated_newcell (); } while (0)scm_remember_upto_here_2(x,y)do { scm_remember_upto_here_1 (x); scm_remember_upto_here_1 (y); } while (0)scm_remember_upto_here_1(x)do { __asm__ __volatile__ ("" : : "g" (x)); } while (0)SCM_GC_MALLOC_POINTERLESS(size)scm_gc_malloc_pointerless (size, NULL)SCM_GC_MALLOC(size)scm_gc_malloc (size, NULL)scm_gc_typed_calloc(t)((t *) scm_gc_calloc (sizeof (t), #t))scm_gc_running_pSCM_SET_CELL_TYPE(x,t)SCM_SET_CELL_WORD_0 ((x), (t))SCM_CELL_TYPE(x)SCM_CELL_WORD_0 (x)SCM_CDRLOC(x)(SCM_CELL_OBJECT_LOC ((x), 1))SCM_CARLOC(x)(SCM_CELL_OBJECT_LOC ((x), 0))SCM_CELL_OBJECT_LOC(x,n)(SCM_VALIDATE_CELL((x), &SCM_GC_CELL_OBJECT ((x), (n))))SCM_SET_CELL_OBJECT_3(x,v)SCM_SET_CELL_OBJECT ((x), 3, (v))SCM_SET_CELL_OBJECT_2(x,v)SCM_SET_CELL_OBJECT ((x), 2, (v))SCM_SET_CELL_OBJECT_1(x,v)SCM_SET_CELL_OBJECT ((x), 1, (v))SCM_SET_CELL_OBJECT_0(x,v)SCM_SET_CELL_OBJECT ((x), 0, (v))SCM_SET_CELL_OBJECT(x,n,v)SCM_VALIDATE_CELL ((x), SCM_GC_SET_CELL_OBJECT ((x), (n), (v)))SCM_SET_CELL_WORD_3(x,v)SCM_SET_CELL_WORD ((x), 3, (v))SCM_SET_CELL_WORD_2(x,v)SCM_SET_CELL_WORD ((x), 2, (v))SCM_SET_CELL_WORD_1(x,v)SCM_SET_CELL_WORD ((x), 1, (v))SCM_SET_CELL_WORD_0(x,v)SCM_SET_CELL_WORD ((x), 0, (v))SCM_SET_CELL_WORD(x,n,v)SCM_VALIDATE_CELL ((x), SCM_GC_SET_CELL_WORD ((x), (n), (v)))SCM_CELL_OBJECT_3(x)SCM_CELL_OBJECT ((x), 3)SCM_CELL_OBJECT_2(x)SCM_CELL_OBJECT ((x), 2)SCM_CELL_OBJECT_1(x)SCM_CELL_OBJECT ((x), 1)SCM_CELL_OBJECT_0(x)SCM_CELL_OBJECT ((x), 0)SCM_CELL_OBJECT(x,n)SCM_VALIDATE_CELL ((x), SCM_GC_CELL_OBJECT ((x), (n)))SCM_CELL_WORD_3(x)SCM_CELL_WORD ((x), 3)SCM_CELL_WORD_2(x)SCM_CELL_WORD ((x), 2)SCM_CELL_WORD_1(x)SCM_CELL_WORD ((x), 1)SCM_CELL_WORD_0(x)SCM_CELL_WORD ((x), 0)SCM_CELL_WORD(x,n)SCM_VALIDATE_CELL ((x), SCM_GC_CELL_WORD ((x), (n)))SCM_VALIDATE_CELL(cell,expr)(expr)SCM_GC_CELL_TYPE(x)(SCM_GC_CELL_OBJECT ((x), 0))SCM_GC_SET_CELL_WORD(x,n,v)(SCM_GC_SET_CELL_OBJECT ((x), (n), SCM_PACK (v)))SCM_GC_SET_CELL_OBJECT(x,n,v)((((SCM *)SCM2PTR (x)) [n]) = (v))SCM_GC_CELL_WORD(x,n)(SCM_UNPACK (SCM_GC_CELL_OBJECT ((x), (n))))SCM_GC_CELL_OBJECT(x,n)(((SCM *)SCM2PTR (x)) [n])PTR2SCM(x)(SCM_PACK ((scm_t_bits) (x)))SCM2PTR(x)((scm_t_cell *) (SCM_UNPACK (x)))SCM_GC_H_UNICOS(SCM_DEBUG_CELL_ACCESSES == 1)/* SCM_GC_H *//* In GCC we can force a reference to an SCM by making it an input to an
   empty asm.  This avoids the code size and slowdown of an actual function
   call.  Unfortunately there doesn't seem to be any way to do the varargs
   scm_remember_upto_here like this.

   __volatile__ ensures nothing will be moved across the asm, and it won't
   be optimized away (or only if proved unreachable).  Constraint "g" can be
   used on all processors and allows any memory or general register (or
   immediate) operand.  The actual asm syntax doesn't matter, we don't want
   to use it, just ensure the operand is still alive.  See "Extended Asm" in
   the GCC manual for more.  *//* SCM_CAN_INLINE || defined SCM_INLINE_C_IMPLEMENTING_INLINES *//* portable version, just in case any other compiler does the same
     thing.  *//* When this function is inlined, it's possible that the last
     SCM_GC_SET_CELL_WORD above will be adjacent to a following
     initialization of z.  E.g., it occurred in scm_make_real.  GCC
     from around version 3 (e.g., certainly 3.2) began taking
     advantage of strict C aliasing rules which say that it's OK to
     interchange the initialization above and the one below when the
     pointer types appear to differ sufficiently.  We don't want that,
     of course.  GCC allows this behaviour to be disabled with the
     -fno-strict-aliasing option, but would also need to be supplied
     by Guile users.  Instead, the following statements prevent the
     reordering.
   *//* FIXME: is the following concern even relevant with BDW-GC? *//* Initialize the type slot last so that the cell is ignored by the
     GC until it is completely initialized.  This is only relevant
     when the GC can actually run during this code, which it can't
     since the GC only runs when all other threads are stopped.
  *//* Initialize the type slot last so that the cell is ignored by the GC
     until it is completely initialized.  This is only relevant when the GC
     can actually run during this code, which it can't since the GC only runs
     when all other threads are stopped.  *//* Set this to != 0 if every cell that is accessed shall be checked:
 *//* Except for the garbage collector, no part of guile should ever run over a
 * free cell.  Thus, if guile is compiled in debug mode the SCM_CELL_* and
 * SCM_SET_CELL_* macros below report an error if they are applied to a free
 * cell.  Some other plausibility checks are also performed.  However, if
 * guile is not compiled in debug mode, there won't be any time penalty at all
 * when using these macros.  *//* Low level cell data accessing macros.  These macros should only be used
 * from within code related to garbage collection issues, since they will
 * never check the cells they are applied to - not even if guile is compiled
 * in debug mode.  In particular these macros will even work for free cells,
 * which should never be encountered by user code.  *//* def _UNICOS *//* Cray machines have pointers that are incremented once for each
 * word, rather than each byte, the 3 most significant bits encode the
 * byte within the word.  The following macros deal with this by
 * storing the native Cray pointers like the ones that looks like scm
 * expects.  This is done for any pointers that point to a cell,
 * pointers to scm_vector elts, functions, &c are not munged.
 *//* Copyright (C) 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006,
 *   2007, 2008, 2009, 2010, 2011, 2013 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */whereoleneltobj1obj2old_sizenew_sizeflag/usr/include/guile/2.0/libguile/gdbint.hscm_init_gdbintscm_print_carefully_pSCM_GDBINT_H/* SCM_GDBINT_H *//* Copyright (C) 1996,2000, 2006, 2008 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/generalized-arrays.hscm_init_generalized_arraysscm_array_to_listscm_array_set_xscm_array_refscm_c_array_set_2_xscm_c_array_set_1_xscm_c_array_ref_2scm_c_array_ref_1scm_array_in_bounds_pscm_array_typescm_array_dimensionsscm_array_lengthscm_c_array_lengthscm_array_rankscm_c_array_rankscm_typed_array_pscm_is_typed_arrayscm_array_p_2scm_array_pscm_is_arraySCM_GENERALIZED_ARRAYS_H/* SCM_GENERALIZED_ARRAYS_H *//* These functions operate on all kinds of arrays that Guile knows about.
 *//* Copyright (C) 1995,1996,1997,1999,2000,2001, 2004, 2006, 2008, 2009, 2013 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */unused/usr/include/guile/2.0/libguile/generalized-vectors.hscm_init_generalized_vectorsscm_i_register_vector_constructorscm_make_generalized_vectorscm_generalized_vector_get_handlescm_c_generalized_vector_set_xscm_c_generalized_vector_refscm_c_generalized_vector_lengthscm_is_generalized_vectorSCM_VECTOR_IMPLEMENTATION(type,ctor)SCM_SNARF_INIT (scm_i_register_vector_constructor (scm_i_array_element_types[type], ctor))SCM_GENERALIZED_VECTORS_H/* SCM_GENERALIZED_VECTORS_H *//* Generalized vectors */ctor/usr/include/guile/2.0/libguile/validate.hSCM_VALIDATE_VECTOR_LEN(pos,v,len)do { SCM_ASSERT (scm_is_vector (v) && len == scm_c_vector_length (v), v, pos, FUNC_NAME); } while (0)SCM_VALIDATE_VTABLE(pos,v)do { SCM_ASSERT (scm_is_true (scm_struct_vtable_p (v)), v, pos, FUNC_NAME); } while (0)SCM_VALIDATE_STRUCT(pos,v)SCM_MAKE_VALIDATE_MSG (pos, v, STRUCTP, "struct")SCM_VALIDATE_VECTOR_OR_DVECTOR(pos,v)do { SCM_ASSERT ((scm_is_simple_vector (v) || (scm_is_true (scm_f64vector_p (v)))), v, pos, FUNC_NAME); } while (0)SCM_VALIDATE_VECTOR(pos,v)do { SCM_ASSERT (scm_is_simple_vector (v), v, pos, FUNC_NAME); } while (0)SCM_VALIDATE_ARRAY(pos,v)do { SCM_ASSERT (!SCM_IMP (v) && scm_is_true (scm_array_p (v, SCM_UNDEFINED)), v, pos, FUNC_NAME); } while (0)SCM_VALIDATE_RSTATE(pos,v)SCM_MAKE_VALIDATE_MSG (pos, v, RSTATEP, "random-generator-state")SCM_VALIDATE_FRAME(pos,v)SCM_MAKE_VALIDATE_MSG (pos, v, FRAMEP, "frame")SCM_VALIDATE_STACK(pos,v)SCM_MAKE_VALIDATE_MSG (pos, v, STACKP, "stack")SCM_VALIDATE_KEYWORD(pos,v)SCM_MAKE_VALIDATE_MSG (pos, v, KEYWORDP, "keyword")SCM_VALIDATE_FLUID(pos,fluid)SCM_I_MAKE_VALIDATE_MSG2 (pos, fluid, scm_is_fluid, "fluid")SCM_VALIDATE_OPOUTSTRPORT(pos,port)SCM_MAKE_VALIDATE_MSG (pos, port, OPOUTSTRPORTP, "open output string port")SCM_VALIDATE_OPOUTPORT(pos,port)SCM_MAKE_VALIDATE_MSG (pos, port, OPOUTPORTP, "open output port")SCM_VALIDATE_OPPORT(pos,port)SCM_MAKE_VALIDATE_MSG (pos, port, OPPORTP, "open port")SCM_VALIDATE_OPENPORT(pos,port)do { SCM_ASSERT (SCM_PORTP (port) && SCM_OPENP (port), port, pos, FUNC_NAME); } while (0)SCM_VALIDATE_OPINPORT(pos,port)SCM_MAKE_VALIDATE_MSG (pos, port, OPINPORTP, "open input port")SCM_VALIDATE_OPFPORT(pos,port)SCM_MAKE_VALIDATE_MSG (pos, port, OPFPORTP, "open file port")SCM_VALIDATE_FPORT(pos,port)SCM_MAKE_VALIDATE_MSG (pos, port, FPORTP, "file port")SCM_VALIDATE_OUTPUT_PORT(pos,port)SCM_MAKE_VALIDATE_MSG (pos, port, OUTPUT_PORT_P, "output port")SCM_VALIDATE_INPUT_PORT(pos,port)SCM_MAKE_VALIDATE_MSG (pos, port, INPUT_PORT_P, "input port")SCM_VALIDATE_PORT(pos,port)SCM_MAKE_VALIDATE_MSG (pos, port, PORTP, "port")SCM_VALIDATE_DIR(pos,port)SCM_MAKE_VALIDATE_MSG (pos, port, DIRP, "directory port")SCM_VALIDATE_RGXP(pos,a)SCM_MAKE_VALIDATE_MSG (pos, a, RGXP, "regexp")SCM_VALIDATE_HOOK(pos,a)SCM_MAKE_VALIDATE_MSG (pos, a, HOOKP, "hook")SCM_VALIDATE_NULLORCONS(pos,env)do { SCM_ASSERT (scm_is_null (env) || scm_is_pair (env), env, pos, FUNC_NAME); } while (0)SCM_VALIDATE_PROC(pos,proc)do { SCM_ASSERT (scm_is_true (scm_procedure_p (proc)), proc, pos, FUNC_NAME); } while (0)SCM_VALIDATE_MEMOIZED(pos,obj)SCM_MAKE_VALIDATE_MSG (pos, obj, MEMOIZED_P, "memoized code")SCM_VALIDATE_VARIABLE(pos,var)SCM_MAKE_VALIDATE_MSG (pos, var, VARIABLEP, "variable")SCM_VALIDATE_SYMBOL(pos,str)do { SCM_ASSERT_TYPE (scm_is_symbol (str), str, pos, FUNC_NAME, "symbol"); } while (0)SCM_VALIDATE_THUNK(pos,thunk)do { SCM_ASSERT (scm_is_true (scm_thunk_p (thunk)), thunk, pos, FUNC_NAME); } while (0)SCM_VALIDATE_SMOB(pos,obj,type)do { SCM_ASSERT (SCM_SMOB_PREDICATE (scm_tc16_ ## type, obj), obj, pos, FUNC_NAME); } while (0)SCM_VALIDATE_PRINTSTATE(pos,a)SCM_MAKE_VALIDATE_MSG(pos, a, PRINT_STATE_P, "print-state")SCM_VALIDATE_OPORT_VALUE(pos,port)do { SCM_ASSERT (scm_valid_oport_value_p (port), port, pos, FUNC_NAME); } while (0)SCM_VALIDATE_ALISTCELL_COPYSCM(pos,alist,cvar)do { SCM_ASSERT (scm_is_pair (alist), alist, pos, FUNC_NAME); cvar = SCM_CAR (alist); SCM_ASSERT (scm_is_pair (cvar), alist, pos, FUNC_NAME); } while (0)SCM_VALIDATE_ALISTCELL(pos,alist)do { SCM_ASSERT (scm_is_pair (alist) && scm_is_pair (SCM_CAR (alist)), alist, pos, FUNC_NAME); } while (0)SCM_VALIDATE_NONEMPTYLIST_COPYLEN(pos,lst,cvar)do { cvar = scm_ilength (lst); SCM_ASSERT (cvar >= 1, lst, pos, FUNC_NAME); } while (0)SCM_VALIDATE_LIST_COPYLEN(pos,lst,cvar)do { cvar = scm_ilength (lst); SCM_ASSERT (cvar >= 0, lst, pos, FUNC_NAME); } while (0)SCM_VALIDATE_NONEMPTYLIST(pos,lst)do { SCM_ASSERT (scm_ilength (lst) > 0, lst, pos, FUNC_NAME); } while (0)SCM_VALIDATE_LIST(pos,lst)do { SCM_ASSERT (scm_ilength (lst) >= 0, lst, pos, FUNC_NAME); } while (0)SCM_VALIDATE_CONS(pos,scm)SCM_I_MAKE_VALIDATE_MSG2 (pos, scm, scm_is_pair, "pair")SCM_VALIDATE_NULL_OR_NIL(pos,scm)SCM_MAKE_VALIDATE_MSG (pos, scm, NULL_OR_NIL_P, "empty list")SCM_VALIDATE_NULL(pos,scm)SCM_I_MAKE_VALIDATE_MSG2 (pos, scm, scm_is_null, "empty list")SCM_VALIDATE_DOUBLE_DEF_COPY(pos,k,default,cvar)do { if (SCM_UNBNDP (k)) { k = scm_make_real (default); cvar = default; } else { cvar = SCM_NUM2DOUBLE (pos, k); } } while (0)SCM_VALIDATE_DOUBLE_COPY(pos,k,cvar)do { cvar = SCM_NUM2DOUBLE (pos, k); } while (0)SCM_VALIDATE_FLOAT_COPY(pos,k,cvar)do { cvar = SCM_NUM2FLOAT (pos, k); } while (0)SCM_VALIDATE_SIZE_COPY(pos,k,cvar)do { cvar = SCM_NUM2SIZE (pos, k); } while (0)SCM_VALIDATE_LONG_COPY(pos,k,cvar)do { cvar = SCM_NUM2LONG (pos, k); } while (0)SCM_VALIDATE_ULONG_COPY(pos,k,cvar)do { cvar = SCM_NUM2ULONG (pos, k); } while (0)SCM_VALIDATE_INT_COPY(pos,k,cvar)do { cvar = SCM_NUM2INT (pos, k); } while (0)SCM_VALIDATE_UINT_COPY(pos,k,cvar)do { cvar = SCM_NUM2UINT (pos, k); } while (0)SCM_VALIDATE_SHORT_COPY(pos,k,cvar)do { cvar = SCM_NUM2SHORT (pos, k); } while (0)SCM_VALIDATE_USHORT_COPY(pos,k,cvar)do { cvar = SCM_NUM2USHORT (pos, k); } while (0)SCM_VALIDATE_NUMBER(pos,z)SCM_MAKE_VALIDATE_MSG (pos, z, NUMBERP, "number")SCM_VALIDATE_REAL(pos,z)SCM_MAKE_VALIDATE_MSG (pos, z, REALP, "real")SCM_VALIDATE_STRING(pos,str)do { SCM_ASSERT_TYPE (scm_is_string (str), str, pos, FUNC_NAME, "string"); } while (0)SCM_VALIDATE_CHAR_COPY(pos,scm,cvar)do { SCM_ASSERT (SCM_CHARP (scm), scm, pos, FUNC_NAME); cvar = SCM_CHAR (scm); } while (0)SCM_VALIDATE_CHAR(pos,scm)SCM_MAKE_VALIDATE_MSG (pos, scm, CHARP, "character")SCM_VALIDATE_BYTEVECTOR(_pos,_obj)SCM_ASSERT_TYPE (SCM_BYTEVECTOR_P (_obj), (_obj), (_pos), FUNC_NAME, "bytevector")SCM_VALIDATE_BOOL_COPY(pos,flag,cvar)do { SCM_ASSERT (scm_is_bool (flag), flag, pos, FUNC_NAME); cvar = scm_to_bool (flag); } while (0)SCM_VALIDATE_BOOL(pos,flag)do { SCM_ASSERT_TYPE (scm_is_bool (flag), flag, pos, FUNC_NAME, "boolean"); } while (0)SCM_VALIDATE_NIM(pos,scm)SCM_MAKE_VALIDATE_MSG (pos, scm, NIMP, "non-immediate")SCM_VALIDATE_REST_ARGUMENT(x)do { if (SCM_DEBUG_REST_ARGUMENT) { if (scm_ilength (x) < 0) { SCM_MISC_ERROR ("Rest arguments do not form a proper list.", SCM_EOL); } } } while (0)SCM_MAKE_VALIDATE_MSG(pos,var,pred,msg)SCM_I_MAKE_VALIDATE_MSG2 (pos, var, SCM_ ## pred, msg)SCM_I_MAKE_VALIDATE_MSG2(pos,var,pred,msg)do { SCM_ASSERT_TYPE (pred (var), var, pos, FUNC_NAME, msg); } while (0)SCM_MAKE_VALIDATE(pos,var,pred)do { SCM_ASSERT_TYPE (SCM_ ## pred (var), var, pos, FUNC_NAME, #pred); } while (0)SCM_MUST_MALLOC(size)(scm_must_malloc ((size), FUNC_NAME))SCM_MUST_MALLOC_TYPE_NUM(type,num)((type *) scm_must_malloc (sizeof (type) * (num), FUNC_NAME))SCM_MUST_MALLOC_TYPE(type)((type *) scm_must_malloc (sizeof (type), FUNC_NAME))SCM_ASSERT_RANGE(pos,arg,f)do { if (SCM_UNLIKELY (!(f))) scm_out_of_range_pos (FUNC_NAME, arg, scm_from_int (pos)); } while (0)SCM_OUT_OF_RANGE(pos,arg)do { scm_out_of_range_pos (FUNC_NAME, arg, scm_from_int (pos)); } while (0)SCM_NUM2DOUBLE(pos,arg)(scm_to_double (arg))SCM_NUM2FLOAT(pos,arg)((float) scm_to_double (arg))SCM_NUM2SIZE(pos,arg)(scm_to_size_t (arg))SCM_NUM2ULONG_LONG_DEF(pos,arg,def)(SCM_UNBNDP (arg) ? def : scm_to_ulong_long (arg))SCM_NUM2ULONG_LONG(pos,arg)(scm_to_ulong_long (arg))SCM_NUM2LONG_LONG_DEF(pos,arg,def)(SCM_UNBNDP (arg) ? def : scm_to_long_long (arg))SCM_NUM2LONG_LONG(pos,arg)(scm_to_long_long (arg))SCM_NUM2LONG_DEF(pos,arg,def)(SCM_UNBNDP (arg) ? def : scm_to_long (arg))SCM_NUM2LONG(pos,arg)(scm_to_long (arg))SCM_NUM2ULONG_DEF(pos,arg,def)(SCM_UNBNDP (arg) ? def : scm_to_ulong (arg))SCM_NUM2ULONG(pos,arg)(scm_to_ulong (arg))SCM_NUM2UINT_DEF(pos,arg,def)(SCM_UNBNDP (arg) ? def : scm_to_uint (arg))SCM_NUM2UINT(pos,arg)(scm_to_uint (arg))SCM_NUM2INT_DEF(pos,arg,def)(SCM_UNBNDP (arg) ? def : scm_to_int (arg))SCM_NUM2INT(pos,arg)(scm_to_int (arg))SCM_NUM2USHORT_DEF(pos,arg,def)(SCM_UNBNDP (arg) ? def : scm_to_ushort (arg))SCM_NUM2USHORT(pos,arg)(scm_to_ushort (arg))SCM_NUM2SHORT_DEF(pos,arg,def)(SCM_UNBNDP (arg) ? def : scm_to_short (arg))SCM_NUM2SHORT(pos,arg)(scm_to_short (arg))SCM_NUM2PTRDIFF_DEF(pos,arg,def)(SCM_UNBNDP (arg) ? def : scm_to_ssize_t (arg))SCM_NUM2PTRDIFF(pos,arg)(scm_to_ssize_t (arg))SCM_NUM2SIZE_DEF(pos,arg,def)(SCM_UNBNDP (arg) ? def : scm_to_size_t (arg))SCM_WRONG_TYPE_ARG(pos,obj)do { scm_wrong_type_arg (FUNC_NAME, pos, obj); } while (0)SCM_WRONG_NUM_ARGS()do { scm_error_num_args_subr (FUNC_NAME); } while (0)SCM_MISC_ERROR(str,args)do { scm_misc_error (FUNC_NAME, str, args); } while (0)SCM_SYSERROR_MSG(str,args,val)do { scm_syserror_msg (FUNC_NAME, (str), (args), (val)); } while (0)SCM_MEMORY_ERRORdo { scm_memory_error (FUNC_NAME); } while (0)SCM_SYSERRORdo { scm_syserror (FUNC_NAME); } while (0)SCM_VALIDATE_H/* SCM_VALIDATE_H *//* Written by Greg J. Badros <gjb@cs.washington.edu>, Dec-1999 *//* Copyright (C) 1999, 2000, 2001, 2002, 2004, 2006, 2007, 2009,
 *   2012 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/goops.h"libguile/validate.h"scm_init_goopsscm_init_goops_builtinsscm_i_define_class_for_vtablescm_call_generic_3scm_change_object_classscm_sys_method_more_specific_pscm_find_methodscm_makestklos_versionscm_c_extend_primitive_genericscm_primitive_generic_genericscm_set_primitive_generic_xscm_enable_primitive_generic_xscm_generic_capability_pscm_sys_invalidate_method_cache_xscm_sys_invalidate_classscm_sys_modify_classscm_sys_modify_instancescm_slot_exists_pscm_slot_bound_pscm_slot_exists_using_class_pscm_slot_bound_using_class_pscm_slot_set_using_class_xscm_slot_ref_using_classscm_sys_fast_slot_set_xscm_sys_fast_slot_refscm_method_procedurescm_method_specializersscm_method_generic_functionscm_generic_function_methodsscm_generic_function_namescm_class_slotsscm_class_precedence_listscm_class_direct_methodsscm_class_direct_subclassesscm_class_direct_slotsscm_class_direct_supersscm_class_namescm_instance_pscm_sys_inherit_magic_xscm_sys_prep_layout_xscm_sys_initialize_objectscm_get_keywordscm_i_get_keywordscm_i_inherit_applicablescm_sys_compute_slotsscm_sys_compute_applicable_methodsscm_compute_applicable_methodsscm_slot_set_xscm_slot_refscm_sys_set_object_setter_xscm_sys_allocate_instancescm_basic_make_classscm_basic_basic_make_classscm_make_next_methodscm_class_ofscm_ensure_accessorscm_make_port_classesscm_make_extended_classscm_load_goopsscm_c_oldfmtscm_c_oldfmt0scm_oldfmtscm_goops_versionscm_t_methodspecializersgeneric_functionscm_module_goopsscm_no_applicable_methodscm_s_slot_set_xscm_class_doublescm_class_floatscm_class_intscm_class_scmscm_class_protected_read_onlyscm_class_protected_opaquescm_class_protected_hiddenscm_class_read_onlyscm_class_opaquescm_class_hiddenscm_class_protectedscm_class_selfscm_class_foreign_slotscm_class_output_portscm_class_input_portscm_class_input_output_portscm_class_portscm_class_keywordscm_class_listscm_class_numberscm_class_applicable_struct_classscm_class_procedure_classscm_class_accessor_methodscm_class_methodscm_class_extended_accessorscm_class_extended_generic_with_setterscm_class_extended_genericscm_class_accessorscm_class_generic_with_setterscm_class_genericscm_class_applicable_struct_with_setterscm_class_applicable_structscm_class_applicablescm_class_classscm_class_objectscm_class_topscm_smob_classscm_port_classscm_class_unknownscm_class_fractionscm_class_integerscm_class_complexscm_class_realscm_class_nullscm_class_vectorscm_class_primitive_genericscm_class_symbolscm_class_stringscm_class_procedurescm_class_pairscm_class_charscm_class_booleanscm_si_make_procedurescm_si_bodyscm_si_formalsscm_si_procedurescm_si_specializersscm_si_generic_functionscm_si_generic_setterscm_si_effective_methodsscm_si_extended_byscm_si_n_specializedscm_si_methodsscm_si_dispatch_procedureSCM_SET_GENERIC_SETTER(G,C)(SCM_STRUCT_DATA (G) [scm_si_generic_setter] = SCM_UNPACK (C))SCM_GENERIC_SETTER(G)(SCM_PACK (SCM_STRUCT_DATA (G) [scm_si_generic_setter]))SCM_CLEAR_GENERIC_EFFECTIVE_METHODS(G)(SCM_STRUCT_SLOT_SET (G, scm_si_effective_methods, SCM_EOL));SCM_SET_GENERIC_DISPATCH_PROCEDURE(G,C)(SCM_STRUCT_SLOT_SET (G, scm_si_dispatch_procedure, (C)))SCM_SET_CLASS_DESTRUCTOR(c,d)SCM_SET_VTABLE_DESTRUCTOR (c, d)SCM_VALIDATE_METHOD(pos,x)SCM_MAKE_VALIDATE_MSG (pos, x, METHODP, "method")SCM_METHODP(x)(SCM_INSTANCEP (x) && SCM_SUBCLASSP (SCM_CLASS_OF (x), scm_class_method))SCM_VALIDATE_GENERIC(pos,x)SCM_MAKE_VALIDATE_MSG (pos, x, GENERICP, "generic function")SCM_GENERICP(x)(SCM_INSTANCEP (x) && SCM_SUBCLASSP (SCM_CLASS_OF (x), scm_class_generic))SCM_IS_A_P(x,c)(SCM_INSTANCEP (x) && SCM_SUBCLASSP (SCM_CLASS_OF (x), c))SCM_SUBCLASSP(c1,c2)(scm_is_true (scm_c_memq (c2, SCM_SLOT (c1, scm_si_cpl))))SCM_SET_HASHSET(c,i,h)(SCM_INST (c) [scm_si_hashsets + (i)] = (h))SCM_INSTANCE_HASH(c,i)(SCM_INST (c) [scm_si_hashsets + (i)])SCM_SET_SLOT(x,i,v)(SCM_STRUCT_SLOT_SET (x, i, v))SCM_SLOT(x,i)(SCM_STRUCT_SLOT_REF (x, i))SCM_VALIDATE_PUREGENERIC(pos,x)SCM_MAKE_VALIDATE_MSG (pos, x, PUREGENERICP, "pure generic function")SCM_PUREGENERICP(x)(SCM_STRUCTP (x) && (SCM_STRUCT_VTABLE_FLAGS (x) & SCM_CLASSF_PURE_GENERIC))SCM_VALIDATE_INSTANCE(pos,x)SCM_MAKE_VALIDATE_MSG (pos, x, INSTANCEP, "instance")SCM_INSTANCEP(x)(SCM_STRUCTP (x) && (SCM_STRUCT_VTABLE_FLAGS (x) & SCM_CLASSF_GOOPS))SCM_VALIDATE_CLASS(pos,x)SCM_MAKE_VALIDATE_MSG (pos, x, CLASSP, "class")SCM_CLASSP(x)(SCM_STRUCTP (x) && SCM_STRUCT_VTABLE_FLAGS (x) & SCM_CLASSF_METACLASS)SCM_ACCESSORS_OF(x)(SCM_PACK (SCM_STRUCT_VTABLE_DATA (x)[scm_si_getters_n_setters]))SCM_CLASS_OF(x)SCM_STRUCT_VTABLE (x)SCM_INST(x)SCM_STRUCT_DATA (x)SCM_OBJ_CLASS_REDEF(x)(SCM_PACK (SCM_STRUCT_VTABLE_DATA (x) [scm_si_redefined]))SCM_METHOD(obj)((scm_t_method *) SCM_STRUCT_DATA (obj))SCM_N_CLASS_SLOTS(scm_vtable_offset_user + 19)scm_si_nfields(scm_vtable_offset_user + 18)scm_si_keyword_access(scm_vtable_offset_user + 17)scm_si_getters_n_settersscm_si_name_access(scm_vtable_offset_user + 16)scm_si_slots(scm_vtable_offset_user + 15)scm_si_slotdef_class(scm_vtable_offset_user + 14)scm_si_cpl(scm_vtable_offset_user + 13)scm_si_direct_methods(scm_vtable_offset_user + 12)scm_si_direct_subclasses(scm_vtable_offset_user + 11)scm_si_direct_slots(scm_vtable_offset_user + 10)scm_si_direct_supers(scm_vtable_offset_user + 9)scm_si_h7(scm_vtable_offset_user + 8)scm_si_h6(scm_vtable_offset_user + 7)scm_si_h5(scm_vtable_offset_user + 6)scm_si_h4(scm_vtable_offset_user + 5)scm_si_h3(scm_vtable_offset_user + 4)scm_si_h2(scm_vtable_offset_user + 3)scm_si_h1(scm_vtable_offset_user + 2)scm_si_hashsetsscm_si_h0(scm_vtable_offset_user + 1)scm_si_redefined(scm_vtable_offset_user + 0)SCM_CLASS_CLASS_LAYOUT"pw" "uw" "uw" "uw" "uw" "uw" "uw" "uw" "uw" "pw" "pw" "pw" "pw" "pw" "pw" "pw" "pw" "pw" "pw"SCM_CLASSF_GOOPS_OR_VALID(SCM_CLASSF_GOOPS | SCM_CLASSF_GOOPS_VALID)SCM_CLASSF_GOOPSSCM_VTABLE_FLAG_GOOPS_CLASSSCM_CLASSF_GOOPS_VALIDSCM_VTABLE_FLAG_GOOPS_VALIDSCM_CLASSF_PURE_GENERICSCM_VTABLE_FLAG_GOOPS_PURE_GENERICSCM_CLASSF_METACLASS(SCM_VTABLE_FLAG_GOOPS_CLASS|SCM_VTABLE_FLAG_VTABLE)SCM_CLEAR_CLASS_FLAGS(c,f)(SCM_CLEAR_VTABLE_FLAGS (c, f))SCM_SET_CLASS_FLAGS(c,f)(SCM_SET_VTABLE_FLAGS (c, f))SCM_OBJ_CLASS_FLAGS(obj)(SCM_STRUCT_VTABLE_FLAGS (obj))SCM_CLASS_FLAGS(class)(SCM_VTABLE_FLAGS (class))SCM_GOOPS_H/* SCM_GOOPS_H *//* The following are declared in __scm.h
SCM_API SCM scm_call_generic_0 (SCM gf);
SCM_API SCM scm_call_generic_1 (SCM gf, SCM a1);
SCM_API SCM scm_call_generic_2 (SCM gf, SCM a1, SCM a2);
SCM_API SCM scm_apply_generic (SCM gf, SCM args);
*//* Primitives exported *//* Low level functions exported *//* C interface *//* offset of makep.slot in a <method> *//* offset of body  slot in a <method> *//* offset of form. slot in a <method> *//* offset of proc. slot in a <method> *//* offset of spec. slot in a <method> *//* offset of gf    slot in a <method> *//* 0 *//* an integer *//* ((name . options) ...) *//* (class ...) *//* (methods ...) *//* nfields *//* keyword access *//* getters-n-setters *//* slots *//* default-slot-definition-class *//* cpl *//* direct methods *//* direct subclasses *//* direct slots *//* direct supers *//* h7 *//* h6 *//* h5 *//* h4 *//* h3 *//* h2 *//* h1 *//* h0 *//* redefined *//* see also, SCM_VTABLE_BASE_LAYOUT, and build_class_class_slots *//*
 * scm_class_class
 *//* {Class flags}
 *
 * These are used for efficient identification of instances of a
 * certain class or its subclasses when traversal of the inheritance
 * graph would be too costly.
 *//* This software is a derivative work of other copyrighted softwares; the
 * copyright notices of these softwares are placed in the file COPYRIGHTS
 *
 * This file is based upon stklos.h from the STk distribution by
 * Erick Gallesio <eg@unice.fr>.
 *//* Copyright (C) 1998,1999,2000,2001,2002,2003, 2006, 2008, 2009, 2011 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */a3m1m2targsextensiongenericsubrsclsoldnewclsnewinstslot_nameindexdsupersinitargsdefault_valuedslotsmethodsptobnumtype_nameapplicablep/usr/include/guile/2.0/libguile/gsubr.hscm_init_gsubrscm_c_define_gsubr_with_genericscm_c_define_gsubrscm_c_make_gsubr_with_genericscm_c_make_gsubrscm_subr_objcode_trampolineSCM_SET_SUBR_GENERIC(x,g)(*SCM_SUBR_GENERIC (x) = (g))SCM_SUBR_GENERIC(x)((SCM *) SCM_POINTER_VALUE (SCM_SIMPLE_VECTOR_REF (SCM_PROGRAM_OBJTABLE (x), 2)))SCM_SUBR_NAME(x)(SCM_SIMPLE_VECTOR_REF (SCM_PROGRAM_OBJTABLE (x), 1))SCM_SUBRF(x)((SCM (*) (void)) SCM_POINTER_VALUE (SCM_SIMPLE_VECTOR_REF (SCM_PROGRAM_OBJTABLE (x), 0)))SCM_PRIMITIVE_GENERIC_P(x)(SCM_PROGRAM_P (x) && SCM_PROGRAM_IS_PRIMITIVE_GENERIC (x))SCM_PRIMITIVE_P(x)(SCM_PROGRAM_P (x) && SCM_PROGRAM_IS_PRIMITIVE (x))SCM_GSUBR_MAXSCM_GSUBR_H/* SCM_GSUBR_H *//* Max number of args to the C procedure backing a gsubr *//* Subrs 
 *//* Copyright (C) 1995, 1996, 1998, 2000, 2001, 2006, 2008, 2009,
 *   2010, 2011 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */reqoptrstfcnnreqnopt/usr/include/guile/2.0/libguile/guardians.hscm_init_guardiansscm_i_mark_inaccessible_guardedsscm_i_identify_inaccessible_guardedsscm_i_init_guardians_for_gcscm_make_guardianSCM_GUARDIANS_H/* SCM_GUARDIANS_H *//* Copyright (C) 1998,2000,2001, 2006, 2008 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/hash.hscm_init_hashscm_hashscm_ihashscm_hashvscm_ihashvscm_hashqscm_ihashqscm_hasherscm_i_string_hashscm_i_utf8_string_hashscm_i_latin1_string_hashscm_i_locale_string_hashscm_string_hashSCM_HASH_H/* SCM_HASH_H *//* Deprecated in 2.0.12.  *//* Copyright (C) 1995, 1996, 2000, 2006, 2008, 2011,
 *   2015 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/weaks.hscm_i_remove_weaks_from_weak_vectorsscm_i_mark_weak_vectors_non_weaksscm_i_mark_weak_vectorscm_i_init_weak_vectors_for_gcscm_init_weaksscm_weaks_prehistoryscm_init_weaks_builtinsscm_doubly_weak_alist_vector_pscm_weak_value_alist_vector_pscm_weak_key_alist_vector_pscm_make_doubly_weak_alist_vectorscm_make_weak_value_alist_vectorscm_make_weak_key_alist_vectorscm_c_weak_vector_set_xscm_c_weak_vector_refscm_c_weak_vector_lengthscm_is_weak_vectorscm_c_make_weak_vectorscm_weak_vector_set_xscm_weak_vector_refscm_weak_vector_lengthscm_weak_vector_pscm_weak_vectorscm_make_weak_vectorscm_doubly_weak_pairscm_weak_cdr_pairscm_weak_car_pairSCM_WEAK_PAIR_CDR(_cell)(SCM_WEAK_PAIR_WORD ((_cell), 1))SCM_WEAK_PAIR_CAR(_cell)(SCM_WEAK_PAIR_WORD ((_cell), 0))SCM_WEAK_PAIR_WORD(_cell,_word)(SCM_WEAK_PAIR_WORD_DELETED_P ((_cell), (_word)) ? SCM_UNDEFINED : SCM_CELL_OBJECT ((_cell), (_word)))SCM_WEAK_PAIR_DELETED_P(_cell)((SCM_WEAK_PAIR_CAR_DELETED_P (_cell)) || (SCM_WEAK_PAIR_CDR_DELETED_P (_cell)))SCM_WEAK_PAIR_CDR_DELETED_P(_cell)(SCM_WEAK_PAIR_WORD_DELETED_P ((_cell), 1))SCM_WEAK_PAIR_CAR_DELETED_P(_cell)(SCM_WEAK_PAIR_WORD_DELETED_P ((_cell), 0))SCM_WEAK_PAIR_WORD_DELETED_P(_cell,_word)(SCM_UNPACK (SCM_CELL_OBJECT ((_cell), (_word))) == 0)SCM_IS_WHVEC_ANY(X)(SCM_I_WVECT_TYPE (X) != 0)SCM_IS_WHVEC_B(X)(SCM_I_WVECT_TYPE (X) == 3)SCM_IS_WHVEC_V(X)(SCM_I_WVECT_TYPE (X) == 2)SCM_IS_WHVEC(X)(SCM_I_WVECT_TYPE (X) == 1)SCM_I_SET_WVECT_TYPE(x,t)(SCM_I_SET_WVECT_EXTRA ((x), (SCM_I_WVECT_EXTRA (x) & ~7) | (t)))SCM_I_WVECT_TYPE(x)(SCM_I_WVECT_EXTRA(x) & 7)SCM_WVECT_WEAK_VALUE_P(x)(SCM_I_WVECT_EXTRA(x) & SCM_WVECTF_WEAK_VALUE)SCM_WVECT_WEAK_KEY_P(x)(SCM_I_WVECT_EXTRA(x) & SCM_WVECTF_WEAK_KEY)SCM_WVECTF_WEAK_VALUESCM_WVECTF_WEAK_KEYSCM_WEAKS_H/* SCM_WEAKS_H *//* Weak vectors and weak hash tables.  *//* Accessing the components of a weak cell.  These return `SCM_UNDEFINED' if
   the car/cdr has been collected.  *//* Testing the weak component(s) of a cell for reachability.  *//* Weak pairs.  *//* Copyright (C) 1995,1996,2000,2001, 2003, 2006, 2008, 2009, 2011, 2014 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/hashtab.h"weaks.h"scm_init_hashtabscm_i_hashtable_printscm_hash_countscm_hash_map_to_listscm_hash_for_each_handlescm_hash_for_eachscm_hash_foldscm_hashx_remove_xscm_hashx_set_xscm_hashx_refscm_hashx_create_handle_xscm_hashx_get_handlescm_hash_remove_xscm_hash_set_xscm_hash_refscm_hash_create_handle_xscm_hash_get_handlescm_hashv_remove_xscm_hashv_set_xscm_hashv_refscm_hashv_create_handle_xscm_hashv_get_handlescm_hashq_remove_xscm_hashq_set_xscm_hashq_refscm_hashq_create_handle_xscm_hashq_get_handlescm_hash_clear_xscm_internal_hash_for_each_handlescm_internal_hash_foldscm_hash_fn_remove_xscm_hash_fn_set_xscm_hash_fn_refscm_hash_fn_create_handle_xscm_hash_fn_get_handle_by_hashscm_hash_fn_get_handlescm_i_rehashscm_doubly_weak_hash_table_pscm_weak_value_hash_table_pscm_weak_key_hash_table_pscm_hash_table_pscm_make_doubly_weak_hash_tablescm_make_weak_value_hash_tablescm_make_weak_key_hash_tablescm_make_hash_tablescm_c_make_hash_tablescm_vector_to_hash_tablescm_t_hashtablescm_t_hash_handle_fnscm_t_hash_fold_fnscm_t_hash_predicate_fnscm_t_assoc_fnscm_t_hash_fnhash_fnmin_size_indexsize_indexupperlowern_itemsSCM_SET_HASHTABLE_BUCKET(h,i,x)SCM_SIMPLE_VECTOR_SET (SCM_HASHTABLE_VECTOR (h), i, x)SCM_HASHTABLE_BUCKET(h,i)SCM_SIMPLE_VECTOR_REF (SCM_HASHTABLE_VECTOR (h), i)SCM_HASHTABLE_N_BUCKETS(h)SCM_SIMPLE_VECTOR_LENGTH (SCM_HASHTABLE_VECTOR (h))SCM_HASHTABLE_LOWER(x)(SCM_HASHTABLE (x)->lower)SCM_HASHTABLE_UPPER(x)(SCM_HASHTABLE (x)->upper)SCM_HASHTABLE_DECREMENT(x)(SCM_HASHTABLE_N_ITEMS(x)--)SCM_HASHTABLE_INCREMENT(x)(SCM_HASHTABLE_N_ITEMS(x)++)SCM_SET_HASHTABLE_N_ITEMS(x,n)(SCM_HASHTABLE (x)->n_items = n)SCM_HASHTABLE_N_ITEMS(x)(SCM_HASHTABLE (x)->n_items)SCM_HASHTABLE_WEAK_P(x)SCM_HASHTABLE_FLAGS (x)SCM_HASHTABLE_DOUBLY_WEAK_P(x)((SCM_HASHTABLE_FLAGS (x) & (SCM_HASHTABLEF_WEAK_CAR | SCM_HASHTABLEF_WEAK_CDR)) == (SCM_HASHTABLEF_WEAK_CAR | SCM_HASHTABLEF_WEAK_CDR))SCM_HASHTABLE_WEAK_VALUE_P(x)(SCM_HASHTABLE_FLAGS (x) & SCM_HASHTABLEF_WEAK_CDR)SCM_HASHTABLE_WEAK_KEY_P(x)(SCM_HASHTABLE_FLAGS (x) & SCM_HASHTABLEF_WEAK_CAR)SCM_HASHTABLE_FLAGS(x)(SCM_HASHTABLE (x)->flags)SCM_HASHTABLE(x)((scm_t_hashtable *) SCM_CELL_WORD_2 (x))SCM_SET_HASHTABLE_VECTOR(x,v)SCM_SET_CELL_OBJECT_1 ((x), (v))SCM_HASHTABLE_VECTOR(h)SCM_CELL_OBJECT_1 (h)SCM_VALIDATE_HASHTABLE(pos,arg)SCM_MAKE_VALIDATE_MSG (pos, arg, HASHTABLE_P, "hash-table")SCM_HASHTABLE_P(x)(!SCM_IMP (x) && SCM_TYP7(x) == scm_tc7_hashtable)SCM_HASHTABLEF_WEAK_CDRSCM_HASHTABLEF_WEAK_CARSCM_HASHTAB_H/* SCM_HASHTAB_H *//* for rehashing after a GC. *//* minimum size_index *//* index into hashtable_size *//* when to grow *//* when to shrink *//* number of items in table *//* properties of table *//* Function to iterate over the handles (key-value pairs) of a hash
   table.  *//* Function to fold over the entries of a hash table.  *//* Function that returns true if the given object is the one we are
   looking for, for scm_hash_fn_ref_by_hash.  *//* Function that returns the value associated with OBJ in ALIST according to
   some equality predicate.  *//* Function that computes a hash of OBJ modulo MAX.  *//* Copyright (C) 1995,1996,1999,2000,2001, 2003, 2004, 2006, 2008, 2009 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */predassoctablefnclosureassoc_fnraw_hashpredicate_fnfunc_namevector/usr/include/guile/2.0/libguile/i18n.hscm_bootstrap_i18nscm_init_i18nscm_nl_langinfoscm_locale_string_to_inexactscm_locale_string_to_integerscm_string_locale_titlecasescm_string_locale_downcasescm_string_locale_upcasescm_char_locale_titlecasescm_char_locale_downcasescm_char_locale_upcasescm_char_locale_ci_eqscm_char_locale_ci_gtscm_char_locale_ci_ltscm_char_locale_gtscm_char_locale_ltscm_string_locale_ci_eqscm_string_locale_ci_gtscm_string_locale_ci_ltscm_string_locale_gtscm_string_locale_ltscm_locale_pscm_make_localescm_global_localeSCM_I18N_H/* SCM_I18N_H *//* Copyright (C) 2006, 2008, 2009 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */localec1c2category_masklocale_namebase_locale/usr/include/guile/2.0/libguile/init.hscm_load_startup_filesscm_i_init_guilescm_boot_guilescm_init_guilescm_initialized_pscm_i_init_mutexSCM_INIT_H/* SCM_INIT_H *//* Copyright (C) 1995,1996,1997,2000, 2006, 2008, 2011 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */main_func/usr/include/guile/2.0/libguile/ioext.hscm_init_ioextscm_fdes_to_portsscm_primitive_move_to_fdesscm_fdopenscm_isatty_pscm_filenoscm_dup2scm_dup_to_fdesscm_redirect_portscm_ftellSCM_IOEXT_H/* SCM_IOEXT_H *//* Copyright (C) 1995,1996,1997,1998,2000,2001, 2006, 2008 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */oldfdnewfdinto_ptfrom_pt/usr/include/guile/2.0/libguile/rdelim.hscm_init_rdelimscm_init_rdelim_builtinsscm_write_linescm_read_linescm_read_delimited_xSCM_RDELIM_H/* SCM_RDELIM_H */delimsgobble/usr/include/guile/2.0/libguile/rw.hscm_init_rwscm_init_rw_builtinsscm_write_string_partialscm_read_string_x_partialSCM_RW_H/* SCM_RW_H */port_or_fdes/usr/include/guile/2.0/libguile/keywords.hscm_init_keywordsscm_c_bind_keyword_argumentsscm_from_utf8_keywordscm_from_latin1_keywordscm_from_locale_keywordnscm_from_locale_keywordscm_is_keywordscm_keyword_to_symbolscm_symbol_to_keywordscm_keyword_pscm_t_keyword_arguments_flagsscm_keyword_arguments_flagsSCM_ALLOW_OTHER_KEYS1U1U << 0(1U << 0)SCM_ALLOW_NON_KEYWORD_ARGUMENTS1U << 1(1U << 1)scm_tc16_keywordSCM_KEYWORDS_H/* SCM_KEYWORDS_H *//* Copyright (C) 1995,1996,1999,2000,2001, 2006, 2008 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */keyword/usr/include/guile/2.0/libguile/list.hscm_init_listscm_i_finite_list_copyscm_copy_treescm_filter_xscm_filterscm_delete1_xscm_delv1_xscm_delq1_xscm_deletescm_delvscm_delqscm_list_copyscm_delete_xscm_delv_xscm_delq_xscm_memberscm_memvscm_memqscm_c_memqscm_list_tailscm_last_pairscm_list_cdr_set_xscm_list_set_xscm_list_refscm_reverse_xscm_reversescm_append_xscm_appendscm_lengthscm_ilengthscm_list_pscm_null_pscm_cons_starscm_make_listscm_list_headscm_listscm_list_nscm_list_5scm_list_4scm_list_3scm_list_2scm_list_1SCM_LIST_H/* SCM_LIST_H *//* a list known to be finite *//* Guile internal functions *//* Copyright (C) 1995,1996,1997,2000,2001,2003,2004,2005,2006,2008,2009
 * Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */sxnewtailargobjse1e2e3e4e5/usr/include/guile/2.0/libguile/load.hscm_i_mirror_backslashesscm_init_eval_in_schemescm_init_load_should_auto_compilescm_init_loadscm_init_load_pathscm_sys_warn_auto_compilation_enabledscm_c_primitive_load_pathscm_primitive_load_pathscm_sys_search_load_pathscm_search_pathscm_sys_site_ccache_dirscm_sys_global_site_dirscm_sys_site_dirscm_sys_library_dirscm_sys_package_data_dirscm_c_primitive_loadscm_primitive_loadscm_parse_path_with_ellipsisscm_parse_pathSCM_LOAD_H/* SCM_LOAD_H *//* Copyright (C) 1995,1996,1998,2000,2001, 2006, 2008, 2009, 2010, 2011, 2013 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */filename_and_exception_on_not_foundtail/usr/include/guile/2.0/libguile/macros.hscm_init_macrosscm_i_macro_primitivescm_i_make_primitive_macroscm_macro_transformerscm_macro_bindingscm_macro_namescm_macro_typescm_macro_pscm_make_syntax_transformerscm_t_macro_primitiveSCM_MACROS_H/* SCM_MACROS_H *//* Copyright (C) 1998,2000,2001,2002,2003, 2006, 2008, 2009, 2010 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */name_or_existing_definitionbinding/usr/include/guile/2.0/libguile/mallocs.hscm_init_mallocsscm_malloc_objscm_tc16_mallocSCM_SETMALLOCDATA(obj,val)(SCM_SET_SMOB_DATA ((obj), (val)))SCM_MALLOCDATA(obj)((char *) SCM_SMOB_DATA (obj))SCM_MALLOCP(X)(SCM_SMOB_PREDICATE (scm_tc16_malloc, (X)))SCM_MALLOCS_H/* SCM_MALLOCS_H *//* Copyright (C) 1995,2000, 2006, 2008 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/modules.hscm_init_modulesscm_modules_prehistoryscm_get_pre_modules_obarrayscm_current_module_transformerscm_module_transformerscm_module_import_interfacescm_module_public_interfacescm_c_exportscm_c_use_modulescm_c_define_modulescm_resolve_modulescm_c_resolve_modulescm_c_private_refscm_c_public_refscm_private_refscm_public_refscm_c_private_lookupscm_c_public_lookupscm_private_lookupscm_public_lookupscm_c_private_variablescm_c_public_variablescm_private_variablescm_public_variablescm_module_reverse_lookupscm_module_exportscm_module_definescm_module_lookupscm_c_module_definescm_c_module_lookupscm_definescm_lookupscm_c_definescm_c_lookupscm_module_ensure_local_variablescm_module_local_variablescm_module_variablescm_dynwind_current_modulescm_c_call_with_current_modulescm_set_current_modulescm_interaction_environmentscm_the_root_modulescm_current_modulescm_module_tagscm_module_system_booted_pSCM_MODULE_IMPORT_OBARRAY(module)SCM_PACK (SCM_STRUCT_DATA (module)[scm_module_index_import_obarray])SCM_MODULE_DUPLICATE_HANDLERS(module)SCM_PACK (SCM_STRUCT_DATA (module)[scm_module_index_duplicate_handlers])SCM_MODULE_TRANSFORMER(module)SCM_PACK (SCM_STRUCT_DATA (module)[scm_module_index_transformer])SCM_MODULE_EVAL_CLOSURE(module)SCM_PACK (SCM_STRUCT_DATA (module)[scm_module_index_eval_closure])SCM_MODULE_BINDER(module)SCM_PACK (SCM_STRUCT_DATA (module) [scm_module_index_binder])SCM_MODULE_USES(module)SCM_PACK (SCM_STRUCT_DATA (module) [scm_module_index_uses])SCM_MODULE_OBARRAY(module)SCM_PACK (SCM_STRUCT_DATA (module) [scm_module_index_obarray])scm_module_index_import_obarrayscm_module_index_duplicate_handlersscm_module_index_transformerscm_module_index_eval_closurescm_module_index_binderscm_module_index_usesscm_module_index_obarraySCM_VALIDATE_MODULE(pos,scm)SCM_MAKE_VALIDATE_MSG (pos, scm, MODULEP, "module")SCM_MODULEP(OBJ)(!SCM_IMP (OBJ) && SCM_CELL_TYPE (OBJ) == scm_module_tag)SCM_MODULES_H/* SCM_MODULES_H *//* NOTE: Indexes of module fields are dependent upon the definition of
 *       module-type in boot-9.scm.
 *//* Copyright (C) 1998, 2000, 2001, 2002, 2003, 2006, 2007, 2008, 2011, 2012 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */module_namevariablesymbol_list/usr/include/guile/2.0/libguile/net_db.hscm_init_net_dbscm_gai_strerrorscm_getaddrinfoscm_setservscm_setprotoscm_setnetscm_sethostscm_getservscm_getprotoscm_getnetscm_gethostSCM_NET_DB_H/* SCM_NET_DB_H *//* Copyright (C) 1995,2000,2001, 2006, 2008, 2010 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */protohost/usr/include/guile/2.0/libguile/objprop.hscm_init_objpropscm_set_object_property_xscm_object_propertyscm_set_object_properties_xscm_object_propertiesSCM_OBJPROP_H/* SCM_OBJPROP_H *//* Copyright (C) 1995,2000,2001, 2006, 2008 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */plist/usr/include/guile/2.0/libguile/pairs.hscm_init_pairsscm_caaaarscm_caaadrscm_caadarscm_caaddrscm_cadaarscm_cadadrscm_caddarscm_cadddrscm_cdaaarscm_cdaadrscm_cdadarscm_cdaddrscm_cddaarscm_cddadrscm_cdddarscm_cddddrscm_caaarscm_caadrscm_cadarscm_caddrscm_cdaarscm_cdadrscm_cddarscm_cdddrscm_caarscm_cadrscm_cdarscm_cddrscm_set_cdr_xscm_set_car_xscm_cdrscm_carscm_pair_pscm_cons2scm_consSCM_CDDDDR(OBJ)SCM_CDR (SCM_CDR (SCM_CDR (SCM_CDR (OBJ))))SCM_CADDDR(OBJ)SCM_CAR (SCM_CDR (SCM_CDR (SCM_CDR (OBJ))))SCM_CDADDR(OBJ)SCM_CDR (SCM_CAR (SCM_CDR (SCM_CDR (OBJ))))SCM_CAADDR(OBJ)SCM_CAR (SCM_CAR (SCM_CDR (SCM_CDR (OBJ))))SCM_CDDADR(OBJ)SCM_CDR (SCM_CDR (SCM_CAR (SCM_CDR (OBJ))))SCM_CADADR(OBJ)SCM_CAR (SCM_CDR (SCM_CAR (SCM_CDR (OBJ))))SCM_CDAADR(OBJ)SCM_CDR (SCM_CAR (SCM_CAR (SCM_CDR (OBJ))))SCM_CAAADR(OBJ)SCM_CAR (SCM_CAR (SCM_CAR (SCM_CDR (OBJ))))SCM_CDDDAR(OBJ)SCM_CDR (SCM_CDR (SCM_CDR (SCM_CAR (OBJ))))SCM_CADDAR(OBJ)SCM_CAR (SCM_CDR (SCM_CDR (SCM_CAR (OBJ))))SCM_CDADAR(OBJ)SCM_CDR (SCM_CAR (SCM_CDR (SCM_CAR (OBJ))))SCM_CAADAR(OBJ)SCM_CAR (SCM_CAR (SCM_CDR (SCM_CAR (OBJ))))SCM_CDDAAR(OBJ)SCM_CDR (SCM_CDR (SCM_CAR (SCM_CAR (OBJ))))SCM_CADAAR(OBJ)SCM_CAR (SCM_CDR (SCM_CAR (SCM_CAR (OBJ))))SCM_CDAAAR(OBJ)SCM_CDR (SCM_CAR (SCM_CAR (SCM_CAR (OBJ))))SCM_CAAAAR(OBJ)SCM_CAR (SCM_CAR (SCM_CAR (SCM_CAR (OBJ))))SCM_CDDDR(OBJ)SCM_CDR (SCM_CDR (SCM_CDR (OBJ)))SCM_CADDR(OBJ)SCM_CAR (SCM_CDR (SCM_CDR (OBJ)))SCM_CDADR(OBJ)SCM_CDR (SCM_CAR (SCM_CDR (OBJ)))SCM_CAADR(OBJ)SCM_CAR (SCM_CAR (SCM_CDR (OBJ)))SCM_CDDAR(OBJ)SCM_CDR (SCM_CDR (SCM_CAR (OBJ)))SCM_CADAR(OBJ)SCM_CAR (SCM_CDR (SCM_CAR (OBJ)))SCM_CDAAR(OBJ)SCM_CDR (SCM_CAR (SCM_CAR (OBJ)))SCM_CAAAR(OBJ)SCM_CAR (SCM_CAR (SCM_CAR (OBJ)))SCM_CDDR(OBJ)SCM_CDR (SCM_CDR (OBJ))SCM_CADR(OBJ)SCM_CAR (SCM_CDR (OBJ))SCM_CDAR(OBJ)SCM_CDR (SCM_CAR (OBJ))SCM_CAAR(OBJ)SCM_CAR (SCM_CAR (OBJ))SCM_SETCDR(x,v)(SCM_VALIDATE_PAIR (x, SCM_SET_CELL_OBJECT_1 ((x), (v))))SCM_SETCAR(x,v)(SCM_VALIDATE_PAIR (x, SCM_SET_CELL_OBJECT_0 ((x), (v))))SCM_CDR(x)(SCM_VALIDATE_PAIR (x, SCM_CELL_OBJECT_1 (x)))SCM_CAR(x)(SCM_VALIDATE_PAIR (x, SCM_CELL_OBJECT_0 (x)))scm_is_null(x)(scm_is_null_or_nil(x))SCM_NCONSP(x)(!SCM_CONSP (x))SCM_CONSP(x)(scm_is_pair (x))SCM_NNULLP(x)(!scm_is_null (x))SCM_NULLP(x)(scm_is_null (x))SCM_NULL_OR_NIL_P(x)(scm_is_null_or_nil (x))SCM_NILP(x)(scm_is_eq ((x), SCM_ELISP_NIL))scm_is_null_or_nil(x)(SCM_MATCHES_BITS_IN_COMMON ((x), SCM_ELISP_NIL, SCM_EOL))scm_is_null_assume_not_nil(x)(scm_is_eq ((x), SCM_EOL))scm_is_null_and_not_nil(x)SCM_VALIDATE_PAIR(cell,expr)SCM_PAIRS_H(SCM_DEBUG_PAIR_ACCESSES == 1)/* SCM_PAIRS_H *//* #nil is null. *//* Older spellings for these null, nil, and pair predicates. *//*
 * Use scm_is_null_assume_not_nil if 
#nil will never be tested,
 * for increased efficiency.
 *//*
 * Use scm_is_null_and_not_nil if it's important (for correctness)
 * that #nil must NOT be considered null.
 *//* Copyright (C) 1995,1996,2000,2001, 2004, 2006, 2008, 2009, 2010 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */pair/usr/include/guile/2.0/libguile/posix.hscm_init_posixscm_setaffinityscm_getaffinityscm_gethostnamescm_sethostnamescm_flockscm_getpassscm_setpriorityscm_getpriorityscm_getloginscm_chrootscm_cryptscm_syncscm_nicescm_mknodscm_setlocalescm_putenvscm_getpidscm_accessscm_utimescm_system_starscm_close_pipescm_open_pipescm_tmpfilescm_mkstempscm_tmpnamscm_environscm_unamescm_forkscm_execlescm_execlpscm_execlscm_ttynamescm_setegidscm_seteuidscm_setgidscm_setuidscm_getegidscm_geteuidscm_getgidscm_getuidscm_getppidscm_status_stop_sigscm_status_term_sigscm_status_exit_valscm_waitpidscm_killscm_setrlimitscm_getrlimitscm_setgrentscm_getgrgidscm_setpwentscm_getpwuidscm_getpgrpscm_setgroupsscm_getgroupsscm_pipescm_setpgidscm_getsidscm_setsidscm_ctermidscm_tcgetpgrpscm_tcsetpgrpscm_i_locale_mutexSCM_POSIX_H/* SCM_POSIX_H *//* Copyright (C) 1995, 1996, 1997, 1998, 2000, 2001, 2003, 2006, 2008,
 *   2009, 2010, 2011 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */pidcpu_setfileoperationpromptwhichwhopriosaltincrpermsdevcategoryhowpathnameactimemodtimeactimensmodtimenscmdspipestrtmplegideuidgiduidstatussigresourcesofthardusergroupspgid/usr/include/guile/2.0/libguile/procprop.hscm_init_procpropscm_set_procedure_property_xscm_procedure_propertyscm_set_procedure_properties_xscm_procedure_propertiesscm_procedure_minimum_arityscm_set_procedure_minimum_arity_xscm_i_procedure_arityscm_sym_system_procedurescm_sym_arityscm_sym_nameSCM_PROCPROP_H/* SCM_PROCPROP_H *//* Copyright (C) 1995,1996,1998,2000, 2006, 2008, 2009, 2010 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/promises.hscm_init_promisesscm_promise_pscm_forcescm_make_promisescm_tc16_promiseSCM_SET_PROMISE_DATASCM_SET_SMOB_OBJECTSCM_PROMISE_DATASCM_SMOB_OBJECTSCM_PROMISE_MUTEXSCM_SMOB_OBJECT_2SCM_SET_PROMISE_COMPUTED(promise)SCM_SET_SMOB_FLAGS ((promise), SCM_F_PROMISE_COMPUTED)SCM_PROMISE_COMPUTED_P(promise)(SCM_F_PROMISE_COMPUTED & SCM_SMOB_FLAGS (promise))SCM_F_PROMISE_COMPUTEDSCM_PROMISES_H/* SCM_PROMISES_H *//* {Promises}
 *//* Copyright (C) 1995,1996,1998,1999,2000,2001,2002,2003,2004,2008,2009
 * Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/r6rs-ports.hscm_register_r6rs_portsscm_init_r6rs_portsscm_get_string_n_xscm_make_custom_binary_output_portscm_open_bytevector_output_portscm_put_bytevectorscm_put_u8scm_get_bytevector_allscm_get_bytevector_somescm_get_bytevector_n_xscm_get_bytevector_nscm_lookahead_u8scm_get_u8scm_make_custom_binary_input_portscm_open_bytevector_input_portscm_eof_objectSCM_R6RS_PORTS_H/* SCM_R6RS_PORTS_H *//* R6RS I/O Ports.  *//* Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/random.hscm_i_random_bytes_from_platformscm_init_randomscm_random_expscm_random_normal_vector_xscm_random_normalscm_random_hollow_sphere_xscm_random_solid_sphere_xscm_random_uniformscm_random_state_from_platformscm_random_state_to_datumscm_datum_to_random_statescm_seed_to_random_statescm_copy_random_statescm_randomscm_c_random_bignumscm_t_rstate *scm_c_random64scm_c_randomscm_c_exp1scm_c_normal01scm_c_uniform01scm_c_default_rstatescm_c_rstate_from_datumscm_c_make_rstatescm_t_rngscm_t_rstatenormal_nextscm_t_rng *rngto_datumfrom_datumcopy_rstateinit_rstaterandom_bitsrstate_sizescm_var_random_stateunsigned char[256]scm_masktabscm_tc16_rstatescm_the_rngSCM_RSTATE(obj)((scm_t_rstate *) SCM_SMOB_DATA (obj))SCM_RSTATEP(obj)SCM_SMOB_PREDICATE (scm_tc16_rstate, obj)scm_c_uniform32(RSTATE)((RSTATE)->rng->random_bits (RSTATE))SCM_RANDOM_H/* SCM_RANDOM_H *//*
 * Scheme level interface
 *//*
 * Random number library functions
 *//* gives 32 random bits *//* size of random state *//* Custom fields follow here *//* For scm_c_normal01 *//*
 * A plugin interface for RNGs
 *
 * Using this interface, it is possible for the application to tell
 * libguile to use a different RNG.  This is desirable if it is
 * necessary to use the same RNG everywhere in the application in
 * order to prevent interference, if the application uses RNG
 * hardware, or if the application has special demands on the RNG.
 *
 * Look how the default generator is "plugged in" in scm_init_random().
 *//* Copyright (C) 1999,2000,2001, 2006, 2008, 2010 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */datumseed/usr/include/guile/2.0/libguile/read.hscm_init_readscm_i_input_errorscm_file_encodingscm_i_scan_for_encodingscm_read_hash_extendscm_readscm_read_optionsscm_sym_dotSCM_WHITE_SPACESSCM_SINGLE_SPACES: case '\t'SCM_SINGLE_SPACES' ':case '\r':case '\f'SCM_LINE_INCREMENTORS'\n'SCM_READ_H/* SCM_READ_H *//* SCM_LINE_INCREMENTORS are the characters which cause the line count to
 * be incremented for the purposes of error reporting.  This feature
 * is only used for scheme code loaded from files.
 *
 * SCM_WHITE_SPACES are other characters which should be treated like spaces
 * in programs.
 *//* Copyright (C) 1995,1996,2000, 2006, 2008, 2009 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/scmsigs.hscm_i_ensure_signal_delivery_threadscm_i_close_signal_pipescm_init_scmsigsscm_raisescm_usleepscm_sleepscm_pausescm_getitimerscm_setitimerscm_alarmscm_restore_signalsscm_sigaction_for_threadscm_sigactionscm_i_signal_delivery_threadSCM_SCMSIGS_H/* SCM_SCMSIGS_H *//* Copyright (C) 1995,1996,1997,1998,2000, 2002, 2006, 2007, 2008 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */which_timerinterval_secondsinterval_microsecondsvalue_secondsvalue_microsecondssignum/usr/include/guile/2.0/libguile/script.hscm_init_scriptscm_i_set_boot_program_argumentschar *[]scm_shellscm_compile_shell_switchesscm_shell_usagescm_count_argvscm_get_meta_argsscm_find_impl_filescm_find_executablescm_usage_nameSCM_SCRIPT_H/* SCM_SCRIPT_H *//* Copyright (C) 1997,1998,2000, 2006, 2008, 2011 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */fatalexec_pathgeneric_nameinitnamesep/usr/include/guile/2.0/libguile/simpos.hscm_init_simposscm_primitive__exitscm_primitive_exitscm_getenvscm_systemSCM_SIMPOS_H/* SCM_SIMPOS_H *//* Copyright (C) 1995,1996,1997,1998,2000, 2006, 2008 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */nam/usr/include/guile/2.0/libguile/smob.hscm_smob_prehistoryscm_make_smobscm_assert_smob_typescm_set_smob_applyscm_set_smob_equalpscm_set_smob_printscm_set_smob_freescm_set_smob_markscm_make_smob_typescm_smob_printscm_free0scm_markcdrscm_mark0scm_new_double_smobsmobnum255scm_smobs[smobnum].mark || scm_smobs[smobnum].freescm_smob_descriptor[]scm_smob_descriptor *scm_new_smobscm_i_new_smob_with_mark_procscm_i_finalize_smobscm_i_new_double_smobscm_i_new_smobscm_smob_descriptorapply_trampoline_objcodeapplyscm_smobsscm_numsmobSCM_SMOB_APPLY_3(x,a1,a2,rst)(scm_call_3 (x, a1, a2, a3))SCM_SMOB_APPLY_2(x,a1,a2)(scm_call_2 (x, a1, a2))SCM_SMOB_APPLY_1(x,a1)(scm_call_1 (x, a1))SCM_SMOB_APPLY_0(x)(scm_call_0 (x))SCM_SMOB_OBJECT_LOC(x)(SCM_SMOB_OBJECT_1_LOC (x))SCM_SET_SMOB_OBJECT(x,obj)(SCM_SET_SMOB_OBJECT_1 ((x), (obj)))SCM_SMOB_OBJECT(x)(SCM_SMOB_OBJECT_1 (x))SCM_SMOB_OBJECT_3_LOC(x)(SCM_SMOB_OBJECT_N_LOC ((x), 3))SCM_SMOB_OBJECT_2_LOC(x)(SCM_SMOB_OBJECT_N_LOC ((x), 2))SCM_SMOB_OBJECT_1_LOC(x)(SCM_SMOB_OBJECT_N_LOC ((x), 1))SCM_SMOB_OBJECT_0_LOC(x)(SCM_SMOB_OBJECT_N_LOC ((x), 0))SCM_SET_SMOB_OBJECT_3(x,obj)(SCM_SET_SMOB_OBJECT_N ((x), 3, (obj)))SCM_SET_SMOB_OBJECT_2(x,obj)(SCM_SET_SMOB_OBJECT_N ((x), 2, (obj)))SCM_SET_SMOB_OBJECT_1(x,obj)(SCM_SET_SMOB_OBJECT_N ((x), 1, (obj)))SCM_SMOB_OBJECT_3(x)(SCM_SMOB_OBJECT_N ((x), 3))SCM_SMOB_OBJECT_2(x)(SCM_SMOB_OBJECT_N ((x), 2))SCM_SMOB_OBJECT_1(x)(SCM_SMOB_OBJECT_N ((x), 1))SCM_SMOB_OBJECT_N_LOC(x,n)(SCM_CELL_OBJECT_LOC ((x), (n)))SCM_SET_SMOB_OBJECT_N(x,n,obj)(SCM_SET_CELL_OBJECT ((x), (n), (obj)))SCM_SMOB_OBJECT_N(x,n)(SCM_CELL_OBJECT ((x), (n)))SCM_SET_SMOB_DATA(x,data)(SCM_SET_SMOB_DATA_1 ((x), (data)))SCM_SET_SMOB_FLAGS(x,data)(SCM_SET_SMOB_DATA_0 ((x), (SCM_CELL_TYPE (x)&0xffff)|((data)<<16)))SCM_SMOB_DATA(x)(SCM_SMOB_DATA_1 (x))SCM_SMOB_FLAGS(x)(SCM_SMOB_DATA_0 (x) >> 16)SCM_SET_SMOB_DATA_3(x,data)(SCM_SET_SMOB_DATA_N ((x), 3, (data)))SCM_SET_SMOB_DATA_2(x,data)(SCM_SET_SMOB_DATA_N ((x), 2, (data)))SCM_SET_SMOB_DATA_1(x,data)(SCM_SET_SMOB_DATA_N ((x), 1, (data)))SCM_SET_SMOB_DATA_0(x,data)(SCM_SET_SMOB_DATA_N ((x), 0, (data)))SCM_SMOB_DATA_3(x)(SCM_SMOB_DATA_N ((x), 3))SCM_SMOB_DATA_2(x)(SCM_SMOB_DATA_N ((x), 2))SCM_SMOB_DATA_1(x)(SCM_SMOB_DATA_N ((x), 1))SCM_SMOB_DATA_0(x)(SCM_SMOB_DATA_N ((x), 0))SCM_SET_SMOB_DATA_N(x,n,data)(SCM_SET_CELL_WORD ((x), (n), (data)))SCM_SMOB_DATA_N(x,n)(SCM_CELL_WORD ((x), (n)))SCM_RETURN_NEWSMOB3(tc,data1,data2,data3)return scm_new_double_smob ((tc), (scm_t_bits)(data1), (scm_t_bits)(data2), (scm_t_bits)(data3))SCM_NEWSMOB3(z,tc,data1,data2,data3)z = scm_new_double_smob ((tc), (scm_t_bits)(data1), (scm_t_bits)(data2), (scm_t_bits)(data3))SCM_RETURN_NEWSMOB2(tc,data1,data2)return scm_new_double_smob ((tc), (scm_t_bits)(data1), (scm_t_bits)(data2), 0)SCM_NEWSMOB2(z,tc,data1,data2)z = scm_new_double_smob ((tc), (scm_t_bits)(data1), (scm_t_bits)(data2), 0)SCM_RETURN_NEWSMOB(tc,data)return scm_new_smob ((tc), (scm_t_bits)(data))SCM_NEWSMOB(z,tc,data)z = scm_new_smob ((tc), (scm_t_bits)(data))SCM_I_MAX_SMOB_TYPE_COUNTSCM_SMOB_APPLICABLE_P(x)(SCM_SMOB_DESCRIPTOR (x).apply)SCM_SMOB_DESCRIPTOR(x)(scm_smobs[SCM_SMOBNUM (x)])SCM_SMOB_PREDICATE(tag,obj)SCM_TYP16_PREDICATE (tag, obj)SCM_SMOBNAME(smobnum)(scm_smobs[smobnum].name)SCM_SMOBNUM(x)(SCM_TC2SMOBNUM (SCM_CELL_TYPE (x)))SCM_TC2SMOBNUM(x)SCM_SMOB_TYPE_BITS(tc)(tc)SCM_SMOB_TYPE_MASK0xffffSCM_SMOB_H/* SCM_SMOB_H *//* Function for creating smobs *//* The following set of functions is the standard way to create new
 * SMOB types.
 *
 * Create a type tag using `scm_make_smob_type', accept default values
 * for mark, free, print and/or equalp functions, or set your own
 * values using `scm_set_smob_xxx'.
 *//*#define SCM_SET_SMOB_OBJECT_0(x,obj)	(SCM_SET_SMOB_OBJECT_N ((x), 0, (obj)))*//*#define SCM_SMOB_OBJECT_0(x)		(SCM_SMOB_OBJECT_N ((x), 0))*//* These two are internal details of the previous implementation of
   SCM_NEWSMOB and are no longer used.  They are still here to preserve
   ABI stability in the 2.0 series.  *//* Maximum number of SMOB types.  *//* SCM_SMOBNAME can be 0 if name is missing *//* In 2.2 this field is renamed to "apply_trampoline".  *//* This is the internal representation of a smob type *//* Copyright (C) 1995, 1996, 1998, 1999, 2000, 2001, 2004, 2006, 2009,
 *   2010, 2011, 2012 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */data1data2data3/usr/include/guile/2.0/libguile/snarf.hSCM_STATIC_PROGRAM(c_name,objcode,objtable,freevars)static SCM_ALIGNED (8) SCM_UNUSED SCM scm_i_paste (c_name, _raw_cell)[] = { SCM_PACK (scm_tc7_program | SCM_F_PROGRAM_IS_PRIMITIVE), objcode, objtable, freevars }; static SCM_UNUSED const SCM c_name = SCM_PACK (& scm_i_paste (c_name, _raw_cell))SCM_STATIC_SUBR_OBJVECT(c_name,foreign)static SCM_ALIGNED (8) SCM c_name[4] = { SCM_PACK (scm_tc7_vector | (2 << 8)), SCM_PACK (0), foreign, SCM_BOOL_F, }SCM_IMMUTABLE_POINTER(c_name,ptr)SCM_IMMUTABLE_CELL (c_name, scm_tc7_pointer, ptr)SCM_IMMUTABLE_STRING(c_name,contents)SCM_IMMUTABLE_STRINGBUF (scm_i_paste (c_name, _stringbuf), contents); SCM_IMMUTABLE_DOUBLE_CELL (c_name, scm_tc7_ro_string, (scm_t_bits) &scm_i_paste (c_name, _stringbuf), (scm_t_bits) 0, (scm_t_bits) (sizeof (contents) - 1))SCM_IMMUTABLE_STRINGBUF(c_name,contents)static SCM_UNUSED const struct { scm_t_bits word_0; scm_t_bits word_1; const char buffer[sizeof (contents)]; } c_name = { scm_tc7_stringbuf | SCM_I_STRINGBUF_F_SHARED, sizeof (contents) - 1, contents }SCM_STATIC_DOUBLE_CELL(c_name,car,cbr,ccr,cdr)static SCM_ALIGNED (8) SCM_UNUSED scm_t_cell c_name ## _raw_cell [2] = { { SCM_PACK (car), SCM_PACK (cbr) }, { SCM_PACK (ccr), SCM_PACK (cdr) } }; static SCM_UNUSED SCM c_name = SCM_PACK (& c_name ## _raw_cell)SCM_IMMUTABLE_DOUBLE_CELL(c_name,car,cbr,ccr,cdr)static SCM_ALIGNED (8) SCM_UNUSED const scm_t_cell c_name ## _raw_cell [2] = { { SCM_PACK (car), SCM_PACK (cbr) }, { SCM_PACK (ccr), SCM_PACK (cdr) } }; static SCM_UNUSED const SCM c_name = SCM_PACK (& c_name ## _raw_cell)SCM_IMMUTABLE_CELL(c_name,car,cdr)static SCM_ALIGNED (8) SCM_UNUSED const scm_t_cell c_name ## _raw_scell = { SCM_PACK (car), SCM_PACK (cdr) }; static SCM_UNUSED const SCM c_name = SCM_PACK (& c_name ## _raw_scell)SCM_GLOBAL_SMOB_APPLY(tag,c_name,req,opt,rest,arglist)SCM_SNARF_HERE(SCM c_name arglist) SCM_SNARF_INIT(scm_set_smob_apply((tag), (c_name), (req), (opt), (rest));)SCM_SMOB_APPLY(tag,c_name,req,opt,rest,arglist)SCM_SNARF_HERE(static SCM c_name arglist) SCM_SNARF_INIT(scm_set_smob_apply((tag), (c_name), (req), (opt), (rest));)SCM_GLOBAL_SMOB_EQUALP(tag,c_name,obj1,obj2)SCM_SNARF_HERE(SCM c_name(SCM obj1, SCM obj2)) SCM_SNARF_INIT(scm_set_smob_equalp((tag), (c_name));)SCM_SMOB_EQUALP(tag,c_name,obj1,obj2)SCM_SNARF_HERE(static SCM c_name(SCM obj1, SCM obj2)) SCM_SNARF_INIT(scm_set_smob_equalp((tag), (c_name));)SCM_GLOBAL_SMOB_PRINT(tag,c_name,obj,port,pstate)SCM_SNARF_HERE(int c_name(SCM obj, SCM port, scm_print_state* pstate)) SCM_SNARF_INIT(scm_set_smob_print((tag), (c_name));)SCM_SMOB_PRINT(tag,c_name,obj,port,pstate)SCM_SNARF_HERE(static int c_name(SCM obj, SCM port, scm_print_state* pstate)) SCM_SNARF_INIT(scm_set_smob_print((tag), (c_name));)SCM_GLOBAL_SMOB_FREE(tag,c_name,arg)SCM_SNARF_HERE(size_t c_name(SCM arg)) SCM_SNARF_INIT(scm_set_smob_free((tag), (c_name));)SCM_SMOB_FREE(tag,c_name,arg)SCM_SNARF_HERE(static size_t c_name(SCM arg)) SCM_SNARF_INIT(scm_set_smob_free((tag), (c_name));)SCM_GLOBAL_SMOB_MARK(tag,c_name,arg)SCM_SNARF_HERE(SCM c_name(SCM arg)) SCM_SNARF_INIT(scm_set_smob_mark((tag), (c_name));)SCM_SMOB_MARK(tag,c_name,arg)SCM_SNARF_HERE(static SCM c_name(SCM arg)) SCM_SNARF_INIT(scm_set_smob_mark((tag), (c_name));)SCM_GLOBAL_SMOB(tag,scheme_name,size)SCM_SNARF_HERE(scm_t_bits tag) SCM_SNARF_INIT((tag)=scm_make_smob_type((scheme_name), (size));)SCM_SMOB(tag,scheme_name,size)SCM_SNARF_HERE(static scm_t_bits tag) SCM_SNARF_INIT((tag)=scm_make_smob_type((scheme_name), (size));)SCM_GLOBAL_REC_MUTEX(c_name)SCM_SNARF_HERE(scm_t_rec_mutex c_name) SCM_SNARF_INIT(scm_i_plugin_rec_mutex_init (&c_name, &scm_i_plugin_rec_mutex))SCM_REC_MUTEX(c_name)SCM_SNARF_HERE(static scm_t_rec_mutex c_name) SCM_SNARF_INIT(scm_i_plugin_rec_mutex_init (&c_name, &scm_i_plugin_rec_mutex))SCM_GLOBAL_MUTEX(c_name)SCM_SNARF_HERE(scm_t_mutex c_name) SCM_SNARF_INIT(scm_i_plugin_mutex_init (&c_name, &scm_i_plugin_mutex))SCM_MUTEX(c_name)SCM_SNARF_HERE(static scm_t_mutex c_name) SCM_SNARF_INIT(scm_i_plugin_mutex_init (&c_name, &scm_i_plugin_mutex))SCM_GLOBAL_VARIABLE_INIT(c_name,scheme_name,init_val)SCM_SNARF_HERE(SCM c_name) SCM_SNARF_INIT(c_name = scm_c_define (scheme_name, init_val);)SCM_VARIABLE_INIT(c_name,scheme_name,init_val)SCM_SNARF_HERE(static SCM c_name) SCM_SNARF_INIT(c_name = scm_c_define (scheme_name, init_val);)SCM_GLOBAL_VARIABLE(c_name,scheme_name)SCM_SNARF_HERE(SCM c_name) SCM_SNARF_INIT(c_name = scm_c_define (scheme_name, SCM_BOOL_F);)SCM_VARIABLE(c_name,scheme_name)SCM_SNARF_HERE(static SCM c_name) SCM_SNARF_INIT(c_name = scm_c_define (scheme_name, SCM_BOOL_F);)SCM_GLOBAL_KEYWORD(c_name,scheme_name)SCM_SNARF_HERE(SCM c_name) SCM_SNARF_INIT(c_name = scm_from_locale_keyword (scheme_name))SCM_KEYWORD(c_name,scheme_name)SCM_SNARF_HERE(static SCM c_name) SCM_SNARF_INIT(c_name = scm_from_locale_keyword (scheme_name))SCM_GLOBAL_SYMBOL(c_name,scheme_name)SCM_SNARF_HERE( SCM_IMMUTABLE_STRING (scm_i_paste (c_name, _string), scheme_name); SCM c_name) SCM_SNARF_INIT( c_name = scm_string_to_symbol (scm_i_paste (c_name, _string)) )SCM_SYMBOL(c_name,scheme_name)SCM_SNARF_HERE( SCM_IMMUTABLE_STRING (scm_i_paste (c_name, _string), scheme_name); static SCM c_name) SCM_SNARF_INIT( c_name = scm_string_to_symbol (scm_i_paste (c_name, _string)) )SCM_GPROC(RANAME,STR,REQ,OPT,VAR,CFN,GF)SCM_SNARF_HERE(SCM_UNUSED static const char RANAME[]=STR;static SCM GF )SCM_SNARF_INIT(GF = SCM_PACK (0); scm_c_define_gsubr_with_generic (RANAME, REQ, OPT, VAR, (SCM_FUNC_CAST_ARBITRARY_ARGS) CFN, &GF) )SCM_REGISTER_PROC(RANAME,STR,REQ,OPT,VAR,CFN)SCM_SNARF_HERE(SCM_UNUSED static const char RANAME[]=STR) SCM_SNARF_INIT(scm_c_define_gsubr (RANAME, REQ, OPT, VAR, (SCM_FUNC_CAST_ARBITRARY_ARGS) CFN);) SCM_SNARF_DOCS(register, CFN, STR, (), REQ, OPT, VAR, "implemented by the C function \"" #CFN "\"")SCM_PROC(RANAME,STR,REQ,OPT,VAR,CFN)SCM_SNARF_HERE(SCM_UNUSED static const char RANAME[]=STR) SCM_SNARF_INIT(scm_c_define_gsubr (RANAME, REQ, OPT, VAR, (SCM_FUNC_CAST_ARBITRARY_ARGS) CFN))SCM_DEFINE_PUBLIC(FNAME,PRIMNAME,REQ,OPT,VAR,ARGLIST,DOCSTRING)SCM_SNARF_HERE(SCM_UNUSED static const char s_ ## FNAME [] = PRIMNAME; SCM FNAME ARGLIST)SCM_SNARF_INIT(scm_c_define_gsubr (s_ ## FNAME, REQ, OPT, VAR, (SCM_FUNC_CAST_ARBITRARY_ARGS) FNAME); scm_c_export (s_ ## FNAME, NULL); )SCM_SNARF_DOCS(primitive, FNAME, PRIMNAME, ARGLIST, REQ, OPT, VAR, DOCSTRING)SCM_PRIMITIVE_GENERIC(FNAME,PRIMNAME,REQ,OPT,VAR,ARGLIST,DOCSTRING)SCM_SNARF_HERE(SCM_UNUSED static const char s_ ## FNAME [] = PRIMNAME; static SCM g_ ## FNAME; SCM FNAME ARGLIST)SCM_SNARF_INIT(g_ ## FNAME = SCM_PACK (0); scm_c_define_gsubr_with_generic (s_ ## FNAME, REQ, OPT, VAR, (SCM_FUNC_CAST_ARBITRARY_ARGS) FNAME, &g_ ## FNAME); )SCM_SNARF_DOCS(primitive, FNAME, PRIMNAME, ARGLIST, REQ, OPT, VAR, DOCSTRING)SCM_DEFINE(FNAME,PRIMNAME,REQ,OPT,VAR,ARGLIST,DOCSTRING)SCM_SYMBOL (scm_i_paste (FNAME, __name), PRIMNAME); SCM_SNARF_HERE( SCM_UNUSED static const char scm_i_paste (s_, FNAME) [] = PRIMNAME; SCM_API SCM FNAME ARGLIST; SCM_IMMUTABLE_POINTER (scm_i_paste (FNAME, __subr_foreign), (scm_t_bits) &FNAME); SCM_STATIC_SUBR_OBJVECT (scm_i_paste (FNAME, __raw_objtable), SCM_BOOL_F); SCM_STATIC_PROGRAM (scm_i_paste (FNAME, __subr), SCM_BOOL_F, SCM_PACK (&scm_i_paste (FNAME, __raw_objtable)), SCM_BOOL_F); SCM FNAME ARGLIST ) SCM_SNARF_INIT( scm_i_paste (FNAME, __raw_objtable)[2] = scm_i_paste (FNAME, __subr_foreign); scm_i_paste (FNAME, __raw_objtable)[3] = scm_i_paste (FNAME, __name); SCM_SET_CELL_OBJECT (scm_i_paste (FNAME, __subr), 1, scm_subr_objcode_trampoline (REQ, OPT, VAR)); scm_define (scm_i_paste (FNAME, __name), scm_i_paste (FNAME, __subr)); ) SCM_SNARF_DOCS(primitive, FNAME, PRIMNAME, ARGLIST, REQ, OPT, VAR, DOCSTRING)SCM_DEFINE_GSUBR(FNAME,PRIMNAME,REQ,OPT,VAR,ARGLIST,DOCSTRING)SCM_SNARF_HERE(SCM_UNUSED static const char s_ ## FNAME [] = PRIMNAME; SCM FNAME ARGLIST)SCM_SNARF_INIT(scm_c_define_gsubr (s_ ## FNAME, REQ, OPT, VAR, (SCM_FUNC_CAST_ARBITRARY_ARGS) FNAME); )SCM_SNARF_DOCS(primitive, FNAME, PRIMNAME, ARGLIST, REQ, OPT, VAR, DOCSTRING)SCM_SNARF_DOCS(TYPE,CNAME,FNAME,ARGLIST,REQ,OPT,VAR,DOCSTRING)SCM_SNARF_INIT(X)SCM_SNARF_HERE(X)Xscm_i_paste3(a,b,c)a ## b ## cscm_i_paste(x,y)x ## ySCM_SUPPORT_STATIC_ALLOCATIONSCM_FUNC_CAST_ARBITRARY_ARGSSCM_SNARF_HSCM_ALIGNEDSCM_MAGIC_SNARF_INITSSCM_MAGIC_SNARF_DOCS/* SCM_SNARF_H *//* SCM_MAGIC_SNARF_DOCS *//* Documentation.  *//* SCM_SUPPORT_STATIC_ALLOCATION *//* the name *//* for primitive-generics, add a foreign to the end *//* Low-level snarfing for static memory allocation.  *//* !SCM_SUPPORT_STATIC_ALLOCATION *//* Dirk:FIXME:: Can we safely use #f instead of 0? *//* Always use the generic subr case.  *//* Define the subr.  *//* Initialize the objcode trampoline.  *//* Initialize the procedure name (an interned symbol).  *//* Initialize the foreign.  *//* FIXME: be immutable. grr *//* FIXME: directly be the foreign *//* the subr *//* FIXME: how to verify that req + opt + rest < 11, all are positive, etc? *//* Static subr allocation.  *//* Generic macros to be used in user macro definitions.
 *
 * For example, in order to define a macro which creates ints and
 * initializes them to the result of foo (), do:
 *
 *   #define SCM_FOO(NAME) \
 *     SCM_SNARF_HERE (int NAME) \
 *     SCM_SNARF_INIT (NAME = foo ())
 *
 * The SCM_SNARF_INIT text goes into the corresponding .x file
 * up through the first occurrence of SCM_SNARF_DOC_START on that
 * line, if any.
 *
 * Some debugging options can cause the preprocessor to echo #define
 * directives to its output. Keeping the snarfing markers on separate
 * lines prevents guile-snarf from inadvertently snarfing the definition
 * of SCM_SNARF_INIT if those options are in effect.
 *//* C preprocessor token concatenation.  *//* We support static allocation of some `SCM' objects.  *//* Casting to a function that can take any number of arguments.  *//* Macros for snarfing initialization actions from C source. *//* Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
 *   2004, 2006, 2009, 2010, 2011, 2014 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/socket.hscm_make_socket_addresssockaddr *scm_c_make_socket_addressscm_to_sockaddrscm_from_sockaddrconst sockaddrconst sockaddr *scm_init_socketscm_sendtoscm_recvfromscm_sendscm_recvscm_getpeernamescm_getsocknamescm_acceptscm_listenscm_bindscm_connectscm_shutdownscm_setsockoptscm_getsockoptscm_socketpairscm_socketscm_inet_ntopscm_inet_ptonscm_inet_makeaddrscm_lnaofscm_inet_netofscm_inet_ntoascm_inet_atonsockaddrSCM_SOCKET_H/* SCM_SOCKET_H *//* Wrapping/unwrapping address objects.  *//* Copyright (C) 1995,1996,1997,2000,2001, 2004, 2005, 2006, 2008, 2014 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */familyaddress_sizeadress_sizeaddr_sizesockfdfamargs_and_flagsbuff_or_sizesfdbacklogoptnamestylenetlnainetid/usr/include/guile/2.0/libguile/sort.hscm_init_sortscm_sort_list_xscm_sort_listscm_stable_sort_xscm_stable_sortscm_sort_xscm_sortscm_merge_xscm_mergescm_sorted_pscm_restricted_vector_sort_xSCM_SORT_H/* SCM_SORT_H *//* Copyright (C) 1999,2000, 2006, 2008 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */lslessls1ls2startposendpos/usr/include/guile/2.0/libguile/srcprop.hscm_init_srcpropscm_cons_sourcescm_i_set_source_properties_xscm_i_has_source_propertiesscm_set_source_properties_xscm_source_propertiesscm_set_source_property_xscm_source_propertyscm_make_srcpropsscm_supports_source_properties_pscm_sym_columnscm_sym_linescm_sym_copyscm_sym_filenamescm_tc16_srcpropsSCM_SOURCE_PROPERTY_FLAG_BREAKSCM_PROCTRACEP(x)(scm_is_true (scm_procedure_property (x, scm_sym_trace)))SCM_SRCPROP_H/* SCM_SRCPROP_H *//* {Source properties}
 *//* Copyright (C) 1995, 1996, 2000, 2001, 2006, 2008, 2009, 2010,
 *   2011, 2012 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */xorigcolcopy/usr/include/guile/2.0/libguile/stackchk.hscm_init_stackchkscm_sys_get_stack_sizescm_stack_reportscm_stack_sizescm_report_stack_overflowscm_stack_checking_enabled_pSCM_CHECK_STACKSCM_STACK_CHECKING_PSCM_STACK_LIMITSCM_STACKCHK_Hdefined BUILDING_LIBGUILE && defined STACK_CHECKING/* SCM_STACKCHK_H *//**//* With debug options we have the possibility to disable stack checking.
 *//* Copyright (C) 1995,1996,1998,2000, 2003, 2006, 2008, 2009, 2010 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/stime.hscm_init_stimescm_strptimescm_strftimescm_timesscm_tzsetscm_mktimescm_gmtimescm_localtimescm_gettimeofdayscm_current_timescm_get_internal_run_timescm_get_internal_real_timescm_c_get_internal_run_timescm_c_time_units_per_secondSCM_TIME_UNITS_PER_SECONDSCM_STIME_H/* SCM_STIME_H *//* Copyright (C) 1995,1996,1997,1998,2000, 2003, 2006, 2008, 2011 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */formatstimesbd_timezonetime/usr/include/guile/2.0/libguile/srfi-13.hscm_init_srfi_13_14scm_init_srfi_13scm_string_deletescm_string_filterscm_string_splitscm_string_tokenizescm_string_replacescm_string_xcopy_xscm_xsubstringscm_string_for_each_indexscm_string_for_eachscm_string_unfold_rightscm_string_unfoldscm_string_fold_rightscm_string_foldscm_string_map_xscm_string_mapscm_string_concatenate_reverse_sharedscm_string_concatenate_reversescm_string_concatenate_sharedscm_string_concatenatescm_string_append_sharedscm_string_reverse_xscm_string_reversescm_string_capitalizescm_string_capitalize_xscm_string_titlecasescm_string_titlecase_xscm_string_downcasescm_string_downcase_xscm_substring_downcasescm_substring_downcase_xscm_string_upcasescm_string_upcase_xscm_substring_upcasescm_substring_upcase_xscm_string_contains_ciscm_string_containsscm_string_countscm_string_skip_rightscm_string_skipscm_string_rindexscm_string_index_rightscm_string_indexscm_string_suffix_ci_pscm_string_suffix_pscm_string_prefix_ci_pscm_string_prefix_pscm_string_suffix_length_ciscm_string_suffix_lengthscm_string_prefix_length_ciscm_string_prefix_lengthscm_substring_hash_ciscm_substring_hashscm_string_ci_gescm_string_ci_lescm_string_ci_gtscm_string_ci_ltscm_string_ci_neqscm_string_ci_eqscm_string_gescm_string_lescm_string_gtscm_string_ltscm_string_neqscm_string_eqscm_string_compare_ciscm_string_comparescm_string_fill_xscm_substring_fill_xscm_string_trim_bothscm_string_trim_rightscm_string_trimscm_string_pad_rightscm_string_padscm_string_drop_rightscm_string_take_rightscm_string_dropscm_string_takescm_substring_move_xscm_string_copy_xscm_string_copyscm_string_joinscm_reverse_list_to_stringscm_substring_to_listscm_string_to_listscm_string_tabulatescm_string_everyscm_string_anyscm_string_null_pSCM_SRFI_13_H/* SCM_SRFI_13_H *//* srfi-13.c --- SRFI-13 procedures for Guile
 *
 * 	Copyright (C) 2001, 2004, 2006, 2008, 2010 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */char_predtoken_charend2targettstartsfromstofromfgmake_finalkonsknilfinal_stringboundproc_ltproc_eqproc_gtstr1str2delimitergrammar/usr/include/guile/2.0/libguile/srfi-14.hscm_init_srfi_14scm_sys_char_set_dumpscm_char_set_diff_plus_intersection_xscm_char_set_xor_xscm_char_set_difference_xscm_char_set_intersection_xscm_char_set_union_xscm_char_set_complement_xscm_char_set_diff_plus_intersectionscm_char_set_xorscm_char_set_differencescm_char_set_intersectionscm_char_set_unionscm_char_set_complementscm_char_set_delete_xscm_char_set_adjoin_xscm_char_set_deletescm_char_set_adjoinscm_char_set_anyscm_char_set_everyscm_char_set_contains_pscm_char_set_to_stringscm_char_set_to_listscm_char_set_countscm_char_set_sizescm_to_char_setscm_ucs_range_to_char_set_xscm_ucs_range_to_char_setscm_char_set_filter_xscm_char_set_filterscm_string_to_char_set_xscm_string_to_char_setscm_list_to_char_set_xscm_list_to_char_setscm_char_setscm_char_set_copyscm_char_set_mapscm_char_set_for_eachscm_char_set_unfold_xscm_char_set_unfoldscm_char_set_foldscm_end_of_char_set_pscm_char_set_cursor_nextscm_char_set_refscm_char_set_cursorscm_char_set_hashscm_char_set_leqscm_char_set_eqscm_char_set_pscm_i_charset_unsetscm_t_char_set *scm_i_charset_setscm_i_charset_getscm_t_char_set_cursorscm_t_char_setscm_t_char_rangerangescm_t_char_range *rangeshiloscm_char_set_fullscm_char_set_emptyscm_char_set_asciiscm_char_set_blankscm_char_set_hex_digitscm_char_set_symbolscm_char_set_punctuationscm_char_set_iso_controlscm_char_set_whitespacescm_char_set_printingscm_char_set_graphicscm_char_set_letter_and_digitscm_char_set_digitscm_char_set_letterscm_char_set_title_casescm_char_set_upper_casescm_char_set_lower_casescm_tc16_charsetSCM_CHARSETP(x)(!SCM_IMP (x) && (SCM_TYP16 (x) == scm_tc16_charset))SCM_CHARSET_GET(cs,idx)scm_i_charset_get((scm_t_char_set *)SCM_SMOB_DATA(cs),idx)SCM_SRFI_14_H/* SCM_SRFI_14_H *//* Smob type code for character sets.  *//* srfi-14.c --- SRFI-14 procedures for Guile
 *
 * 	Copyright (C) 2001, 2004, 2006, 2008 Free Software Foundation, Inc.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */charsetcs1cs2cscherrorbase_cscursorchar_sets/usr/include/guile/2.0/libguile/strorder.hscm_init_strorderscm_string_ci_geq_pscm_string_ci_gr_pscm_string_ci_leq_pscm_string_ci_less_pscm_string_geq_pscm_string_gr_pscm_string_leq_pscm_string_less_pscm_string_ci_equal_pscm_string_equal_pSCM_STRORDER_H/* SCM_STRORDER_H *//usr/include/guile/2.0/libguile/strports.hscm_init_strportsscm_eval_string_in_modulescm_eval_stringscm_c_eval_string_in_modulescm_c_eval_stringscm_c_read_stringscm_get_output_stringscm_open_output_stringscm_open_input_stringscm_call_with_input_stringscm_call_with_output_stringscm_object_to_stringscm_strport_to_stringscm_mkstrportscm_tc16_strportSCM_OPOUTSTRPORTP(x)(SCM_OPSTRPORTP (x) && (SCM_CELL_WORD_0 (x) & SCM_WRTNG))SCM_OPINSTRPORTP(x)(SCM_OPSTRPORTP (x) && (SCM_CELL_WORD_0 (x) & SCM_RDNG))SCM_OPSTRPORTP(x)(SCM_STRPORTP (x) && (SCM_CELL_WORD_0 (x) & SCM_OPN))SCM_STRPORTP(x)(!SCM_IMP (x) && (SCM_TYP16 (x) == scm_tc16_strport))SCM_STRPORTS_H/* SCM_STRPORTS_H *//* Copyright (C) 1995,1996,2000,2001,2002, 2006, 2008, 2010 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */exprcaller/usr/include/guile/2.0/libguile/symbols.hscm_init_symbolsscm_symbols_prehistoryscm_i_hash_symbolscm_take_utf8_symbolnscm_take_utf8_symbolscm_from_utf8_symbolnscm_from_utf8_symbolscm_take_latin1_symbolnscm_take_latin1_symbolscm_from_latin1_symbolnscm_from_latin1_symbolscm_take_locale_symbolnscm_take_locale_symbolscm_from_locale_symbolnscm_from_locale_symbolscm_gensymscm_symbol_hashscm_symbol_pset_xscm_symbol_fset_xscm_symbol_prefscm_symbol_frefscm_string_ci_to_symbolscm_string_to_symbolscm_symbol_to_stringscm_make_symbolscm_symbol_interned_pscm_symbol_pSCM_SYMBOL_INTERNED_P(x)(scm_i_symbol_is_interned (x))SCM_SYMBOL_HASH(x)(scm_i_symbol_hash (x))SCM_SET_SYMBOL_PROPS(x,p)(scm_symbol_pset_x (x, p))SCM_SYMBOL_PROPS(x)(scm_symbol_pref (x))SCM_SET_SYMBOL_FUNC(x,f)(scm_symbol_fset_x (x, f))SCM_SYMBOL_FUNC(x)(scm_symbol_fref (x))SCM_SYMBOLP(x)(scm_is_symbol (x))SCM_I_F_SYMBOL_UNINTERNEDscm_i_symbol_is_interned(x)(!(SCM_CELL_WORD_0 (x) & SCM_I_F_SYMBOL_UNINTERNED))scm_i_symbol_hash(x)((unsigned long) SCM_CELL_WORD_2 (x))scm_is_symbol(x)(!SCM_IMP (x) && (SCM_TYP7 (x) == scm_tc7_symbol))SCM_SYMBOLS_H/* SCM_SYMBOLS_H *//* internal functions. *//* Use locale encoding for user input, user output, or interacting with
   the C library.  Use latin-1 for ASCII, and for literals in source
   code.  Use UTF-8 for interaction with modern libraries which deal in
   UTF-8.  Otherwise use scm_to_stringn or scm_from_stringn, and
   convert.  *//* Older spellings; don't use in new code.
 *//* Copyright (C) 1995,1996,1997,1998,2000,2001, 2003, 2004, 2006, 2008, 2010 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */prefix/usr/include/guile/2.0/libguile/trees.hscm_init_treesSCM_TREES_H/* SCM_TREES_H *//* Copyright (C) 2009
 * Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/uniform.h"libguile/generalized-vectors.h"scm_init_uniformscm_uniform_vector_writable_elementsscm_uniform_vector_elementsscm_c_uniform_vector_set_xscm_c_uniform_vector_refscm_c_uniform_vector_lengthscm_is_uniform_vectorscm_uniform_vector_writescm_uniform_vector_read_xscm_uniform_vector_to_listscm_uniform_vector_set_xscm_uniform_vector_refscm_uniform_vector_element_sizescm_uniform_vector_element_typescm_uniform_vector_lengthscm_uniform_vector_pscm_array_handle_uniform_writable_elementsscm_array_handle_uniform_elementsscm_array_handle_uniform_element_bit_sizescm_array_handle_uniform_element_sizeconst size_tconst size_t[]scm_i_array_element_type_sizesSCM_ARRAY_ELEMENT_TYPE_IS_UNBOXED(t)(scm_i_array_element_type_sizes[(t)] != 0)SCM_UNIFORM_H/* SCM_UNIFORM_H *//* type size in bits *//* type size in bytes *//*
 * Uniform vectors contain unboxed values. They are not necessarily contiguous.
 *//* Copyright (C) 1995,1996,1997,1999,2000,2001, 2004, 2006, 2008, 2009,
 * 2014 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */uvecport_or_fd/usr/include/guile/2.0/libguile/values.hscm_init_valuesscm_c_value_refscm_c_nvaluesscm_c_valuesscm_valuesscm_i_extract_values_2scm_values_vtableSCM_VALUESP(x)(SCM_STRUCTP (x) && scm_is_eq (scm_struct_vtable (x), scm_values_vtable))SCM_VALUES_H/* SCM_VALUES_H *//* Copyright (C) 2000,2001, 2006, 2008, 2012 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */p1p2/usr/include/guile/2.0/libguile/variable.h"libguile/smob.h"scm_init_variablescm_i_variable_printscm_variable_bound_pscm_variable_unset_xscm_variable_set_xscm_variable_refscm_variable_pscm_make_undefined_variablescm_make_variableSCM_VARIABLE_LOC(V)(SCM_CELL_OBJECT_LOC ((V), 1))SCM_VARIABLE_SET(V,X)SCM_SET_CELL_OBJECT_1 (V, X)SCM_VARIABLE_REF(V)SCM_CELL_OBJECT_1 (V)SCM_VARIABLEP(X)(!SCM_IMP (X) && SCM_TYP7(X) == scm_tc7_variable)SCM_VARIABLE_H/* SCM_VARIABLE_H *//* Variables 
 */var/usr/include/guile/2.0/libguile/srfi-4.hscm_init_srfi_4scm_uniform_element_sizescm_i_uniform_vector_set_procscm_i_uniform_vector_ref_procscm_i_uniform_vector_tagscm_i_generalized_vector_typedouble *scm_c64vector_writable_elementsconst doubleconst double *scm_c64vector_elementsscm_array_handle_c64_writable_elementsscm_array_handle_c64_elementsscm_any_to_c64vectorscm_list_to_c64vectorscm_c64vector_to_listscm_c64vector_set_xscm_c64vector_refscm_c64vector_lengthscm_c64vectorscm_take_c64vectorscm_make_c64vectorscm_c64vector_pfloat *scm_c32vector_writable_elementsconst floatconst float *scm_c32vector_elementsscm_array_handle_c32_writable_elementsscm_array_handle_c32_elementsscm_any_to_c32vectorscm_list_to_c32vectorscm_c32vector_to_listscm_c32vector_set_xscm_c32vector_refscm_c32vector_lengthscm_c32vectorscm_take_c32vectorscm_make_c32vectorscm_c32vector_pscm_f64vector_writable_elementsscm_f64vector_elementsscm_array_handle_f64_writable_elementsscm_array_handle_f64_elementsscm_any_to_f64vectorscm_list_to_f64vectorscm_f64vector_to_listscm_f64vector_set_xscm_f64vector_refscm_f64vector_lengthscm_f64vectorscm_take_f64vectorscm_make_f64vectorscm_f64vector_pscm_f32vector_writable_elementsscm_f32vector_elementsscm_array_handle_f32_writable_elementsscm_array_handle_f32_elementsscm_any_to_f32vectorscm_list_to_f32vectorscm_f32vector_to_listscm_f32vector_set_xscm_f32vector_refscm_f32vector_lengthscm_f32vectorscm_take_f32vectorscm_make_f32vectorscm_f32vector_pscm_t_int64 *scm_s64vector_writable_elementsconst scm_t_int64const scm_t_int64 *scm_s64vector_elementsscm_array_handle_s64_writable_elementsscm_array_handle_s64_elementsscm_take_s64vectorscm_any_to_s64vectorscm_list_to_s64vectorscm_s64vector_to_listscm_s64vector_set_xscm_s64vector_refscm_s64vector_lengthscm_s64vectorscm_make_s64vectorscm_s64vector_pscm_t_uint64 *scm_u64vector_writable_elementsconst scm_t_uint64const scm_t_uint64 *scm_u64vector_elementsscm_array_handle_u64_writable_elementsscm_array_handle_u64_elementsscm_take_u64vectorscm_any_to_u64vectorscm_list_to_u64vectorscm_u64vector_to_listscm_u64vector_set_xscm_u64vector_refscm_u64vector_lengthscm_u64vectorscm_make_u64vectorscm_u64vector_pscm_t_int32 *scm_s32vector_writable_elementsconst scm_t_int32const scm_t_int32 *scm_s32vector_elementsscm_array_handle_s32_writable_elementsscm_array_handle_s32_elementsscm_any_to_s32vectorscm_list_to_s32vectorscm_s32vector_to_listscm_s32vector_set_xscm_s32vector_refscm_s32vector_lengthscm_s32vectorscm_take_s32vectorscm_make_s32vectorscm_s32vector_pscm_u32vector_writable_elementsscm_u32vector_elementsscm_array_handle_u32_writable_elementsscm_array_handle_u32_elementsscm_any_to_u32vectorscm_list_to_u32vectorscm_u32vector_to_listscm_u32vector_set_xscm_u32vector_refscm_u32vector_lengthscm_u32vectorscm_take_u32vectorscm_make_u32vectorscm_u32vector_pscm_t_int16 *signed short *scm_s16vector_writable_elementsconst scm_t_int16const scm_t_int16 *scm_s16vector_elementsscm_array_handle_s16_writable_elementsscm_array_handle_s16_elementsscm_any_to_s16vectorscm_list_to_s16vectorscm_s16vector_to_listscm_s16vector_set_xscm_s16vector_refscm_s16vector_lengthscm_s16vectorscm_take_s16vectorscm_make_s16vectorscm_s16vector_pscm_t_uint16 *unsigned short *scm_u16vector_writable_elementsconst scm_t_uint16const scm_t_uint16 *scm_u16vector_elementsscm_array_handle_u16_writable_elementsscm_array_handle_u16_elementsscm_any_to_u16vectorscm_list_to_u16vectorscm_u16vector_to_listscm_u16vector_set_xscm_u16vector_refscm_u16vector_lengthscm_u16vectorscm_take_u16vectorscm_make_u16vectorscm_u16vector_pscm_t_int8 *scm_s8vector_writable_elementsconst scm_t_int8const scm_t_int8 *scm_s8vector_elementsscm_array_handle_s8_writable_elementsscm_array_handle_s8_elementsscm_any_to_s8vectorscm_list_to_s8vectorscm_s8vector_to_listscm_s8vector_set_xscm_s8vector_refscm_s8vector_lengthscm_s8vectorscm_take_s8vectorscm_make_s8vectorscm_s8vector_pscm_t_uint8 *scm_u8vector_writable_elementsconst scm_t_uint8const scm_t_uint8 *scm_u8vector_elementsscm_array_handle_u8_writable_elementsscm_array_handle_u8_elementsscm_any_to_u8vectorscm_list_to_u8vectorscm_u8vector_to_listscm_u8vector_set_xscm_u8vector_refscm_u8vector_lengthscm_u8vectorscm_take_u8vectorscm_make_u8vectorscm_u8vector_pscm_make_srfi_4_vectorSCM_SRFI_4_H/* SCM_SRFI_4_H *//* Deprecated because we want people to use the scm_t_array_handle
   interface.
*//* Specific procedures.
 *//* srfi-4.c --- Homogeneous numeric vector datatypes.
 *
 * 	Copyright (C) 2001, 2004, 2006, 2008, 2009, 2010 Free Software Foundation, Inc.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/version.hscm_init_versionscm_versionscm_effective_versionscm_micro_versionscm_minor_versionscm_major_versionSCM_EFFECTIVE_VERSION"2.0"SCM_MICRO_VERSIONSCM_MINOR_VERSIONSCM_MAJOR_VERSIONSCM_VERSION_H/*
  Local Variables:
  c-file-style: "gnu"
  mode: c
  End:
*//* SCM_VERSION_H *//* Copyright (C) 1995,1996,1998,1999,2000,2001, 2006, 2008, 2010 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/vports.hscm_init_vportsscm_make_soft_portSCM_VPORTS_H/* SCM_VPORTS_H */pv/usr/include/guile/2.0/libguile/backtrace.hscm_init_backtracescm_backtrace_with_highlightsscm_backtracescm_display_backtrace_with_highlightsscm_display_backtracescm_display_applicationscm_display_errorscm_i_display_errorscm_display_error_messagescm_print_exceptionSCM_BACKTRACE_H/* SCM_BACKTRACE_H *//* Copyright (C) 1996,1998,1999,2000,2001, 2004, 2006, 2008, 2010, 2011 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */highlightsframeindent/usr/include/guile/2.0/libguile.hSCM_LIBGUILE_H/* SCM_LIBGUILE_H *//* This needs to be included outside of the extern "C" block.
 *//* Copyright (C) 1995,1996,1997,1998,2000,2001, 2002, 2003, 2004, 2006, 2008, 2009, 2010, 2011, 2012, 2014 Free Software Foundation, Inc.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/objcodes.h<libguile.h>scm_init_objcodesscm_bootstrap_objcodesscm_i_objcode_printscm_write_objcodescm_objcode_to_bytecodescm_bytecode_to_native_objcodescm_bytecode_to_objcodescm_objcode_metascm_objcode_pscm_load_objcodescm_c_make_objcode_slicescm_objcodemetalenSCM_SET_OBJCODE_NATIVE_CODE(x,code)(SCM_SET_CELL_WORD_3 (x, code))SCM_OBJCODE_NATIVE_CODE(x)(SCM_CELL_WORD_3 (x))SCM_OBJCODE_IS_STATIC(x)(SCM_OBJCODE_TYPE (x) == SCM_OBJCODE_TYPE_STATIC)SCM_OBJCODE_IS_SLICE(x)(SCM_OBJCODE_TYPE (x) == SCM_OBJCODE_TYPE_SLICE)SCM_OBJCODE_IS_BYTEVECTOR(x)(SCM_OBJCODE_TYPE (x) == SCM_OBJCODE_TYPE_BYTEVECTOR)SCM_OBJCODE_IS_MMAP(x)(SCM_OBJCODE_TYPE (x) == SCM_OBJCODE_TYPE_MMAP)SCM_OBJCODE_FLAGS(x)(SCM_CELL_WORD_0 (x) >> 16)SCM_OBJCODE_TYPE(x)((SCM_CELL_WORD_0 (x) >> 8) & 0xff)SCM_MAKE_OBJCODE_TAG(type,flags)(scm_tc7_objcode | (type << 8) | (flags << 16))SCM_OBJCODE_BASE(x)(SCM_C_OBJCODE_BASE (SCM_OBJCODE_DATA (x)))SCM_OBJCODE_TOTAL_LEN(x)(SCM_OBJCODE_LEN (x) + SCM_OBJCODE_META_LEN (x))SCM_OBJCODE_META_LEN(x)(SCM_OBJCODE_DATA (x)->metalen)SCM_OBJCODE_LEN(x)(SCM_OBJCODE_DATA (x)->len)SCM_VALIDATE_OBJCODE(p,x)SCM_MAKE_VALIDATE (p, x, OBJCODE_P)SCM_OBJCODE_DATA(x)((struct scm_objcode *) SCM_CELL_WORD_1 (x))SCM_OBJCODE_P(x)(SCM_NIMP (x) && SCM_TYP7 (x) == scm_tc7_objcode)SCM_OBJCODE_TYPE_STATICSCM_OBJCODE_TYPE_SLICESCM_OBJCODE_TYPE_BYTEVECTORSCM_OBJCODE_TYPE_MMAPSCM_C_OBJCODE_BASE(obj)((scm_t_uint8 *)(obj) + sizeof (struct scm_objcode))_SCM_OBJCODES_H_/* _SCM_OBJCODES_H_ *//* Return a pointer to the base of objcode OBJ.  *//* In C99, we'd have:
     scm_t_uint8 base[];  *//* well, i lie. this many bytes at the end of
                                   base[] for metadata *//* the maximum index of base[] *//* Objcode data should be directly mappable to this C structure.  *//* Copyright (C) 2001, 2009, 2010, 2011 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */objcodebytecode/usr/include/guile/2.0/libguile/programs.h<libguile/objcodes.h>scm_init_programsscm_bootstrap_programsscm_i_program_printscm_i_program_arityscm_i_program_propertiesscm_program_objcodescm_program_free_variable_set_xscm_program_free_variable_refscm_program_num_free_variablesscm_program_modulescm_program_objectsscm_program_aritiesscm_program_sourcescm_program_sourcesscm_program_bindingsscm_program_metascm_program_basescm_program_pscm_make_programSCM_PROGRAM_IS_PARTIAL_CONTINUATION(x)(SCM_CELL_WORD_0 (x) & SCM_F_PROGRAM_IS_PARTIAL_CONTINUATION)SCM_PROGRAM_IS_CONTINUATION(x)(SCM_CELL_WORD_0 (x) & SCM_F_PROGRAM_IS_CONTINUATION)SCM_PROGRAM_IS_PRIMITIVE_GENERIC(x)(SCM_CELL_WORD_0 (x) & SCM_F_PROGRAM_IS_PRIMITIVE_GENERIC)SCM_PROGRAM_IS_PRIMITIVE(x)(SCM_CELL_WORD_0 (x) & SCM_F_PROGRAM_IS_PRIMITIVE)SCM_PROGRAM_IS_BOOT(x)(SCM_CELL_WORD_0 (x) & SCM_F_PROGRAM_IS_BOOT)SCM_VALIDATE_PROGRAM(p,x)SCM_MAKE_VALIDATE (p, x, PROGRAM_P)SCM_PROGRAM_DATA(x)(SCM_OBJCODE_DATA (SCM_PROGRAM_OBJCODE (x)))SCM_PROGRAM_NUM_FREE_VARIABLES(x)SCM_PROGRAM_FREE_VARIABLE_SET(x,i,v)(SCM_PROGRAM_FREE_VARIABLES (x)[i]=(v))SCM_PROGRAM_FREE_VARIABLE_REF(x,i)(SCM_PROGRAM_FREE_VARIABLES (x)[i])SCM_PROGRAM_FREE_VARIABLES(x)(SCM_CELL_OBJECT_LOC (x, 3))SCM_PROGRAM_OBJTABLE(x)SCM_PROGRAM_OBJCODE(x)SCM_PROGRAM_P(x)(!SCM_IMP (x) && SCM_TYP7(x) == scm_tc7_program)SCM_F_PROGRAM_IS_PARTIAL_CONTINUATION0x1000SCM_F_PROGRAM_IS_CONTINUATION0x800SCM_F_PROGRAM_IS_PRIMITIVE_GENERICSCM_F_PROGRAM_IS_PRIMITIVE0x200SCM_F_PROGRAM_IS_BOOT_SCM_PROGRAMS_H_/* _SCM_PROGRAMS_H_ *//*
 * Programs
 *//* Copyright (C) 2001, 2009, 2010, 2013 Free Software Foundation, Inc.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */programipsourcesobjtablefree_variables/usr/include/guile/2.0/libguile/frames.h"programs.h"scm_init_framesscm_i_frame_printscm_frame_previousscm_frame_dynamic_linkscm_frame_mv_return_addressscm_frame_return_addressscm_frame_instruction_pointerscm_frame_stack_pointerscm_frame_addressscm_frame_local_set_xscm_frame_local_refscm_frame_num_localsscm_frame_sourcescm_frame_argumentsscm_frame_procedurescm_frame_pscm_c_make_framescm_framescm_vm_framespfpstack_holderSCM[1]scm_unused_struct *[1]return_addressmv_return_addressdynamic_linkSCM_VALIDATE_VM_FRAME(p,x)SCM_MAKE_VALIDATE (p, x, VM_FRAME_P)SCM_VM_FRAME_OFFSET(f)SCM_VM_FRAME_DATA(f)->offsetSCM_VM_FRAME_IP(f)SCM_VM_FRAME_DATA(f)->ipSCM_VM_FRAME_SP(f)SCM_VM_FRAME_DATA(f)->spSCM_VM_FRAME_FP(f)SCM_VM_FRAME_DATA(f)->fpSCM_VM_FRAME_STACK_HOLDER(f)SCM_VM_FRAME_DATA(f)->stack_holderSCM_VM_FRAME_DATA(x)((struct scm_frame*)SCM_CELL_WORD_1 (x))SCM_VM_FRAME_P(x)(SCM_NIMP (x) && SCM_TYP7 (x) == scm_tc7_frame)SCM_FRAME_PROGRAM(fp)(SCM_FRAME_STRUCT (fp)->program)SCM_FRAME_VARIABLE(fp,i)(SCM_FRAME_STRUCT (fp)->stack[i])SCM_FRAME_SET_DYNAMIC_LINK(fp,dl)SCM_FRAME_DYNAMIC_LINK (fp) = (dl)SCM_FRAME_DYNAMIC_LINK(fp)(SCM_FRAME_STRUCT (fp)->dynamic_link)SCM_FRAME_SET_MV_RETURN_ADDRESS(fp,mvra)SCM_FRAME_STRUCT (fp)->mv_return_address = (mvra)SCM_FRAME_MV_RETURN_ADDRESS(fp)(SCM_FRAME_STRUCT (fp)->mv_return_address)SCM_FRAME_SET_RETURN_ADDRESS(fp,ra)SCM_FRAME_STRUCT (fp)->return_address = (ra)SCM_FRAME_RETURN_ADDRESS(fp)(SCM_FRAME_STRUCT (fp)->return_address)SCM_FRAME_STACK_CAST(x)((SCM *) SCM_UNPACK (x))SCM_FRAME_BYTE_CAST(x)((scm_t_uint8 *) SCM_UNPACK (x))SCM_FRAME_LOWER_ADDRESS(fp)((SCM*)SCM_FRAME_STRUCT (fp))SCM_FRAME_UPPER_ADDRESS(fp)((SCM*)&SCM_FRAME_STRUCT (fp)->return_address)SCM_FRAME_STACK_ADDRESS(fp)(SCM_FRAME_STRUCT (fp)->stack)SCM_FRAME_DATA_ADDRESS(fp)(((SCM *) (fp)) - 4)SCM_FRAME_STRUCT(fp)((struct scm_vm_frame *) SCM_FRAME_DATA_ADDRESS (fp))_SCM_FRAMES_H_/* _SCM_FRAMES_H_ *//*
 * Heap frames
 *//* Variable-length *//* This structure maps to the contents of a VM stack frame.  It can
   alias a frame directly.  *//* VM Frame Layout
   ---------------

   | ...              |
   | Intermed. val. 0 | <- fp + nargs + nlocs
   +------------------+    
   | Local variable 1 |
   | Local variable 0 | <- fp + nargs
   | Argument 1       |
   | Argument 0       | <- fp = SCM_FRAME_STACK_ADDRESS (fp)
   | Program          | <- fp - 1
   +==================+
   | Return address   | <- SCM_FRAME_UPPER_ADDRESS (fp)
   | MV return address|
   | Dynamic link     | <- fp - 4 = SCM_FRAME_DATA_ADDRESS (fp) = SCM_FRAME_LOWER_ADDRESS (fp)
   +==================+
   |                  |

   As can be inferred from this drawing, it is assumed that
   `sizeof (SCM *) == sizeof (SCM)', since pointers (the `link' parts) are
   assumed to be as long as SCM objects.  *//*
 * It's a little confusing, but there are two representations of frames in this
 * file: frame pointers and Scheme objects wrapping those frame pointers. The
 * former uses the SCM_FRAME_... macro prefix, the latter SCM_VM_FRAME_..
 * prefix.
 *
 * The confusing thing is that only Scheme frame objects have functions that use
 * them, and they use the scm_frame_.. prefix. Hysterical raisins.
 *//*
 * VM frames
 *//* Copyright (C) 2001, 2009, 2010, 2011 Free Software Foundation, Inc.
 * * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/stacks.h"libguile/frames.h"scm_init_stacksscm_stack_lengthscm_stack_refscm_stack_idscm_make_stackscm_stack_pscm_stack_typeSCM_FRAMEP(obj)(SCM_VM_FRAME_P (obj))SCM_SET_STACK_FRAME(obj,f)(SCM_STRUCT_SLOT_SET (obj,2,f))SCM_STACK_FRAME(obj)(SCM_STRUCT_SLOT_REF (obj,2))SCM_SET_STACK_ID(obj,f)(SCM_STRUCT_SLOT_SET (obj,1,f))SCM_STACK_ID(obj)(SCM_STRUCT_SLOT_REF (obj,1))SCM_SET_STACK_LENGTH(obj,f)(SCM_STRUCT_SLOT_SET (obj,0,scm_from_long (f)))SCM_STACK_LENGTH(obj)(scm_to_long (SCM_STRUCT_SLOT_REF (obj,0)))SCM_STACKP(obj)(SCM_STRUCTP (obj) && scm_is_eq (SCM_STRUCT_VTABLE (obj), scm_stack_type))SCM_STACK_LAYOUT"pw" "pw" "pw"SCM_STACKS_H/* SCM_STACKS_H *//* frame *//* id *//* len *//* {Frames and stacks}
 *//* Copyright (C) 1995,1996,2000,2001, 2004, 2006, 2008 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//usr/include/guile/2.0/libguile/inline.h"libguile/gc.h""libguile/pairs.h"<string.h>scm_putsSCM_OPOUTPORTP (port)(!(6 & ((scm_t_bits) (0? (*(volatile SCM *)0=(port)): port))) && (((0x7f | (1L<<16) | (4L<<16)) & ((((scm_t_bits) (0? (*(volatile SCM *)0=((((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=((((port))))): (((port)))))))) [((0))]))): (((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=((((port))))): (((port)))))))) [((0))]))))))==(125 | (1L<<16) | (4L<<16))))"output port"!((!(6 & ((scm_t_bits) (0? (*(volatile SCM *)0=(port)): port))) && (((0x7f | (1L<<16) | (4L<<16)) & ((((scm_t_bits) (0? (*(volatile SCM *)0=((((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=((((port))))): (((port)))))))) [((0))]))): (((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=((((port))))): (((port)))))))) [((0))]))))))==(125 | (1L<<16) | (4L<<16)))))6553665663262144327807(port)((port))SCM_GC_CELL_OBJECT ((((port))), ((0)))(((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=((((port))))): (((port)))))))) [((0))])(((port)))((0))SCM_GC_CELL_WORD (((port)), (0))(((scm_t_bits) (0? (*(volatile SCM *)0=((((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=((((port))))): (((port)))))))) [((0))]))): (((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=((((port))))): (((port)))))))) [((0))]))))65661327805output portchar[12]scm_putcscm_peek_byte_or_eofSCM_GC_CELL_WORD (((port)), (1))(((scm_t_bits) (0? (*(volatile SCM *)0=((((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=((((port))))): (((port)))))))) [((1))]))): (((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=((((port))))): (((port)))))))) [((1))]))))SCM_GC_CELL_OBJECT ((((port))), ((1)))(((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=((((port))))): (((port)))))))) [((1))])((1))(pt->rw_active == SCM_PORT_READ || !pt->rw_random) && pt->read_pos < pt->read_endscm_get_byte_or_eofscm_is_string(x)((x))SCM_GC_CELL_WORD (((x)), (0))(((scm_t_bits) (0? (*(volatile SCM *)0=((((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=((((x))))): (((x)))))))) [((0))]))): (((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=((((x))))): (((x)))))))) [((0))]))))SCM_GC_CELL_OBJECT ((((x))), ((0)))(((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=((((x))))): (((x)))))))) [((0))])(((x)))scm_is_pairSCM_INLINE_Hdefined (__GNUC__) && __GNUC__ == 2 && __GNUC_MINOR__ == 95/* Like `scm_get_byte_or_eof' but does not change PORT's `read_pos'.  *//* Port I/O.  *//* The following "workaround_for_gcc_295" avoids bad code generated by
     i386 gcc 2.95.4 (the Debian packaged 2.95.4-24 at least).

     Under the default -O2 the inlined SCM_I_CONSP test gets "optimized" so
     the fetch of the tag word from x is done before confirming it's a
     non-immediate (SCM_NIMP).  Needless to say that bombs badly if x is a
     immediate.  This was seen to afflict scm_srfi1_split_at and something
     deep in the bowels of ceval().  In both cases segvs resulted from
     deferencing a random immediate value.  srfi-1.test exposes the problem
     through a short list, the immediate being SCM_EOL in that case.
     Something in syntax.test exposed the ceval() problem.

     Just "volatile SCM workaround_for_gcc_295 = lst" is enough to avoid the
     problem, without even using that variable.  The "w=w" is just to
     prevent a warning about it being unused.
     *//* This file is for inline functions.  On platforms that don't support
   inlining functions, they are turned into ordinary functions.  On
   platforms that do support inline functions, the definitions are still
   compiled into the library, once, in inline.c.  *//* Copyright (C) 2001, 2002, 2003, 2004, 2006, 2008, 2009, 2010,
 *   2011, 2013 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 */str_data/usr/include/guile/2.0/libguile/deprecated.h"libguile/eval.h"scm_i_init_deprecatedscm_ntohlscm_htonlscm_ntohsscm_htonsscm_gc_live_object_statsscm_c_program_sourcescm_generalized_vector_to_listscm_generalized_vector_set_xscm_generalized_vector_refscm_generalized_vector_lengthscm_generalized_vector_pscm_struct_vtable_tagscm_eval_closure_modulescm_standard_interface_eval_closurescm_standard_eval_closurescm_eval_closure_lookupscm_current_module_lookup_closurescm_module_lookup_closurescm_lookup_closure_modulescm_sym2varscm_i_deprecated_asrtgoscm_immutable_double_cellscm_immutable_cellscm_struct_create_handlescm_whash_insertscm_whash_lookupscm_whash_create_handleSCM_WHASHSETSCM_WHASHREFSCM_WHASHFOUNDPscm_whash_get_handlescm_primitive_property_del_xscm_primitive_property_set_xscm_primitive_property_refscm_primitive_make_propertyscm_cuseridscm_internal_selectscm_thread_usleepscm_thread_sleepscm_c_make_keywordscm_keyword_dash_symbolscm_make_keyword_from_dash_symbolscm_allocate_stringscm_makfrom0str_optscm_makfrom0strscm_str2stringscm_mem2stringscm_take0strscm_take_strscm_str2symbolscm_mem2uninterned_symbolscm_mem2symbolscm_make_complexscm_num2doublescm_num2floatscm_double2numscm_float2numscm_num2dblscm_make_realscm_num2ulong_longscm_num2long_longscm_ulong_long2numscm_long_long2numscm_num2sizescm_num2ptrdiffscm_num2ulongscm_num2longscm_num2uintscm_num2intscm_num2ushortscm_num2shortscm_ptrdiff2numscm_size2numscm_ulong2numscm_long2numscm_uint2numscm_int2numscm_ushort2numscm_short2numscm_internal_stack_catchscm_badargspscm_dynamic_args_callscm_raequalscm_internal_lazy_catchscm_lazy_catchscm_i_subr_pscm_trampoline_2scm_trampoline_1scm_trampoline_0scm_guardian_destroyed_pscm_guardian_greedy_pscm_destroy_guardian_xscm_get_one_zombiescm_guardscm_i_mask_intsscm_i_defer_ints_etcscm_i_fluidpscm_i_stack_basescm_i_deprecated_dynwindsscm_i_progargsscm_i_cur_loadpscm_i_cur_errpscm_i_cur_outpscm_i_cur_inpscm_uniform_array_writescm_uniform_array_read_xscm_i_array_dimsscm_i_array_basescm_i_array_vscm_t_array *scm_i_t_array *scm_i_array_memscm_i_array_contpscm_i_array_ndimscm_i_arraypscm_vector_equal_pscm_i_vector_setscm_i_vector_refscm_i_writable_veltsscm_i_veltsscm_i_vector_lengthscm_i_vectorpscm_i_keywordsymscm_i_keywordpscm_i_deprecated_symbol_lengthscm_i_deprecated_symbol_charsscm_sys_atan2scm_atanhscm_acoshscm_asinhscm_sys_exptscm_roundscm_truncatescm_c_symbol2strscm_c_substring2strscm_c_string2strscm_i_inumscm_i_inumpscm_i_makinumscm_gentempscm_symbol_set_xscm_symbol_bound_pscm_symbol_bindingscm_unintern_symbolscm_intern_symbolscm_string_to_obarray_symbolscm_symbol_value0scm_intern_obarrayscm_intern_obarray_softscm_sym2ovcellscm_sym2ovcell_softscm_i_object_lengthscm_i_object_charsscm_eval_0strscm_read_0strscm_strprint_objscm_smob_freescm_set_smob_mfpescm_make_smob_type_mfpescm_call_catching_errorsscm_read_and_eval_xscm_sloppy_memberscm_sloppy_memvscm_sloppy_memqscm_internal_dynamic_windscm_create_hookscm_make_gsubr_with_genericscm_make_gsubrscm_internal_with_fluidsscm_builtin_variablescm_variable_set_name_hintscm_makfromstrscm_makstrscm_close_all_ports_exceptscm_load_scheme_modulescm_ensure_user_modulescm_make_modulescm_rememberscm_unprotect_objectscm_protect_objectscm_clear_registered_modulesscm_registered_modulesscm_register_module_xxxscm_wtascm_t_arrayscm_t_innerscm_tc16_eval_closurescm_struct_tablescm_max_segment_sizescm_mtriggerscm_mallocatedscm_isymnamesSCM_CHAR_CODE_LIMIT(UCHAR_MAX + 1L)SCM_EVAL_CLOSURE_P(x)SCM_TYP16_PREDICATE (scm_tc16_eval_closure, x)SCM_TOP_LEVEL_LOOKUP_CLOSURE(scm_current_module_lookup_closure())SCM_ASRTGO(_cond,_label)do { if (!scm_i_deprecated_asrtgo(_cond)) goto _label; } while (0)SCM_SET_STRUCT_TABLE_CLASS(X,CLASS)SCM_SETCDR (X, CLASS)SCM_STRUCT_TABLE_CLASS(X)SCM_CDR (X)SCM_SET_STRUCT_TABLE_NAME(X,NAME)SCM_SETCAR (X, NAME)SCM_STRUCT_TABLE_NAME(X)SCM_CAR (X)scm_whash_handlescm_subr_p(x)(scm_i_subr_p (x))SCM_SETTER(obj)SCM_STRUCT_SETTER (obj, 1)SCM_PROCEDURE(obj)SCM_STRUCT_PROCEDURE (obj, 0)SCM_PROCEDURE_WITH_SETTER_P(obj)(scm_is_true (scm_procedure_with_setter_p (obj)))scm_mask_ints(scm_i_mask_ints ())SCM_REALLOW_INTSscm_i_defer_ints_etc ()SCM_REDEFER_INTSSCM_ALLOW_INTSSCM_DEFER_INTSSCM_FLUIDP(x)scm_i_fluidp (x)scm_stack_basescm_i_stack_base ()scm_dynwindsscm_i_deprecated_dynwinds ()scm_progargsscm_i_progargs ()scm_cur_loadpscm_i_cur_loadp ()scm_cur_errpscm_i_cur_errp ()scm_cur_outpscm_i_cur_outp ()scm_cur_inpscm_i_cur_inp ()SCM_ARRAY_DIMS(a)scm_i_array_dims(a)SCM_ARRAY_BASE(a)scm_i_array_base(a)SCM_ARRAY_V(a)scm_i_array_v(a)SCM_ARRAY_MEM(a)scm_i_array_mem(a)SCM_ARRAY_CONTP(a)scm_i_array_contp(a)SCM_ARRAY_NDIM(a)scm_i_array_ndim(a)SCM_ARRAYP(a)scm_i_arrayp(a)SCM_VECTOR_SET(x,y,z)scm_i_vector_set(x,y,z)SCM_VECTOR_REF(x,y)scm_i_vector_ref(x,y)SCM_WRITABLE_VELTS(x)scm_i_writable_velts(x)SCM_VELTS(x)scm_i_velts(x)SCM_VECTOR_LENGTH(x)scm_i_vector_length(x)SCM_VECTORP(x)scm_i_vectorp(x)SCM_VECTOR_MAX_LENGTH((1L << 24) - 1)SCM_KEYWORDSYM(x)scm_i_keywordsym(x)SCM_KEYWORDP(x)scm_i_keywordp(x)SCM_SYMBOL_LENGTH(x)scm_i_deprecated_symbol_length(x)SCM_SYMBOL_CHARS(x)scm_i_deprecated_symbol_chars(x)SCM_VALIDATE_SUBSTRING_SPEC_COPY(pos_str,str,c_str,pos_start,start,c_start,pos_end,end,c_end)do { SCM_VALIDATE_STRING_COPY (pos_str, str, c_str); c_start = SCM_UNBNDP(start)? 0 : scm_to_size_t (start); c_end = SCM_UNBNDP(end)? SCM_STRING_LENGTH(str) : scm_to_size_t (end); SCM_ASSERT_RANGE (pos_start, start, 0 <= c_start && (size_t) c_start <= SCM_STRING_LENGTH (str)); SCM_ASSERT_RANGE (pos_end, end, c_start <= c_end && (size_t) c_end <= SCM_STRING_LENGTH (str)); } while (0)SCM_VALIDATE_STRING_COPY(pos,str,cvar)do { SCM_ASSERT (SCM_STRINGP (str), str, pos, FUNC_NAME); cvar = SCM_STRING_CHARS(str); } while (0)SCM_STRING_COERCE_0TERMINATION_X(x)SCM_VALIDATE_INUM_RANGE_COPY(pos,k,low,high,cvar)do { SCM_ASSERT (SCM_INUMP (k), k, pos, FUNC_NAME); SCM_ASSERT_RANGE (pos, k, low <= SCM_INUM (k) && SCM_INUM (k) < high); cvar = SCM_INUM (k); } while (0)SCM_VALIDATE_INUM_RANGE(pos,k,low,high)do { SCM_ASSERT(SCM_I_INUMP(k), k, pos, FUNC_NAME); SCM_ASSERT_RANGE(pos, k, (SCM_I_INUM (k) >= low && SCM_I_INUM (k) < high)); } while (0)SCM_VALIDATE_INUM_DEF_COPY(pos,k,default,cvar)do { if (SCM_UNBNDP (k)) { k = SCM_I_MAKINUM (default); cvar = default; } else { SCM_ASSERT (SCM_I_INUMP (k), k, pos, FUNC_NAME); cvar = SCM_INUM (k); } } while (0)SCM_VALIDATE_INUM_DEF(pos,k,default)do { if (SCM_UNBNDP (k)) k = SCM_I_MAKINUM (default); else SCM_ASSERT (SCM_I_INUMP (k), k, pos, FUNC_NAME); } while (0)SCM_VALIDATE_INUM_MIN_DEF_COPY(pos,k,min,default,cvar)do { if (SCM_UNBNDP (k)) k = SCM_I_MAKINUM (default); SCM_ASSERT (SCM_I_INUMP (k), k, pos, FUNC_NAME); SCM_ASSERT_RANGE (pos, k, (SCM_I_INUM (k) >= min)); cvar = SCM_INUM (k); } while (0)SCM_VALIDATE_INUM_MIN_COPY(pos,k,min,cvar)do { SCM_ASSERT (SCM_I_INUMP (k), k, pos, FUNC_NAME); SCM_ASSERT_RANGE (pos, k, (SCM_I_INUM (k) >= min)); cvar = SCM_INUM (k); } while (0)SCM_VALIDATE_INUM_MIN(pos,k,min)do { SCM_ASSERT (SCM_I_INUMP(k), k, pos, FUNC_NAME); SCM_ASSERT_RANGE (pos, k, (SCM_I_INUM (k) >= min)); } while (0)SCM_VALIDATE_BIGINT(pos,k)SCM_MAKE_VALIDATE_MSG (pos, k, BIGP, "bignum")SCM_VALIDATE_INUM_COPY(pos,k,cvar)do { SCM_ASSERT (SCM_I_INUMP (k), k, pos, FUNC_NAME); cvar = SCM_I_INUM (k); } while (0)SCM_VALIDATE_INUM(pos,k)SCM_MAKE_VALIDATE_MSG (pos, k, INUMP, "exact integer")SCM_NINUMP(x)(!SCM_INUMP(x))SCM_INUMP(x)scm_i_inump(x)SCM_INUM(x)scm_i_inum(x)SCM_MAKINUM(x)scm_i_makinum(x)SCM_CELL_WORD_LOC(x,n)((scm_t_bits*)SCM_CELL_OBJECT_LOC((x),(n)))SCM_VALIDATE_OPDIR(pos,port)SCM_MAKE_VALIDATE (pos, port, OPDIRP)SCM_VALIDATE_NUMBER_DEF_COPY(pos,number,def,cvar)do { if (SCM_UNBNDP (number)) cvar = def; else SCM_VALIDATE_NUMBER_COPY(pos, number, cvar); } while (0)SCM_VALIDATE_NUMBER_COPY(pos,z,cvar)do { if (SCM_I_INUMP (z)) cvar = (double) SCM_I_INUM (z); else if (SCM_REALP (z)) cvar = SCM_REAL_VALUE (z); else if (SCM_BIGP (z)) cvar = scm_i_big2dbl (z); else { cvar = 0.0; SCM_WRONG_TYPE_ARG (pos, z); } } while (0)RETURN_SCM_WTA(pos,scm)do { return scm_wta (scm, (char *) pos, FUNC_NAME); } while (0)SCM_WTA(pos,scm)do { scm_wta (scm, (char *) pos, FUNC_NAME); } while (0)SCM_FUNC_NAME(scm_makfrom0str (FUNC_NAME))scm_array_dimscm_arrayscm_srcprops_chunkscm_t_srcprops_chunkscm_srcpropsscm_t_srcpropsscm_optionscm_fportSCM_OPDIRP(x)(SCM_DIRP (x) && (SCM_DIR_OPEN_P (x)))scm_strhash(str,len,n)(scm_string_hash ((str), (len)) % (n))SCM_LENGTH(x)scm_i_object_length(x)SCM_UCHARS(x)((unsigned char *)SCM_CHARS(x))SCM_CHARS(x)scm_i_object_chars(x)SCM_SUBR_DOC(x)scm_subr_entryscm_t_subr_entryscm_listifySCM_LIST9(e0,e1,e2,e3,e4,e5,e6,e7,e8)scm_cons ((e0), SCM_LIST8 ((e1), (e2), (e3), (e4), (e5), (e6), (e7), (e8)))SCM_LIST8(e0,e1,e2,e3,e4,e5,e6,e7)scm_cons2 ((e0), (e1), SCM_LIST6 ((e2), (e3), (e4), (e5), (e6), (e7)))SCM_LIST7(e0,e1,e2,e3,e4,e5,e6)scm_cons ((e0), SCM_LIST6 ((e1), (e2), (e3), (e4), (e5), (e6)))SCM_LIST6(e0,e1,e2,e3,e4,e5)scm_cons2 ((e0), (e1), SCM_LIST4 ((e2), (e3), (e4), (e5)))SCM_LIST5(e0,e1,e2,e3,e4)scm_cons ((e0), SCM_LIST4 ((e1), (e2), (e3), (e4)))SCM_LIST4(e0,e1,e2,e3)scm_cons2 ((e0), (e1), SCM_LIST2 ((e2), (e3)))SCM_LIST3(e0,e1,e2)scm_cons ((e0), SCM_LIST2 ((e1), (e2)))SCM_LIST2(e0,e1)scm_cons2 ((e0), (e1), SCM_EOL)SCM_LIST1(e0)scm_cons ((e0), SCM_EOL)SCM_LIST0scm_tcs_symbolsscm_tc7_msymbolscm_tc7_ssymbolSCM_SLOPPY_NCONSP(x)(!SCM_SLOPPY_CONSP(x))SCM_SLOPPY_CONSP(x)((1 & SCM_CELL_TYPE (x)) == 0)scm_rngscm_rstatescm_port_rw_activescm_ptob_descriptorscm_portSCM_GCCDR(x)SCM_CDR (x)SCM_GCTYP16(x)SCM_TYP16 (x)SCM_NFREEP(x)SCM_FREEP(x)SCM_SETOR_CDR(x,y)(SCM_SETCDR ((x), SCM_PACK (SCM_UNPACK (SCM_CDR (x)) | (y))))SCM_SETAND_CDR(x,y)(SCM_SETCDR ((x), SCM_PACK (SCM_UNPACK (SCM_CDR (x)) & (y))))SCM_SETOR_CAR(x,y)(SCM_SETCAR ((x), SCM_PACK (SCM_UNPACK (SCM_CAR (x)) | (y))))SCM_SETAND_CAR(x,y)(SCM_SETCAR ((x), SCM_PACK (SCM_UNPACK (SCM_CAR (x)) & (y))))SCM_NALLOCSCM_OUTOFRANGESCM_WNAscm_sizetsize_tscm_substring_move_right_xscm_substring_move_left_xSCM_SET_VTABLE_DESTRUCTOR(X,D)(SCM_STRUCT_DATA(x)[scm_struct_i_free]=(scm_t_bits)(D))SCM_STRUCTF_MASK((scm_t_bits)-1)scm_struct_i_flagsscm_struct_i_freescm_vtable_index_printerscm_vtable_index_vtableSCM_SLOPPY_COMPLEXP(x)(SCM_TYP16 (x) == scm_tc16_complex)SCM_SLOPPY_REALP(x)(SCM_TYP16 (x) == scm_tc16_real)SCM_SLOPPY_INEXACTP(x)(SCM_TYP16S (x) == scm_tc16_real)SCM_TYP16S(x)(0xfeff & SCM_CELL_TYPE (x))SCM_ISYMCHARS(n)"#@<deprecated>"SCM_ISYMNUM(n)SCM_ICDRP(n)(SCM_ICDR & SCM_UNPACK (n))SCM_IDIST(n)(SCM_UNPACK (n) >> 20)SCM_IFRAME(n)((long)((SCM_ICDR-SCM_IFRINC)>>8) & (SCM_UNPACK (n) >> 8))SCM_ICDR(0x00080000L)SCM_IFRINC(0x00000100L)SCM_DEPRECATED_Hdefined (GUILE_DEBUG) || defined (GUILE_DEBUG_FREELIST)defined (GUILE_DEBUG_FREELIST)SCM_SIZEOF_LONG_LONG != 0UCHAR_MAX/* SCM_DEPRECATED_H *//* Eval closure deprecation, 23-05-2012.  *//* Deprecated 23-05-2012, as as it's undocumented, poorly named, and
   adequately replaced by scm_module_variable /
   scm_ensure_module_variable / scm_define / scm_module_define.  *//* Deprecated 08-01-2012, as it's undocumented and unused.  *//* Deprecated 26-05-2011, as the GC_STUBBORN API doesn't do anything any
   more.  *//* No need for a table for names, and the struct->class mapping is
   maintained by GOOPS now.  *//* {The old whash table interface}
 * Deprecated, as the hash table interface is sufficient, and accessing
 * handles of weak hash tables is no longer supported.
 *//* Deprecated because it's yet another property interface.
 *//* Deprecated because the cuserid call is deprecated.
 *//* Discouraged because it does not state what encoding S is in.
 *//* Discouraged because they are just strange.
 *//* Discouraged because scm_c_make_string has a better name and is more
   consistent with make-string.
 *//* Discouraged because they don't make the encoding explicit.
 *//* The next two are implemented in numbers.c since they use features
   only available there.
*//* scm_to_int, scm_from_int are the official functions to do the job,
   but there is nothing wrong with using scm_num2int, etc.

   These could be trivially defined via macros, but we leave them as
   functions since existing code may take their addresses.
*//* These functions were "discouraged" in 1.8, and now are deprecated. *//* Deprecated 2010-06-19, use call-with-error-handling instead *//* Deprecated 2010-05-12, no replacement *//* Deprecated 2010-04-01, use the dynamic FFI instead *//* Deprecated 2010-03-31, use array-equal? instead *//* Deprecated 2010-01-31, use with-throw-handler instead *//* Deprecated 2010-01-05, use SCM_PRIMITIVE_P instead *//* Deprecated 2009-12-06, use the procedures instead *//* Deprecated 2009-11-27, scm_call_N is sufficient *//* GC-related things deprecated with the move to BDW-GC starting from 1.9.3
   (2009-09-15).  *//* Deprecated since guardians no longer have these special features.
 *//* Deprecated since they are unnecessary and had not been documented.
 *//* In the old days (pre-1.8), this macro was sometimes used as an lvalue as
   in "scm_mask_ints = 1" to block async execution.  It no longer works.  *//* In the old days, SCM_CRITICAL_SECTION_START stopped signal handlers
   from running, since in those days the handler directly ran scheme
   code, and that had to be avoided when the heap was not in a
   consistent state etc.  And since the scheme code could do a stack
   swapping new continuation etc, signals had to be deferred around
   various C library functions which were not safe or not known to be
   safe to swap away, which was a lot of stuff.

   These days signals are implemented with asyncs and don't directly
   run scheme code in the handler, but hold it until an SCM_TICK etc
   where it will be safe.  This means interrupt protection is not
   needed and SCM_CRITICAL_SECTION_START / SCM_CRITICAL_SECTION_END is
   something of an anachronism.

   What past SCM_CRITICAL_SECTION_START usage also did though was
   indicate code that was not reentrant, ie. could not be reentered by
   signal handler code.  The present definitions are a mutex lock,
   affording that reentrancy protection against the new guile 1.8
   free-running posix threads.

   One big problem with the present defintions though is that code which
   throws an error from within a DEFER/ALLOW region will leave the
   defer_mutex locked and hence hang other threads that attempt to enter a
   similar DEFER/ALLOW region.
*//* Deprecated in Guile 1.9.5 on 2009-11-15 because these are IPv4-only
   functions which are deprecated upstream.  *//* Deprecated because it evaluates its argument twice.
 *//* Deprecated because they should not be lvalues and we want people to
   use the official interfaces.
 *//* Deprecated because we don't want to hand out unprotected pointers
   to arrays, vectors, etc. *//* Deprecated because the macros used to evaluate the arguments more
   than once and because the symbol of a keyword now has no dash.
*//* Deprecated because we don't want people to access the internals of
   symbols directly.
*//* validate a string and optional start/end arguments which default to
   0/string-len.  this is unrelated to the old shared substring
   support, so please do not deprecate it :) *//* Deprecated because we don't want people to access the internal
   representation of strings directly.
*//* if your platform doesn't have asinh et al *//* Deprecated, use scm_expt *//* Deprecated because the names belong to what is now
   scm_truncate_number and scm_round_number.
*//* XXX - buggy interface, you don't know how many bytes have been copied.

   Copy LEN characters at START from the Scheme string OBJ to memory
   at STR.  START is an index into OBJ; zero means the beginning of
   the string.  STR has already been allocated by the caller.

   If START + LEN is off the end of OBJ, silently truncate the source
   region to fit the string.  If truncation occurs, the corresponding
   area of STR is left unchanged.  
*//* XXX - buggy interface, STR might not be large enough.

   Converts the given Scheme string OBJ into a C string, containing a copy
   of OBJ's content with a trailing null byte.  If LENP is non-NULL, set
   *LENP to the string's length.

   When STR is non-NULL it receives the copy and is returned by the function,
   otherwise new memory is allocated and the caller is responsible for 
   freeing it via free().  If out of memory, NULL is returned.

   Note that Scheme strings may contain arbitrary data, including null
   characters.  This means that null termination is not a reliable way to 
   determine the length of the returned value.  However, the function always 
   copies the complete contents of OBJ, and sets *LENP to the length of the
   scheme string (if LENP is non-null).  
*//* [low, high) *//* Users shouldn't know about INUMs.
 *//* Deprecated because we can not safely cast a SCM* to a scm_t_bits*
 *//* This name has been reused for real uninterned symbols. *//* Deprecated 13-05-2011 because it's better just to scm_dynwind_begin.
   That also avoids the temptation to stuff pointers in an SCM.  *//* From structs.h:
   Deprecated in Guile 1.9.5 on 2009-11-03. *//* From numbers.h: Macros checking for types, but avoiding a redundant check
 * for !SCM_IMP.  These were deprecated in guile 1.7.0 on 2003-09-06.  *//* From tags.h: Macro checking for two tc16 types that are allocated to differ
 * only in the 's'-bit.  Deprecated in guile 1.7.0 on 2003-09-21.  *//* From tags.h: Macros to access internal symbol names of isyms.  Deprecated
 * in guile 1.7.0 on 2004-04-22.  *//* From eval.h: Macros for handling ilocs.  These were deprecated in guile
 * 1.7.0 on 2004-04-22.  *//* Copyright (C) 2003,2004, 2005, 2006, 2007, 2009, 2010, 2011, 2012, 2013, 2014 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 3 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *//* This file contains definitions for deprecated features.  When you
   deprecate something, move it here when that is feasible.
*/eval_closureeclodefinepconditionwhashpropnot_found_procs_callerwhyslformalsguardianthrow_pobarraysoftpsoftnesserr_filterbeforeinnerafterinner_dataguard_datahintportsinit_funcs_subr"libguile/deprecated.h""libguile/inline.h""libguile/stacks.h""libguile/backtrace.h""libguile/weaks.h""libguile/vports.h""libguile/version.h""libguile/srfi-4.h""libguile/variable.h""libguile/values.h""libguile/uniform.h""libguile/trees.h""libguile/symbols.h""libguile/strports.h""libguile/strorder.h""libguile/srfi-14.h""libguile/srfi-13.h""libguile/stime.h""libguile/stackchk.h""libguile/srcprop.h""libguile/sort.h""libguile/socket.h""libguile/snarf.h""libguile/simpos.h""libguile/script.h""libguile/scmsigs.h""libguile/read.h""libguile/random.h""libguile/r6rs-ports.h""libguile/promises.h""libguile/procprop.h""libguile/posix.h""libguile/objprop.h""libguile/net_db.h""libguile/modules.h""libguile/mallocs.h""libguile/macros.h""libguile/load.h""libguile/list.h""libguile/keywords.h""libguile/rw.h""libguile/rdelim.h""libguile/ioext.h""libguile/init.h""libguile/i18n.h""libguile/hashtab.h""libguile/hash.h""libguile/guardians.h""libguile/gsubr.h""libguile/goops.h""libguile/generalized-arrays.h""libguile/gdbint.h""libguile/fports.h""libguile/foreign.h""libguile/fluids.h""libguile/finalizers.h""libguile/filesys.h""libguile/feature.h""libguile/extensions.h""libguile/evalext.h""libguile/eq.h""libguile/dynl.h""libguile/bytevectors.h""libguile/bitvectors.h""libguile/boolean.h""libguile/async.h""libguile/arrays.h""libguile/array-map.h""libguile/arbiters.h""libguile/alist.h"/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/ag-text.hSCHEME_INIT_TEXT_LINENO434zNil_LENzNil(ag_text_strtable+16319)YYLEX_UNENDING_QUOTE_LENYYLEX_UNENDING_QUOTE(ag_text_strtable+16286)YYLEX_TOKEN_STR_LENYYLEX_TOKEN_STR(ag_text_strtable+16273)YYLEX_ERR_FMT_LEN158YYLEX_ERR_FMT(ag_text_strtable+16114)YYLEX_DF_STR_LENYYLEX_DF_STR(ag_text_strtable+16108)YES_NAME_STR_LENYES_NAME_STR(ag_text_strtable+16104)WORD_FORMAT_LENWORD_FORMAT(ag_text_strtable+16097)WARN_STR_LENWARN_STR(ag_text_strtable+16089)WARN_FMT_LENWARN_FMT(ag_text_strtable+16076)USED_DEFINES_LINE_FMT_LENUSED_DEFINES_LINE_FMT(ag_text_strtable+16072)USED_DEFINES_FMT_LEN97USED_DEFINES_FMT(ag_text_strtable+15974)USAGE_INVAL_DEP_OPT_FMT_LENUSAGE_INVAL_DEP_OPT_FMT(ag_text_strtable+15938)UNAME_CALL_NAME_LENUNAME_CALL_NAME(ag_text_strtable+15929)ULONG_FMT_LENULONG_FMT(ag_text_strtable+794)TRUE_NAME_STR_LENTRUE_NAME_STR(ag_text_strtable+15924)TRACE_XTRACE_MSG_LENTRACE_XTRACE_MSG(ag_text_strtable+15906)TRACE_VER_CONVERT_LENTRACE_VER_CONVERT(ag_text_strtable+15885)TRACE_UNKNOWN_FMT_LENTRACE_UNKNOWN_FMT(ag_text_strtable+15868)TRACE_TRAP_STATE_FMT_LENTRACE_TRAP_STATE_FMT(ag_text_strtable+15852)TRACE_SUSPEND_LENTRACE_SUSPEND(ag_text_strtable+15837)TRACE_START_GUILE_LEN26TRACE_START_GUILE(ag_text_strtable+15521)TRACE_START_FMT_LENTRACE_START_FMT(ag_text_strtable+15807)TRACE_SHELL_STARTS_FMT_LENTRACE_SHELL_STARTS_FMT(ag_text_strtable+15783)TRACE_SHELL_RESULT_MSG_LEN59TRACE_SHELL_RESULT_MSG(ag_text_strtable+15461)TRACE_SHELL_PID_FMT_LENTRACE_SHELL_PID_FMT(ag_text_strtable+15759)TRACE_SHELL_FIRST_START_LENTRACE_SHELL_FIRST_START(ag_text_strtable+15738)TRACE_SEL_MATCH_FULL_LENTRACE_SEL_MATCH_FULL(ag_text_strtable+15429)TRACE_RM_TARG_FILE_FMT_LENTRACE_RM_TARG_FILE_FMT(ag_text_strtable+15714)TRACE_RM_SRC_FILE_FMT_LENTRACE_RM_SRC_FILE_FMT(ag_text_strtable+15690)TRACE_RESUME_LENTRACE_RESUME(ag_text_strtable+15673)TRACE_POP_FMT_LENTRACE_POP_FMT(ag_text_strtable+15664)TRACE_OUT_SWITCH_LEN19TRACE_OUT_SWITCH(ag_text_strtable+15644)TRACE_OUT_PUSH_NEW_LENTRACE_OUT_PUSH_NEW(ag_text_strtable+15624)TRACE_OUT_DELETE_LENTRACE_OUT_DELETE(ag_text_strtable+15597)TRACE_OPEN_OUT_LENTRACE_OPEN_OUT(ag_text_strtable+15580)TRACE_MOVE_FMT_LENTRACE_MOVE_FMT(ag_text_strtable+15567)TRACE_MATCH_VAL_LENTRACE_MATCH_VAL(ag_text_strtable+15548)TRACE_MACRO_FMT_LENTRACE_MACRO_FMT(ag_text_strtable+15399)TRACE_MACRO_DEF_LENTRACE_MACRO_DEF(ag_text_strtable+15372)TRACE_FOR_STEP_TOO_FAR_LEN38TRACE_FOR_STEP_TOO_FAR(ag_text_strtable+15333)TRACE_FOR_BY_STEP_LEN62TRACE_FOR_BY_STEP(ag_text_strtable+15270)TRACE_FN_WHILE_START_LEN41TRACE_FN_WHILE_START(ag_text_strtable+15228)TRACE_FN_WHILE_END_LEN30TRACE_FN_WHILE_END(ag_text_strtable+15197)TRACE_FN_REMAP_INVOKE_LENTRACE_FN_REMAP_INVOKE(ag_text_strtable+15149)TRACE_FN_REMAP_EXPR_LENTRACE_FN_REMAP_EXPR(ag_text_strtable+15144)TRACE_FN_REMAP_BASE_LENTRACE_FN_REMAP_BASE(ag_text_strtable+15130)TRACE_FN_REMAPPED_LEN40TRACE_FN_REMAPPED(ag_text_strtable+15156)TRACE_FN_INC_TPL_LENTRACE_FN_INC_TPL(ag_text_strtable+15108)TRACE_FN_INC_LINE_LENTRACE_FN_INC_LINE(ag_text_strtable+14528)TRACE_FN_IF_NOTHING_LEN33TRACE_FN_IF_NOTHING(ag_text_strtable+15074)TRACE_FN_IF_LEN43TRACE_FN_IF(ag_text_strtable+15030)TRACE_FN_FOR_SKIP_LEN42TRACE_FN_FOR_SKIP(ag_text_strtable+14987)TRACE_FN_FOR_REPEAT_LEN25TRACE_FN_FOR_REPEAT(ag_text_strtable+14892)TRACE_FN_FOR_LENTRACE_FN_FOR(ag_text_strtable+14949)TRACE_FIND_ENT_LENTRACE_FIND_ENT(ag_text_strtable+14879)TRACE_EVAL_STRING_LENTRACE_EVAL_STRING(ag_text_strtable+14918)TRACE_DEF_LOAD_LENTRACE_DEF_LOAD(ag_text_strtable+14861)TRACE_COPY_MARK_LENTRACE_COPY_MARK(ag_text_strtable+14841)TRACE_CASE_NOMATCH_LENTRACE_CASE_NOMATCH(ag_text_strtable+14778)TRACE_CASE_MATCHED_LENTRACE_CASE_MATCHED(ag_text_strtable+14744)TRACE_CASE_FAIL_LENTRACE_CASE_FAIL(ag_text_strtable+14712)TRACE_BUILD_DEFS_LENTRACE_BUILD_DEFS(ag_text_strtable+14817)TRACE_AG_ARG_FMT_LENTRACE_AG_ARG_FMT(ag_text_strtable+14811)TRACE_ADD_TO_ENV_FMT_LEN27TRACE_ADD_TO_ENV_FMT(ag_text_strtable+14684)TRACE_ADD_TARG_FILE_FMT_LENTRACE_ADD_TARG_FILE_FMT(ag_text_strtable+14586)TRACE_ADD_SRC_FILE_FMT_LENTRACE_ADD_SRC_FILE_FMT(ag_text_strtable+14565)TPL_WARN_FMT_LEN36TPL_WARN_FMT(ag_text_strtable+14647)TPL_MARK_LENTPL_MARK(ag_text_strtable+14556)TPL_INVOKED_LENTPL_INVOKED(ag_text_strtable+14607)TPL_FILE_TPL_LENTPL_FILE_TPL(ag_text_strtable+4838)TPL_FILE_NEXT_LINE_FMT_LENTPL_FILE_NEXT_LINE_FMT(ag_text_strtable+2996)TPL_FILE_LINE_FMT_LENTPL_FILE_LINE_FMT(ag_text_strtable+1146)TOO_MANY_TIMEOUTS_MSG_LENTOO_MANY_TIMEOUTS_MSG(ag_text_strtable+14489)TEMP_SUFFIX_LENTEMP_SUFFIX(ag_text_strtable+14546)TAB_FILE_LINE_FMT_LENTAB_FILE_LINE_FMTSYSCALL_NAME_LENSYSCALL_NAME(ag_text_strtable+14520)STR_TO_C_NAME_LENSTR_TO_C_NAME(ag_text_strtable+14463)STR_TO_C_MAP_FAIL_LEN44STR_TO_C_MAP_FAIL(ag_text_strtable+14418)STRDUP_FAIL_FMT_LENSTRDUP_FAIL_FMT(ag_text_strtable+14385)STDIN_FILE_NAME_LENSTDIN_FILE_NAME(ag_text_strtable+7129)START_SCHEME_LIST_LENSTART_SCHEME_LIST(ag_text_strtable+14382)START_DEP_FOPEN_MSG_LENSTART_DEP_FOPEN_MSG(ag_text_strtable+14366)START_DEP_FILE_FMT_LEN113START_DEP_FILE_FMT(ag_text_strtable+14245)START_DEP_ARG_FMT_LENSTART_DEP_ARG_FMT(ag_text_strtable+14359)SH_DONE_MARK_LENSH_DONE_MARK(ag_text_strtable+14213)SHELL_XTRACE_CMDS_LENSHELL_XTRACE_CMDS(ag_text_strtable+14177)SHELL_UNK_LAST_CMD_MSG_LENSHELL_UNK_LAST_CMD_MSG(ag_text_strtable+3273)SHELL_SET_PS4_FMT_LEN22SHELL_SET_PS4_FMT(ag_text_strtable+14112)SHELL_RES_NULL_MSG_LENSHELL_RES_NULL_MSG(ag_text_strtable+12395)SHELL_RES_DISCARD_MSG_LENSHELL_RES_DISCARD_MSG(ag_text_strtable+14092)SHELL_RESTART_MSG_LENSHELL_RESTART_MSG(ag_text_strtable+14075)SHELL_READ_ERR_FMT_LENSHELL_READ_ERR_FMT(ag_text_strtable+14135)SHELL_NO_END_MARK_MSG_LENSHELL_NO_END_MARK_MSG(ag_text_strtable+14056)SHELL_LAST_CMD_MSG_LENSHELL_LAST_CMD_MSG(ag_text_strtable+14033)SHELL_INIT_STR_LEN1253SHELL_INIT_STR(ag_text_strtable+12779)SHELL_DIE_FMT_LENSHELL_DIE_FMT(ag_text_strtable+12737)SHELL_CMD_FMT_LENSHELL_CMD_FMT(ag_text_strtable+12708)SFX_FMT_LENSFX_FMT(ag_text_strtable+12390)SET_WRITE_WARN_LEN84SET_WRITE_WARN(ag_text_strtable+12623)SET_TMP_DIR_CMD_LEN86SET_TMP_DIR_CMD(ag_text_strtable+12536)SET_ORIG_DIR_NO_MEM_MSG_LENSET_ORIG_DIR_NO_MEM_MSG(ag_text_strtable+12510)SERV_RESTART_LENSERV_RESTART(ag_text_strtable+12469)SCM_TRUE_STR_LENSCM_TRUE_STR(ag_text_strtable+12387)SCM_PROC_CAST_LENSCM_PROC_CAST(ag_text_strtable+12381)SCM_OUT_POP_NO_REREAD_LENSCM_OUT_POP_NO_REREAD(ag_text_strtable+12366)SCM_OUT_POP_EMPTY_LEN48SCM_OUT_POP_EMPTY(ag_text_strtable+12420)SCM_LIST_STR_LENSCM_LIST_STR(ag_text_strtable+12362)SCM_FALSE_STR_LENSCM_FALSE_STR(ag_text_strtable+12359)SCM_ERROR_FMT_LEN50SCM_ERROR_FMT(ag_text_strtable+12308)SCM2ZCHARS_BAD_VAL_LEN49SCM2ZCHARS_BAD_VAL(ag_text_strtable+12258)SCHEME_INIT_TEXT_LEN3927SCHEME_INIT_TEXT(ag_text_strtable+8330)SCHEME_INIT_DEBUG_2_0_LENSCHEME_INIT_DEBUG_2_0(ag_text_strtable+8242)SCHEME_INIT_DEBUG_1_6_LENSCHEME_INIT_DEBUG_1_6(ag_text_strtable+8230)SCHEME_EVAL_ERR_FMT_LENSCHEME_EVAL_ERR_FMT(ag_text_strtable+8258)SAFE_PRINTF_BAD_FMT_LENSAFE_PRINTF_BAD_FMT(ag_text_strtable+8165)SAFE_PRINTF_BAD_ARGS_LENSAFE_PRINTF_BAD_ARGS(ag_text_strtable+8210)RUN_PRINTF_HUH_LENRUN_PRINTF_HUHRUN_GPERF_CMD_LEN171RUN_GPERF_CMD(ag_text_strtable+7993)RM_MISSING_DE_LENRM_MISSING_DE(ag_text_strtable+7953)RETURN_FROM_NOWHERE_LENRETURN_FROM_NOWHERE(ag_text_strtable+7894)RESOLVE_SCM_VECTOR_LENRESOLVE_SCM_VECTOR(ag_text_strtable+7881)RESOLVE_SCM_UNKNOWN_LENRESOLVE_SCM_UNKNOWN(ag_text_strtable+7867)RESOLVE_SCM_PROC_LENRESOLVE_SCM_PROC(ag_text_strtable+7843)RESOLVE_SCM_PAIR_LENRESOLVE_SCM_PAIR(ag_text_strtable+7832)RESOLVE_SCM_LIST_LENRESOLVE_SCM_LIST(ag_text_strtable+7821)RESOLVE_SCM_INEXACT_LENRESOLVE_SCM_INEXACT(ag_text_strtable+7807)RESOLVE_SCM_EXACT_LENRESOLVE_SCM_EXACT(ag_text_strtable+7795)REQUEST_METHOD_LENREQUEST_METHOD(ag_text_strtable+7780)REALLOC_FAIL_FMT_LENREALLOC_FAIL_FMT(ag_text_strtable+7916)READ_DEF_READ_LENREAD_DEF_READ(ag_text_strtable+1572)READ_DEF_OPEN_LENREAD_DEF_OPEN(ag_text_strtable+1567)READ_DEF_NO_DEFS_LENREAD_DEF_NO_DEFS(ag_text_strtable+7751)READY_INPUT_STAT_LENREADY_INPUT_STAT(ag_text_strtable+7746)READY_INPUT_NOT_REG_LENREADY_INPUT_NOT_REG(ag_text_strtable+7724)READY_INPUT_NODEF_LENREADY_INPUT_NODEF(ag_text_strtable+7703)PSEUDO_MAC_TPL_FILE_LENPSEUDO_MAC_TPL_FILE(ag_text_strtable+7687)PSEUDO_MAC_MODE_MARK_LENPSEUDO_MAC_MODE_MARK(ag_text_strtable+7683)PSEUDO_MAC_ERR_FMT_LENPSEUDO_MAC_ERR_FMT(ag_text_strtable+7499)PSEUDO_MAC_BAD_STARTER_LENPSEUDO_MAC_BAD_STARTER(ag_text_strtable+7462)PSEUDO_MAC_BAD_PSEUDO_LENPSEUDO_MAC_BAD_PSEUDO(ag_text_strtable+7659)PSEUDO_MAC_BAD_NOTPL_LENPSEUDO_MAC_BAD_NOTPL(ag_text_strtable+7638)PSEUDO_MAC_BAD_NOSTART_LENPSEUDO_MAC_BAD_NOSTART(ag_text_strtable+7620)PSEUDO_MAC_BAD_NOEOL_LENPSEUDO_MAC_BAD_NOEOL(ag_text_strtable+7603)PSEUDO_MAC_BAD_NOEND_LENPSEUDO_MAC_BAD_NOEND(ag_text_strtable+7587)PSEUDO_MAC_BAD_NOAG5_LENPSEUDO_MAC_BAD_NOAG5(ag_text_strtable+7566)PSEUDO_MAC_BAD_MODE_LENPSEUDO_MAC_BAD_MODE(ag_text_strtable+7541)PSEUDO_MAC_BAD_LENGTH_LENPSEUDO_MAC_BAD_LENGTH(ag_text_strtable+7432)PSEUDO_MAC_BAD_FSM_LENPSEUDO_MAC_BAD_FSM(ag_text_strtable+7238)PSEUDO_MAC_BAD_ENDER_LENPSEUDO_MAC_BAD_ENDER(ag_text_strtable+7395)PSEUDO_MACRO_NAME_STR_LENPSEUDO_MACRO_NAME_STR(ag_text_strtable+7225)PROC_TPL_START_LENPROC_TPL_START(ag_text_strtable+7203)PROC_TPL_BOGUS_RET_LENPROC_TPL_BOGUS_RET(ag_text_strtable+1940)PRINT_DEF_SPACES_LENPRINT_DEF_SPACES(ag_text_strtable+7362)PRINT_DEF_SHOW_FMT_LENPRINT_DEF_SHOW_FMT(ag_text_strtable+7330)PREP_INVOKE_NO_SEP_LENPREP_INVOKE_NO_SEP(ag_text_strtable+7288)PREP_INVOKE_NO_NAME_LENPREP_INVOKE_NO_NAME(ag_text_strtable+7255)PORT_NUM_BAD_LENPORT_NUM_BAD(ag_text_strtable+7176)PIPE_WRITE_NAME_STR_LENPIPE_WRITE_NAME_STR(ag_text_strtable+7170)PIPE_POLL_NAME_STR_LENPIPE_POLL_NAME_STR(ag_text_strtable+7165)PIPE_MKFIFO_NAME_LENPIPE_MKFIFO_NAME(ag_text_strtable+7158)PIPE_FORK_NAME_LENPIPE_FORK_NAME(ag_text_strtable+7153)PIPE_FIFO_OUT_NAME_FMT_LENPIPE_FIFO_OUT_NAME_FMT(ag_text_strtable+7146)PIPE_FIFO_OPEN_LENPIPE_FIFO_OPENPIPE_FIFO_IN_NAME_FMT_LENPIPE_FIFO_IN_NAME_FMT(ag_text_strtable+7140)PIPE_DUP2_NAME_STR_LENPIPE_DUP2_NAME_STR(ag_text_strtable+7135)PIPE_DEFS_STDIN_STR_LENPIPE_DEFS_STDIN_STR(ag_text_strtable+1404)PIPE_DEFS_STDIN_NAME_LENPIPE_DEFS_STDIN_NAMEPATH_TOO_BIG_LENPATH_TOO_BIG(ag_text_strtable+7105)PARSE_INPUT_AG_DEF_STR_LENPARSE_INPUT_AG_DEF_STR(ag_text_strtable+7079)OUT_SWITCH_FAIL_LENOUT_SWITCH_FAIL(ag_text_strtable+7071)OUT_SUSPEND_CANNOT_LENOUT_SUSPEND_CANNOT(ag_text_strtable+7003)OUT_RESUME_CANNOT_LENOUT_RESUME_CANNOT(ag_text_strtable+6958)OUT_PUSH_NEW_FAIL_LENOUT_PUSH_NEW_FAILED_LEN34OUT_PUSH_NEW_FAILED(ag_text_strtable+6923)OUT_PUSH_NEW_FAIL(ag_text_strtable+7060)OUT_CLOSE_TRACE_WRAP_LENOUT_CLOSE_TRACE_WRAP(ag_text_strtable+7051)OUT_ADD_INVALID_LENOUT_ADD_INVALID(ag_text_strtable+6888)OUTPUT_TEMP_FILE_LENOUTPUT_TEMP_FILE(ag_text_strtable+6807)OUTPUT_NO_UNLINK_LENOUTPUT_NO_UNLINK(ag_text_strtable+6800)OUTPUT_NO_OPEN_LENOUTPUT_NO_OPEN(ag_text_strtable+6784)OPEN_OUTPUT_NULL_LENOPEN_OUTPUT_NULL(ag_text_strtable+6779)OPEN_OUTPUT_BAD_FMT_LENOPEN_OUTPUT_BAD_FMT(ag_text_strtable+6849)NULL_FILE_NAME_STR_LENNULL_FILE_NAME_STR(ag_text_strtable+6764)NO_TEMPLATE_ERR_MSG_LENNO_TEMPLATE_ERR_MSG(ag_text_strtable+6738)NO_NAME_STR_LENNO_NAME_STR(ag_text_strtable+6735)NO_IF_EXPR_LENNO_IF_EXPR(ag_text_strtable+6717)NOT_STR_FMT_LENNOT_STR_FMT(ag_text_strtable+6690)NEXT_PM_TOKEN_INVALID_LENNEXT_PM_TOKEN_INVALID(ag_text_strtable+6664)NEWLINE_LENNEWLINE(ag_text_strtable+6662)NAMED_VALUES_WHERE_LENNAMED_VALUES_WHERE(ag_text_strtable+6821)NAMED_VALUES_NO_NAME_LENNAMED_VALUES_NO_NAME(ag_text_strtable+6644)MK_TMP_DIR_CMD_LENMK_TMP_DIR_CMD(ag_text_strtable+6417)MK_LIC_YRS_LENMK_LIC_YRS(ag_text_strtable+6636)MK_LIC_TOO_BIG_FMT_LENMK_LIC_TOO_BIG_FMT(ag_text_strtable+6484)MK_LIC_SFX_LENMK_LIC_SFX(ag_text_strtable+3110)MK_LIC_PROG_LENMK_LIC_PROG(ag_text_strtable+6626)MK_LIC_PFX_LENMK_LIC_PFX(ag_text_strtable+6620)MK_LIC_OWN_LENMK_LIC_OWN(ag_text_strtable+6612)MK_LIC_NO_OPEN_LENMK_LIC_NO_OPEN(ag_text_strtable+6384)MK_LIC_NO_LIC_LENMK_LIC_NO_LIC(ag_text_strtable+6588)MK_LIC_NOT_STR_LENMK_LIC_NOT_STR(ag_text_strtable+6559)MK_LIC_BIG_PROG_LENMK_LIC_BIG_PROG(ag_text_strtable+6539)MK_LIC_BIG_PFX_LENMK_LIC_BIG_PFX(ag_text_strtable+6525)MK_LIC_BIG_OWN_LENMK_LIC_BIG_OWN(ag_text_strtable+6512)MK_HEAD_GUARD_SCM_LEN52MK_HEAD_GUARD_SCM(ag_text_strtable+6331)MK_HEAD_GUARD_GUARD_LENMK_HEAD_GUARD_GUARD(ag_text_strtable+6456)MK_GPERF_SCRIPT_LEN1177MK_GPERF_SCRIPT(ag_text_strtable+5153)MKSTEMP_FAIL_FMT_LENMKSTEMP_FAIL_FMT(ag_text_strtable+4860)MEM_FILE_STR_LENMEM_FILE_STR(ag_text_strtable+4848)MALLOC_FAIL_FMT_LENMALLOC_FAIL_FMT(ag_text_strtable+5125)MAKE_SCRIPT_NL_LENMAKE_SCRIPT_NL(ag_text_strtable+4842)MAKE_GPERF_CLEANUP_LENMAKE_GPERF_CLEANUP(ag_text_strtable+5093)LOG_SEP_FMT_LENLOG_SEP_FMT(ag_text_strtable+5061)LOAD_TPL_SFX_TPL_LENLOAD_TPL_SFX_TPLLOAD_TPL_SFX_AGL_LENLOAD_TPL_SFX_AGL(ag_text_strtable+4834)LOAD_TPL_IRREGULAR_LENLOAD_TPL_IRREGULAR(ag_text_strtable+4817)LOAD_TPL_CANNOT_STAT_LENLOAD_TPL_CANNOT_STAT(ag_text_strtable+3100)LOAD_TPL_CANNOT_OPEN_LENLOAD_TPL_CANNOT_OPEN(ag_text_strtable+4788)LOAD_TPL_CANNOT_MAP_LENLOAD_TPL_CANNOT_MAP(ag_text_strtable+4774)LOAD_SCM_ENDLESS_LENLOAD_SCM_ENDLESS(ag_text_strtable+5020)LOAD_MACS_BAD_PARSE_LENLOAD_MACS_BAD_PARSE(ag_text_strtable+4986)LOAD_FILE_SHORT_NAME_LENLOAD_FILE_SHORT_NAME(ag_text_strtable+4950)LOAD_CGI_READ_WHAT_LENLOAD_CGI_READ_WHAT(ag_text_strtable+4765)LOAD_CGI_READ_NAME_LENLOAD_CGI_READ_NAMELOAD_CGI_NO_DATA_MSG_LENLOAD_CGI_NO_DATA_MSG(ag_text_strtable+4739)LOAD_CGI_INVAL_REQ_FMT_LENLOAD_CGI_INVAL_REQ_FMT(ag_text_strtable+4915)LOAD_CGI_GET_NAME_LENLOAD_CGI_GET_NAME(ag_text_strtable+4735)LOAD_CGI_DEFS_MARKER_LENLOAD_CGI_DEFS_MARKER(ag_text_strtable+4713)LISTEN_PORT_FMT_LENLISTEN_PORT_FMT(ag_text_strtable+4883)LINE_CONCAT3_FMT_LENLINE_CONCAT3_FMT(ag_text_strtable+4704)LD_WHILE_NO_EXPR_LENLD_WHILE_NO_EXPR(ag_text_strtable+4683)LD_WHILE_NO_ENDWHILE_LENLD_WHILE_NO_ENDWHILE(ag_text_strtable+4664)LD_UNKNOWN_INVAL_DEF_LENLD_UNKNOWN_INVAL_DEF(ag_text_strtable+4422)LD_SEL_INVAL_LENLD_SEL_INVAL(ag_text_strtable+4639)LD_SEL_EMPTY_LENLD_SEL_EMPTY(ag_text_strtable+4622)LD_LIB_PATH_STR_LENLD_LIB_PATH_STR(ag_text_strtable+4606)LD_LIB_PATH_PFX_LENLD_LIB_PATH_PFX(ag_text_strtable+4589)LD_INC_NO_FNAME_LENLD_INC_NO_FNAME(ag_text_strtable+4286)LD_IF_NO_ENDIF_LENLD_IF_NO_ENDIF(ag_text_strtable+4573)LD_FOR_NO_ENDFOR_LENLD_FOR_NO_ENDFOR(ag_text_strtable+4556)LD_FOR_NAMELESS_LENLD_FOR_NAMELESS(ag_text_strtable+4253)LD_FOR_IN_LENLD_FOR_INVALID_VAR_LENLD_FOR_INVALID_VAR(ag_text_strtable+4530)LD_FOR_IN(ag_text_strtable+4527)LD_EXPR_NO_TEXT_LENLD_EXPR_NO_TEXT(ag_text_strtable+4501)LD_EXPR_NO_SPACE_LENLD_EXPR_NO_SPACE(ag_text_strtable+4472)LD_EXPR_NEED_TWO_LENLD_EXPR_NEED_TWO(ag_text_strtable+4446)LD_EXPR_BAD_NAME_LENLD_EXPR_BAD_NAMELD_DEF_WOOPS_LENLD_DEF_WOOPS(ag_text_strtable+4397)LD_DEF_NEED_NAME_LENLD_DEF_NEED_NAME(ag_text_strtable+4374)LD_CASE_NO_EXPR_LENLD_CASE_NO_EXPR(ag_text_strtable+4354)LD_CASE_NO_ESAC_LENLD_CASE_NO_ESAC(ag_text_strtable+4339)LD_BOGUS_UNKNOWN_LENLD_BOGUS_UNKNOWN(ag_text_strtable+4199)LC_ALL_IS_C_LENLC_ALL_IS_C(ag_text_strtable+4330)KR_STRING_NEWLINE_LENKR_STRING_NEWLINE(ag_text_strtable+4325)INIT_SCM_ERRS_FMT_LENINIT_SCM_ERRS_FMT(ag_text_strtable+4073)INIT_SCM_DEBUG_FMT_LENINIT_SCM_DEBUG_FMT(ag_text_strtable+3798)HTML_DEC_DIGIT_LENHTML_DEC_DIGIT(ag_text_strtable+3792)HIDE_EMAIL_START_STR_LEN166HIDE_EMAIL_START_STR(ag_text_strtable+3906)HIDE_EMAIL_END_FMT_LENHIDE_EMAIL_END_FMT(ag_text_strtable+3857)HERE_MISS_MARK_STR_LENHERE_MISS_MARK_STR(ag_text_strtable+3764)HERE_MARK_TOO_LONG_LENHERE_MARK_TOO_LONG(ag_text_strtable+3824)HERE_ENDLESS_STR_LENHERE_ENDLESS_STR(ag_text_strtable+3740)HEADER_STR_LENHEADER_STR(ag_text_strtable+3733)HANDLE_SED_IFNDEF_LENHANDLE_SED_IFNDEF(ag_text_strtable+3726)HANDLE_SED_IFDEF_LENHANDLE_SED_IFDEF(ag_text_strtable+3720)HANDLE_SED_ENDIF_LENHANDLE_SED_ENDIF(ag_text_strtable+3715)HANDLE_SED_ELSE_LENHANDLE_SED_ELSE(ag_text_strtable+3711)HANDLE_HASH_SHELL_LENHANDLE_HASH_SHELL(ag_text_strtable+3704)HANDLE_HASH_BAD_TPL_LENHANDLE_HASH_BAD_TPL(ag_text_strtable+3682)HANDLE_EOL__THE_LENHANDLE_EOL__THE(ag_text_strtable+3678)HANDLE_EOL__ELS_LENHANDLE_EOL__ELS(ag_text_strtable+3674)GUILE_WARN_NO_ENV_LENGUILE_WARN_NO_ENV(ag_text_strtable+3649)GUILE_WARN_DEP_STR_LENGUILE_WARN_DEP_STR(ag_text_strtable+3627)GUILE_VERSION_WRONG_LENGUILE_VERSION_WRONG(ag_text_strtable+3578)GUILE_VERSION_BAD_LENGUILE_VERSION_BAD(ag_text_strtable+3540)GUILE_CMD_FAIL_FMT_LEN73GUILE_CMD_FAIL_FMT(ag_text_strtable+3466)GUARD_SFX_LENGUARD_SFX(ag_text_strtable+3330)GOT_NOTHING_FMT_LENGOT_NOTHING_FMT(ag_text_strtable+3432)GET_NOTHING_FMT_LENGET_NOTHING_FMT(ag_text_strtable+3390)FS_ERR_WARNING_LENFS_ERR_WARNING(ag_text_strtable+1581)FOR_ITERATION_FMT_LENFOR_ITERATION_FMT(ag_text_strtable+3337)FOR_IN_LISTLESS_LENFOR_IN_LISTLESS(ag_text_strtable+3305)FN_IF_ELSE_LENFN_IF_ELSE(ag_text_strtable+3293)FN_DEBUG_LENFN_DEBUG_GRAPHIC_LENFN_DEBUG_GRAPHIC(ag_text_strtable+3287)FN_DEBUG(ag_text_strtable+3186)FN_BOGUS_HUH_LENFN_BOGUS_HUHFN_BOGUS_FMT_LENFN_BOGUS_FMT(ag_text_strtable+3217)FIND_MAC_END_NOPE_LENFIND_MAC_END_NOPE(ag_text_strtable+3133)FIND_MAC_END_NESTED_LENFIND_MAC_END_NESTED(ag_text_strtable+3114)FIND_MAC_END_EMPTY_LENFIND_MAC_END_EMPTY(ag_text_strtable+3150)FIND_LIC_TEXT_SFX_LENFIND_LIC_TEXT_SFXFIND_LIC_TEXT_OPEN_LENFIND_LIC_TEXT_OPENFIND_LIC_TEXT_NO_LIC_LENFIND_LIC_TEXT_NO_LICFIND_LIC_TEXT_MBSD_LENFIND_LIC_TEXT_MBSD(ag_text_strtable+3095)FIND_LIC_TEXT_LGPL_LENFIND_LIC_TEXT_LGPL(ag_text_strtable+3090)FIND_LIC_TEXT_INVAL_LENFIND_LIC_TEXT_INVAL(ag_text_strtable+3065)FIND_LIC_TEXT_BAD_FILE_LENFIND_LIC_TEXT_BAD_FILE(ag_text_strtable+3050)FIND_LIC_TEXT_AGPL_LENFIND_LIC_TEXT_AGPL(ag_text_strtable+3045)FIND_FILE_NAME_LENFIND_FILE_NAME(ag_text_strtable+3035)FIND_FILE_DIR_FMT_LENFIND_FILE_DIR_FMT(ag_text_strtable+3029)FIND_FILE_CURDIR_LENFIND_FILE_CURDIR(ag_text_strtable+3027)FIND_ENT_SUCC_LENFIND_ENT_SUCC(ag_text_strtable+3018)FIND_ENT_FAIL_LENFIND_ENT_FAIL(ag_text_strtable+3010)FIND_DIRECT_UNKNOWN_LEN51FIND_DIRECT_UNKNOWN(ag_text_strtable+2852)FILL_IN_VAL_NO_SEP_LENFILL_IN_VAL_NO_SEP(ag_text_strtable+2956)FILL_IN_VAL_NO_ASSIGN_LENFILL_IN_VAL_NO_ASSIGN(ag_text_strtable+2931)FILE_LINE_FMT_LENFILE_LINE_FMTFALSE_NAME_STR_LENFALSE_NAME_STR(ag_text_strtable+2359)EXTRACT_START_LENEXTRACT_START(ag_text_strtable+2990)EXTRACT_END_LENEXTRACT_END(ag_text_strtable+2984)EXTRACT_CAVEAT_LENEXTRACT_CAVEAT(ag_text_strtable+2904)EXP_FMT_DNE_LEN140EXP_FMT_DNE2_LEN145EXP_FMT_DNE2(ag_text_strtable+2706)EXP_FMT_DNE1_LEN46EXP_FMT_DNE1(ag_text_strtable+2659)EXP_FMT_DNE(ag_text_strtable+2518)EXP_FMT_BAD_LIC_LENEXP_FMT_BAD_LIC(ag_text_strtable+2499)EXIT_CLEANUP_WAITED_LENEXIT_CLEANUP_WAITED(ag_text_strtable+2492)EXIT_CLEANUP_STR_LENEXIT_CLEANUP_STR(ag_text_strtable+2398)EXIT_CLEANUP_NOWAIT_LENEXIT_CLEANUP_NOWAIT(ag_text_strtable+2387)EXIT_CLEANUP_MULLIGAN_LENEXIT_CLEANUP_MULLIGAN(ag_text_strtable+2365)EXIT_CLEANUP_DONE_FMT_LENEXIT_CLEANUP_DONE_FMT(ag_text_strtable+2315)EVAL_TRUE_FALSE_STR_LENEVAL_TRUE_FALSE_STREVAL_EXPR_PROG_ERR_LENEVAL_EXPR_PROG_ERR(ag_text_strtable+2279)EVAL_EXPR_BLOCK_IN_EVAL_LENEVAL_EXPR_BLOCK_IN_EVAL(ag_text_strtable+2231)ERROR_STR_LENERROR_STR(ag_text_strtable+2193)ERROR_IN_TPL_FMT_LENERROR_IN_TPL_FMT(ag_text_strtable+2199)END_C_COMMENT_LENEND_C_COMMENT(ag_text_strtable+2190)EMIT_INVAL_PORT_LENEMIT_INVAL_PORT(ag_text_strtable+2163)ELIF_CONTEXT_MSG_LENELIF_CONTEXT_MSG(ag_text_strtable+2126)DUP_VALUE_INDEX_LENDUP_VALUE_INDEX(ag_text_strtable+2092)DO_SUFFIX_EMPTY_LENDO_SUFFIX_EMPTY(ag_text_strtable+2072)DO_SUFFIX_BAD_CHARS_LENDO_SUFFIX_BAD_CHARS(ag_text_strtable+2036)DO_STDOUT_TPL_STDOUT_LENDO_STDOUT_TPL_STDOUT(ag_text_strtable+2029)DO_STDOUT_TPL_START_STD_LENDO_STDOUT_TPL_START_STD(ag_text_strtable+2003)DO_STDOUT_TPL_NOSFX_LENDO_STDOUT_TPL_NOSFX(ag_text_strtable+1994)DO_STDOUT_TPL_CONTENT_LENDO_STDOUT_TPL_CONTENT(ag_text_strtable+1968)DO_STDOUT_TPL_BADR_LENDO_STDOUT_TPL_BADRDO_STDOUT_TPL_ABANDONED_LENDO_STDOUT_TPL_ABANDONED(ag_text_strtable+1916)DOUBLE_NEWLINE_LENDOUBLE_NEWLINE(ag_text_strtable+1875)DOT_SFX_FMT_LENDOT_SFX_FMT(ag_text_strtable+1869)DOOPT_TOO_MANY_DEFS_LENDOOPT_TOO_MANY_DEFS(ag_text_strtable+1878)DONE_CHECK_REDONE_LENDONE_CHECK_REDONE(ag_text_strtable+1849)DONE_CHECK_DONE_LENDONE_CHECK_DONE(ag_text_strtable+1832)DIRECT_SHELL_NOEND_LENDIRECT_SHELL_NOEND(ag_text_strtable+1749)DIRECT_SHELL_END_SHELL_LENDIRECT_SHELL_END_SHELL(ag_text_strtable+1821)DIRECT_SHELL_COMP_DEFS_LENDIRECT_SHELL_COMP_DEFS(ag_text_strtable+1800)DIRECT_NOMATCH_FMT_LENDIRECT_NOMATCH_FMT(ag_text_strtable+1679)DIRECT_NOENDIF_FMT_LENDIRECT_NOENDIF_FMT(ag_text_strtable+1627)DIRECT_INC_DEF_SFX_LENDIRECT_INC_DEF_SFX(ag_text_strtable+1577)DIRECT_INC_CANNOT_READ_LENDIRECT_INC_CANNOT_READDIRECT_INC_CANNOT_OPEN_LENDIRECT_INC_CANNOT_OPENDIRECT_ERROR_FMT_LENDIRECT_ERROR_FMT(ag_text_strtable+1525)DIRECT_CK_LIST_MARK_LENDIRECT_CK_LIST_MARK(ag_text_strtable+1432)DIRECT_BAD_CTX_FMT_LENDIRECT_BAD_CTX_FMT(ag_text_strtable+1463)DIRECT_ASSERT_FMT_LENDIRECT_ASSERT_FMT(ag_text_strtable+1435)DFT_TPL_DIR_RELATIVE_LENDFT_TPL_DIR_RELATIVE(ag_text_strtable+1412)DFT_TPL_DIR_DATA_LENDFT_TPL_DIR_DATA(ag_text_strtable+1409)DFT_ENV_VAL_LENDFT_ENV_VAL(ag_text_strtable+1406)DFT_DEF_INPUT_STR_LENDFT_DEF_INPUT_STRDFT_BASE_NAME_LENDFT_BASE_NAME(ag_text_strtable+1395)DEV_NULL_LENDEV_NULL(ag_text_strtable+1385)DEP_TList_LENDEP_TList(ag_text_strtable+1374)DEP_SList_LENDEP_SList(ag_text_strtable+1361)DEP_OUT_NAME_LENDEP_OUT_NAME(ag_text_strtable+1341)DEP_List_LENDEP_List(ag_text_strtable+1334)DEP_FILE_WRAP_FMT_LENDEP_FILE_WRAP_FMT(ag_text_strtable+1285)DEP_FILE_SPLICE_STR_LENDEP_FILE_SPLICE_STR(ag_text_strtable+1189)DEP_FILE_CLEAN_FMT_LENDEP_FILE_CLEAN_FMT(ag_text_strtable+1193)DEF_TYPE_UNKNOWN_LENDEF_TYPE_UNKNOWN(ag_text_strtable+1181)DEF_TYPE_TEXT_LENDEF_TYPE_TEXT(ag_text_strtable+1176)DEF_TYPE_INVALID_LENDEF_TYPE_INVALID(ag_text_strtable+1168)DEF_TYPE_BLOCK_LENDEF_TYPE_BLOCK(ag_text_strtable+1162)DEF_NOTE_FMT_LENDEF_NOTE_FMT(ag_text_strtable+1059)DEF_FILE_LINE_FMT_LENDEF_FILE_LINE_FMTDEF_ERR_FMT_LENDEF_ERR_FMT(ag_text_strtable+1027)C_STRING_NEWLINE_LENC_STRING_NEWLINE(ag_text_strtable+1133)CONTINUE_STR_LENCONTINUE_STR(ag_text_strtable+1124)COMPILE_RE_BAD_LENCOMPILE_RE_BAD(ag_text_strtable+1101)CMD_FAIL_FMT_LENCMD_FAIL_FMT(ag_text_strtable+982)CGI_TEMP_ERR_FILE_STR_LENCGI_TEMP_ERR_FILE_STR(ag_text_strtable+959)CGI_PARSE_ERR_FMT_LENCGI_PARSE_ERR_FMT(ag_text_strtable+936)CGI_ERR_MSG_FMT_LEN57CGI_ERR_MSG_FMT(ag_text_strtable+878)CFGDEP_UNKNOWN_DEP_FMT_LENCFGDEP_UNKNOWN_DEP_FMT(ag_text_strtable+849)CFGDEP_DUP_TARGET_MSG_LENCFGDEP_DUP_TARGET_MSG(ag_text_strtable+827)CANNOT_FMT_LENCANNOT_FMT(ag_text_strtable+798)BREAK_STR_LENBREAK_STR(ag_text_strtable+788)BOGUS_TAG_LENBOGUS_TAG(ag_text_strtable+776)BASE_NAME_TOO_LONG_LENBASE_NAME_TOO_LONG(ag_text_strtable+747)BAD_RE_FMT_LENBAD_RE_FMT(ag_text_strtable+700)BAD_NAME_FMT_LENBAD_NAME_FMT(ag_text_strtable+664)BAD_MSG_STR_LENBAD_MSG_STR(ag_text_strtable+627)BAD_MAC_NM_FMT_LENBAD_MAC_NM_FMT(ag_text_strtable+592)BAD_BREAK_FMT_LENBAD_BREAK_FMT(ag_text_strtable+562)ASSEMBLE_NAME_ERR_LENASSEMBLE_NAME_ERR(ag_text_strtable+510)ASPRINTFV_FAIL_FMT_LENASPRINTFV_FAIL_FMT(ag_text_strtable+483)APRF_ALLOCATE_FAIL_LENAPRF_ALLOCATE_FAIL(ag_text_strtable+432)ALIST_TO_AG_WRAP_LENALIST_TO_AG_WRAP(ag_text_strtable+408)ALIST_TO_AG_TEXT_LENALIST_TO_AG_TEXT(ag_text_strtable+380)ALIST_TO_AG_ERR_LENALIST_TO_AG_ERR(ag_text_strtable+327)AG_TEXT_STRTABLE_FILE_LENAG_TEXT_STRTABLE_FILE(ag_text_strtable+0)AG_SIG_ABORT_FMT_LENAG_SIG_ABORT_FMT(ag_text_strtable+279)AG_NEVER_STARTED_LENAG_NEVER_STARTED(ag_text_strtable+216)AG_MARK_LENAG_MARK(ag_text_strtable+207)AG_MAKE_DEP_NAME_LENAG_MAKE_DEP_NAME(ag_text_strtable+190)AG_FPRINTF_BAD_PORT_LENAG_FPRINTF_BAD_PORT(ag_text_strtable+160)AG_ABORT_LOC_FMT_LEN74AG_ABORT_LOC_FMT(ag_text_strtable+85)AG_ABEND_STATE_FMT_LENAG_ABEND_STATE_FMT(ag_text_strtable+62)ADD_SYS_ENV_VAL_FMT_LENADD_SYS_ENV_VAL_FMT(ag_text_strtable+57)ADD_ENV_VARS_SUFFIX_FMT_LENADD_ENV_VARS_SUFFIX_FMT(ag_text_strtable+52)ADDR_FAMILY_BAD_LENADDR_FAMILY_BAD(ag_text_strtable+10)STRINGS_AG_TEXT_H_GUARDconst char[16320]char[16320]16320ag_text_strtable/* STRINGS_AG_TEXT_H_GUARD *//*
 * 408 strings in ag_text_strtable string table
 *//*  -*- buffer-read-only: t -*- vi: set ro:
 *
 * DO NOT EDIT THIS FILE   (ag-text.h)
 *
 * It has been AutoGen-ed
 * From the definitions    /u/bkorb/ag/ag/agen5/ag-text.def
 * and the template file   strings
 *
 *  Copyright (C) 2011-2015 Bruce Korb, all rights reserved.
 *  This is free software. It is licensed for use, modification and
 *  redistribution under the terms of the
 *  Modified (3 clause) Berkeley Software Distribution License
 *  <http://www.xfree86.org/3.3.6/COPYRIGHT2.html>
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. Neither the name ``Bruce Korb'' nor the name of any other
 *     contributor may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 *  strings IS PROVIDED BY Bruce Korb ``AS IS'' AND ANY EXPRESS
 *  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *  ARE DISCLAIMED.  IN NO EVENT SHALL Bruce Korb OR ANY OTHER CONTRIBUTORS
 *  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 *  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/opts.h<stdnoreturn.h><stdarg.h><autoopts/options.h>nomem_errstatic"could not allocate %zu bytes for %s\n"fmtcould not allocate %zu bytes for %s
char[37]AUTOGEN_EXIT_NO_MEMte_TraceTRACE_NOTHINGTRACE_DEBUG_MESSAGETRACE_SERVER_SHELLTRACE_TEMPLATESTRACE_BLOCK_MACROSTRACE_EXPRESSIONSTRACE_EVERYTHINGautogen_exit_code_tAUTOGEN_EXIT_SUCCESSAUTOGEN_EXIT_OPTION_ERRORAUTOGEN_EXIT_BAD_TEMPLATEAUTOGEN_EXIT_BAD_DEFINITIONSAUTOGEN_EXIT_LOAD_ERRORAUTOGEN_EXIT_FS_ERRORAUTOGEN_EXIT_SIGNAL128AUTOGEN_EXIT_USAGE_ERRORAUTOGEN_EXIT_NO_CONFIG_INPUT66AUTOGEN_EXIT_LIBOPTS_FAILURE70teOptIndexINDEX_OPT_TEMPL_DIRSINDEX_OPT_OVERRIDE_TPLINDEX_OPT_LIB_TEMPLATEINDEX_OPT_DEFINITIONSINDEX_OPT_SHELLINDEX_OPT_NO_FMEMOPENINDEX_OPT_EQUATEINDEX_OPT_BASE_NAMEINDEX_OPT_SOURCE_TIMEINDEX_OPT_WRITABLEINDEX_OPT_LOOP_LIMITINDEX_OPT_TIMEOUTINDEX_OPT_TRACEINDEX_OPT_TRACE_OUTINDEX_OPT_SHOW_DEFSINDEX_OPT_USED_DEFINESINDEX_OPT_COREINDEX_OPT_SKIP_SUFFIXINDEX_OPT_SELECT_SUFFIXINDEX_OPT_DEFINEINDEX_OPT_UNDEFINEINDEX_OPT_MAKE_DEPINDEX_OPT_RESET_OPTIONINDEX_OPT_VERSIONINDEX_OPT_HELPINDEX_OPT_MORE_HELPINDEX_OPT_USAGEINDEX_OPT_SAVE_OPTSINDEX_OPT_LOAD_OPTSOPT_XLAT_OPT_NAMESOPT_XLAT_CFG_NAMESOPT_NO_XLAT_OPT_NAMESOPT_NO_XLAT_CFG_NAMESUSAGE(c)(*autogenOptions.pUsageProc)(&autogenOptions, c)START_OPTRESTART_OPT(1)RESTART_OPT(n)STMTS( autogenOptions.curOptIdx = (n); autogenOptions.pzCurOpt = NULL )ERRSTOP_OPTERRSTMTS(autogenOptions.fOptSet |= OPTPROC_ERRSTOP)ERRSKIP_OPTERRSTMTS(autogenOptions.fOptSet &= ~OPTPROC_ERRSTOP)SET_OPT_SAVE_OPTS(a)STMTS( DESC(SAVE_OPTS).fOptState &= OPTST_PERSISTENT_MASK; DESC(SAVE_OPTS).fOptState |= OPTST_SET; DESC(SAVE_OPTS).optArg.argString = (char const*)(a))VALUE_OPT_LOAD_OPTS'<'VALUE_OPT_SAVE_OPTS'>'VALUE_OPT_USAGE'u'VALUE_OPT_VERSION'v'VALUE_OPT_RESET_OPTION'R'VALUE_OPT_MORE_HELP'!'VALUE_OPT_HELP'?'SET_OPT_MAKE_DEP(a)STMTS( DESC(MAKE_DEP).optActualIndex = 26; DESC(MAKE_DEP).optActualValue = VALUE_OPT_MAKE_DEP; DESC(MAKE_DEP).fOptState &= OPTST_PERSISTENT_MASK; DESC(MAKE_DEP).fOptState |= OPTST_SET; DESC(MAKE_DEP).optArg.argString = (a); (*(DESC(MAKE_DEP).pOptProc))(&autogenOptions, autogenOptions.pOptDesc + 26); )VALUE_OPT_MAKE_DEP'M'SET_OPT_UNDEFINE(a)STMTS( DESC(DEFINE).optActualIndex = 24; DESC(DEFINE).optActualValue = VALUE_OPT_UNDEFINE; DESC(DEFINE).fOptState &= OPTST_PERSISTENT_MASK; DESC(DEFINE).fOptState |= OPTST_SET | OPTST_EQUIVALENCE; DESC(DEFINE).optArg.argString = (a); (*(DESC(UNDEFINE).pOptProc))(&autogenOptions, autogenOptions.pOptDesc + INDEX_OPT_DEFINE); )VALUE_OPT_UNDEFINE'U'SET_OPT_DEFINE(a)STMTS( DESC(DEFINE).optActualIndex = 23; DESC(DEFINE).optActualValue = VALUE_OPT_DEFINE; DESC(DEFINE).fOptState &= OPTST_PERSISTENT_MASK; DESC(DEFINE).fOptState |= OPTST_SET; DESC(DEFINE).optArg.argString = (a); (*(DESC(DEFINE).pOptProc))(&autogenOptions, autogenOptions.pOptDesc + 23); )VALUE_OPT_DEFINE'D'VALUE_OPT_SELECT_SUFFIX'o'VALUE_OPT_SKIP_SUFFIX's'VALUE_OPT_CORE'C'VALUE_OPT_USED_DEFINES0x100AVALUE_OPT_SHOW_DEFS0x1009VALUE_OPT_TRACE_OUT0x1008OPT_VALUE_TRACE(DESC(TRACE).optArg.argEnum)OPT_TRACE_VAL2STR(_v)optionKeywordName(&DESC(TRACE), (_v))VALUE_OPT_TRACE0x1007OPT_VALUE_TIMEOUT(DESC(TIMEOUT).optArg.argInt)VALUE_OPT_TIMEOUT't'OPT_VALUE_LOOP_LIMIT(DESC(LOOP_LIMIT).optArg.argInt)VALUE_OPT_LOOP_LIMIT0x1006DISABLE_OPT_WRITABLESTMTS( DESC(WRITABLE).fOptState &= OPTST_PERSISTENT_MASK; DESC(WRITABLE).fOptState |= OPTST_SET | OPTST_DISABLED; DESC(WRITABLE).optArg.argString = NULL )SET_OPT_WRITABLESTMTS( DESC(WRITABLE).optActualIndex = 11; DESC(WRITABLE).optActualValue = VALUE_OPT_WRITABLE; DESC(WRITABLE).fOptState &= OPTST_PERSISTENT_MASK; DESC(WRITABLE).fOptState |= OPTST_SET )VALUE_OPT_WRITABLE0x1005VALUE_OPT_SOURCE_TIME0x1004VALUE_OPT_BASE_NAME'b'VALUE_OPT_EQUATE0x1003VALUE_OPT_NO_FMEMOPEN'm'VALUE_OPT_SHELL0x1002DISABLE_OPT_DEFINITIONSSTMTS( DESC(DEFINITIONS).fOptState &= OPTST_PERSISTENT_MASK; DESC(DEFINITIONS).fOptState |= OPTST_SET | OPTST_DISABLED; DESC(DEFINITIONS).optArg.argString = NULL )SET_OPT_DEFINITIONS(a)STMTS( DESC(DEFINITIONS).optActualIndex = 4; DESC(DEFINITIONS).optActualValue = VALUE_OPT_DEFINITIONS; DESC(DEFINITIONS).fOptState &= OPTST_PERSISTENT_MASK; DESC(DEFINITIONS).fOptState |= OPTST_SET; DESC(DEFINITIONS).optArg.argString = (a) )VALUE_OPT_DEFINITIONS0x1001VALUE_OPT_LIB_TEMPLATE'l'VALUE_OPT_OVERRIDE_TPL'T'SET_OPT_TEMPL_DIRS(a)STMTS( DESC(TEMPL_DIRS).optActualIndex = 1; DESC(TEMPL_DIRS).optActualValue = VALUE_OPT_TEMPL_DIRS; DESC(TEMPL_DIRS).fOptState &= OPTST_PERSISTENT_MASK; DESC(TEMPL_DIRS).fOptState |= OPTST_SET; DESC(TEMPL_DIRS).optArg.argString = (a); (*(DESC(TEMPL_DIRS).pOptProc))(&autogenOptions, autogenOptions.pOptDesc + 1); )VALUE_OPT_TEMPL_DIRS'L'CLEAR_OPT(n)STMTS( DESC(n).fOptState &= OPTST_PERSISTENT_MASK; if ((DESC(n).fOptState & OPTST_INITENABLED) == 0) DESC(n).fOptState |= OPTST_DISABLED; DESC(n).optCookie = NULL )STACKLST_OPT(n)(((tArgList*)(DESC(n).optCookie))->apzArgs)STACKCT_OPT(n)(((tArgList*)(DESC(n).optCookie))->useCt)ENABLED_OPT(n)(! DISABLED_OPT(& DESC(n)))ISUNUSED_OPT(n)(UNUSED_OPT(& DESC(n)))ISSEL_OPT(n)(SELECTED_OPT(&DESC(n)))COUNT_OPT(n)(DESC(n).optOccCt)STATE_OPT(n)(DESC(n).fOptState & OPTST_SET_MASK)OPT_ARG(n)(DESC(n).optArg.argString)HAVE_OPT(n)(! UNUSED_OPT(& DESC(n)))DESC(n)(autogenOptions.pOptDesc[INDEX_OPT_ ## n])AUTOGEN_FULL_VERSION"autogen (GNU AutoGen) 5.18.7"AUTOGEN_VERSION"5.18.7"OPTION_CTAO_TEMPLATE_VERSION167937AUTOOPTS_OPTS_H_GUARD(AO_TEMPLATE_VERSION < OPTIONS_MINIMUM_VERSION) \SHELL_ENABLED_fserrdievdieusage_messagevusage_messageautogenOptionstrace_is_to_pipetpl_fname/* opts.h ends here *//** @} *//* AUTOOPTS_OPTS_H_GUARD *//**
 * Print a AUTOGEN_EXIT_NO_MEM fatal error message and die.
 *
 * @param[in] sz     the object size that was not allocated
 * @param[in] what   what that object was going to be
 * @noreturn
 *//* * * * * *
 *
 *  Declare the autogen option descriptor.
 *//*
 *  global exported definitions
 *//*
 *  Interface defines not associated with particular options
 *//** option flag (value) for load-opts-value option *//** option flag (value) for save-opts-value option *//** option flag (value) for usage-value option *//** option flag (value) for version-value option *//** option flag (value) for reset-value option *//** option flag (value) for more-help-value option *//** option flag (value) for help-value option *//* SHELL_ENABLED *//**
 *  Interface defines for specific options.
 * @{
 *//**
 *  Enumeration of autogen exit codes
 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//** Reset an option. *//** stacked argument vector.
 *  Valid only for stacked option arguments. *//** number of stacked option arguments.
 *  Valid only for stacked option arguments. *//** 'true' if OPTST_DISABLED bit not set. *//** 'true' if \a HAVE_OPT would yield 'false'. *//** mask of \a OPTST_SET and \a OPTST_DEFINED. *//** Count of option's occurrances *on the command line*. *//** Mask the option state revealing how an option was specified.
 *  It will be one and only one of \a OPTST_SET, \a OPTST_PRESET,
 * \a OPTST_DEFINED, \a OPTST_RESET or zero.
 *//** The string argument to an option. The argument type must be \"string\". *//** 'true' if an option has been specified in any way *//**
 *  Interface defines for all options.  Replace "n" with the UPPER_CASED
 *  option name (as in the teOptIndex enumeration above).
 *  e.g. HAVE_OPT(INPUT_SELECT)
 *//** Full autogen version text *//** autogen version *//** count of all options for autogen *//**
 *  Enumeration of each option type for autogen
 *//**
 *  Ensure that the library used for compiling this generated header is at
 *  least as new as the version current when the header template was released
 *  (not counting patch version increments).  Also ensure that the oldest
 *  tolerable version is at least as old as what was current when the header
 *  template was released.
 *//**
 *  This file contains the programmatic interface to the Automated
 *  Options generated for the autogen program.
 *  These macros are documented in the AutoGen info file in the
 *  "AutoOpts" chapter.  Please refer to that doc for usage help.
 *//** \file opts.h
 *  \addtogroup autogen
 *  @{
 *//*   -*- buffer-read-only: t -*- vi: set ro:
 *
 *  DO NOT EDIT THIS FILE   (opts.h)
 *
 *  It has been AutoGen-ed
 *  From the definitions    opts.def
 *  and the template file   options
 *
 * Generated from AutoOpts 41:1:16 templates.
 *
 *  AutoOpts is a copyrighted work.  This header file is not encumbered
 *  by AutoOpts licensing, but is provided under the licensing terms chosen
 *  by the autogen author or copyright holder.  AutoOpts is
 *  licensed under the terms of the LGPL.  The redistributable library
 *  (``libopts'') is licensed under the terms of either the LGPL or, at the
 *  users discretion, the BSD license.  See the AutoOpts and/or libopts sources
 *  for details.
 *
 * The autogen program is copyrighted and licensed
 * under the following terms:
 *
 *  Copyright (C) 1992-2015 Bruce Korb, all rights reserved.
 *  This is free software. It is licensed for use, modification and
 *  redistribution under the terms of the GNU General Public License,
 *  version 3 or later <http://gnu.org/licenses/gpl.html>
 *
 *  autogen is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  autogen is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program.  If not, see <http://www.gnu.org/licenses/>.
 */exit_codeopap/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/expr.hteGuileTypeGH_TYPE_UNDEFINEDGH_TYPE_BOOLEANGH_TYPE_SYMBOLGH_TYPE_CHARGH_TYPE_VECTORGH_TYPE_PAIRGH_TYPE_NUMBERGH_TYPE_STRINGGH_TYPE_PROCEDUREGH_TYPE_LISTGH_TYPE_INEXACTGH_TYPE_EXACTGUILE_PROCS_EXPR_H_GUARDGUILE_VERSION >= 108000ag_scm_warnag_scm_version_compareag_scm_tpl_file_next_lineag_scm_tpl_file_lineag_scm_tpl_fileag_scm_time_string_to_numberag_scm_sumag_scm_suffixag_scm_sub_shell_strag_scm_string_upcase_xag_scm_string_upcaseag_scm_string_tr_xag_scm_string_trag_scm_string_to_camelcaseag_scm_string_to_c_name_xag_scm_string_substituteag_scm_string_starts_with_pag_scm_string_starts_eqv_pag_scm_string_start_match_pag_scm_string_start_eqv_match_pag_scm_string_match_pag_scm_string_has_match_pag_scm_string_has_eqv_match_pag_scm_string_eqv_pag_scm_string_eqv_match_pag_scm_string_equals_pag_scm_string_ends_with_pag_scm_string_ends_eqv_pag_scm_string_end_match_pag_scm_string_end_eqv_match_pag_scm_string_downcase_xag_scm_string_downcaseag_scm_string_contains_pag_scm_string_contains_eqv_pag_scm_string_capitalize_xag_scm_string_capitalizeag_scm_stackag_scm_sprintfag_scm_shellfag_scm_shell_strag_scm_shellag_scm_set_writableag_scm_set_optionag_scm_raw_shell_strag_scm_printfag_scm_prefixag_scm_output_file_next_lineag_scm_out_switchag_scm_out_suspendag_scm_out_resumeag_scm_out_push_newag_scm_out_push_addag_scm_out_popag_scm_out_nameag_scm_out_moveag_scm_out_lineag_scm_out_emit_suspendedag_scm_out_depthag_scm_out_deleteag_scm_mk_gettextableag_scm_minag_scm_max_file_timeag_scm_maxag_scm_match_value_pag_scm_makefile_scriptag_scm_make_tmp_dirag_scm_make_header_guardag_scm_make_gperfag_scm_low_limag_scm_license_nameag_scm_license_infoag_scm_license_fullag_scm_license_descriptionag_scm_licenseag_scm_lgplag_scm_lenag_scm_last_for_pag_scm_kr_stringag_scm_joinag_scm_insert_fileag_scm_in_pag_scm_high_limag_scm_hide_emailag_scm_gplag_scm_gperfag_scm_get_up_nameag_scm_get_down_nameag_scm_get_c_nameag_scm_getag_scm_fprintfag_scm_found_for_pag_scm_format_arg_countag_scm_for_toag_scm_for_sepag_scm_for_indexag_scm_for_fromag_scm_for_byag_scm_first_for_pag_scm_find_fileag_scm_extractag_scm_exist_pag_scm_error_source_lineag_scm_errorag_scm_emitag_scm_dneag_scm_def_file_lineag_scm_def_fileag_scm_countag_scm_chdirag_scm_c_stringag_scm_bsdag_scm_base_nameag_scm_agplag_scm_ag_function_pag_scm_ag_fprintf/* GUILE_PROCS_EXPR_H_GUARD *//** \file expr.h
 *  Guile Implementation Routines - for the autogen group
 *
 * @addtogroup autogen
 * @{
 *//*  -*- buffer-read-only: t -*- vi: set ro:
 *
 *  DO NOT EDIT THIS FILE   (expr.h)
 *
 *  It has been AutoGen-ed
 *  From the definitions    expr.def
 *  and the template file   snarf.tpl
 *
 *  Copyright (C) 1992-2015 Bruce Korb - all rights reserved
 *
 *  AutoGen is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AutoGen is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program.  If not, see <http://www.gnu.org/licenses/>.
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/autoopts/autoopts/usage-txt.husage_text_tconst char *[104]char *[104]104apz_strutpz_GnuStrArgutpz_GnuNumArgutpz_GnuKeyArgutpz_GnuBoolArgfield_ctconst char[4285]char[4285]4285option_lib_textoption_xlateable_txtAUTOOPTS_USAGE_TXT_H_GUARDdefined(AUTOOPTS_INTERNAL)XGETTEXT_SCAN_DO_NOT_COMPILE/* AUTOOPTS_USAGE_TXT_H_GUARD *//* XGETTEXT_SCAN_DO_NOT_COMPILE *//* END-USAGE-TEXT *//* USAGE-TEXT: *//* END-LIBOPTS-MESSAGES *//* LIBOPTS-MESSAGES: *//* TRANSLATORS: The following dummy functions were crated solely so that
 * xgettext can extract the correct strings.  These strings are actually
 * referenced where the preceding "#line" directive states, though you will
 * not see the literal string there.  The literal string is defined above in
 * the @code{option_lib_text} table and referenced via a #define name that
 * redirects into the @code{option_xlateable_txt} structure above.  When
 * translating is activated, the pointers in @code{option_xlateable_txt} are
 * updated to point to translated strings.
 *//* AUTOOPTS_INTERNAL *//*
 *  Now, define (and initialize) the structure that contains
 *  the pointers to all these strings.
 *  Aren't you glad you don't maintain this by hand?
 *//*  4255 *//*  4198 *//*  4161 *//*  4128 *//*  3909 *//*  3866 *//*  3826 *//*  3801 *//*  3775 *//*  3709 *//*  3681 *//*  3635 *//*  3629 *//*  3601 *//*  3564 *//*  3550 *//*  3519 *//*  3506 *//*  3479 *//*  3453 *//*  3397 *//*  3361 *//*  3325 *//*  3306 *//*  3272 *//*  3224 *//*  3216 *//*  3178 *//*  3143 *//*  3118 *//*  3085 *//*  3018 *//*  2975 *//*  2941 *//*  2885 *//*  2779 *//*  2676 *//*  2649 *//*  2618 *//*  2571 *//*  2554 *//*  2528 *//*  2498 *//*  2483 *//*  2457 *//*  2415 *//*  2373 *//*  2344 *//*  2288 *//*  2243 *//*  2194 *//*  2188 *//*  2173 *//*  2157 *//*  2132 *//*  2097 *//*  2057 *//*  2010 *//*  1962 *//*  1908 *//*  1890 *//*  1840 *//*  1804 *//*  1771 *//*  1744 *//*  1695 *//*  1646 *//*  1619 *//*  1574 *//*  1528 *//*  1490 *//*  1407 *//*  1364 *//*  1335 *//*  1290 *//*  1254 *//*  1211 *//*  1185 *//*  1159 *//*  1146 *//*  1107 *//*  1060 *//*   918 *//*   900 *//*   862 *//*   837 *//*   800 *//*   748 *//*   716 *//*   667 *//*   634 *//*   596 *//*   564 *//*   519 *//*   484 *//*   427 *//*   405 *//*   314 *//*   264 *//*   228 *//*   129 *//*    83 *//*    31 *//*     0 *//*
   *  First, set up the strings.  Some of these are writable.  These are all in
   *  English.  This gets compiled into libopts and is distributed here so that
   *  xgettext (or equivalents) can extract these strings for translation.
   *//*
 *  Provide a mapping from a short name to either the text directly
 *  (for untranslatable strings), or to pointers to the text, rendering
 *  them translatable.
 *//*
 *  Declare the global structure with all the pointers to translatable
 *  strings and the text array containing untranslatable strings.
 *//*
 *  One structure to hold all the pointers to all the translatable strings.
 *//** @file usage-txt.h
 *
 *  This file handles all the bookkeeping required for tracking all the little
 *  tiny strings used by the AutoOpts library.  There are 108
 *  of them.  This is not versioned because it is entirely internal to the
 *  library and accessed by client code only in a very well-controlled way:
 *  they may substitute translated strings using a procedure that steps through
 *  all the string pointers.
 *//*  -*- buffer-read-only: t -*- vi: set ro:
 *
 * DO NOT EDIT THIS FILE   (usage-txt.h)
 *
 * It has been AutoGen-ed
 * From the definitions    usage-txt.def
 * and the template file   usage-txt.tpl
 *
 *  This file is part of AutoOpts, a companion to AutoGen.
 *  AutoOpts is free software.
 *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
 *
 *  AutoOpts is available under any one of two licenses.  The license
 *  in use must be one of these two and the choice is under the control
 *  of the user of the license.
 *
 *   The GNU Lesser General Public License, version 3 or later
 *      See the files "COPYING.lgplv3" and "COPYING.gplv3"
 *
 *   The Modified Berkeley Software Distribution License
 *      See the file "COPYING.mbsd"
 *
 *  These files have the following sha256 sums:
 *
 *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3
 *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3
 *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/autoopts/autoopts/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/autoopts/autoopts.h"autoopts/usage-txt.h"<sys/mman.h>arg_types_tteTextToTT_LONGUSAGETT_USAGETT_VERSIONCOUNT_TTtOptStateteOptTypeTOPT_UNDEFINEDTOPT_SHORTTOPT_LONGTOPT_DEFAULTteEnvPresetTypeENV_ALLENV_IMMENV_NON_IMMtePagerStatePAGER_STATE_INITIALPAGER_STATE_READYPAGER_STATE_CHILDtOptionLoadModeOPTION_LOAD_COOKEDOPTION_LOAD_UNCOOKEDOPTION_LOAD_KEEPtDirectionpzTimepzOptFmtpzSpcpzNoFpzBrkpzNopzOptpzNestpzBoolpzKeyLpzKeypzFilepzNumpzReqpzStroptTypepzOptArgtOptDesc *opt_desc *pODprogram_pkgdatadiroption_usage_fpoption_load_modeDO_TRANSLATIONSINQUERY_CALL(_o,_d)( ((_o) <= OPTPROC_EMIT_LIMIT) || ((_d) == NULL) || (((_d)->fOptState & OPTST_RESET) != 0) )DO_SECOND_TIME(_flg)( (((_flg) & (OPTST_DISABLED|OPTST_TWICE)) == OPTST_TWICE) || (((_flg) & (OPTST_DISABLED|OPTST_DISABLE_TWICE)) == (OPTST_DISABLED|OPTST_DISABLE_TWICE) ))DO_NORMALLY(_flg)( (((_flg) & (OPTST_DISABLED|OPTST_IMM)) == 0) || (((_flg) & (OPTST_DISABLED|OPTST_DISABLE_IMM)) == OPTST_DISABLED) )DO_IMMEDIATELY(_flg)( (((_flg) & (OPTST_DISABLED|OPTST_IMM)) == OPTST_IMM) || ( ((_flg) & (OPTST_DISABLED|OPTST_DISABLE_IMM)) == (OPTST_DISABLED|OPTST_DISABLE_IMM) ))ao_free(_p)free(VOIDP(_p))AGDUPSTR(_p,_s,_w)(_p = ao_strdup(_s))AGFREE(_p)AGREALOC(_p,_c,_w)ao_realloc(VOIDP(_p), (size_t)_c)AGALOC(_c,_w)ao_malloc((size_t)_c)_TT__TT_(n)TT_ ## n ,TEXTTO_TABLE_TT_(LONGUSAGE) _TT_(USAGE) _TT_(VERSION)OPTSTATE_INITIALIZER(st){ NULL, NULL, OPTST_ ## st, TOPT_UNDEFINED }CALLED(d)((d)==0)PRESETTING(d)((d)<0)PROCESSING(d)((d)>0)DIRECTION_CALLEDDIRECTION_PROCESSDIRECTION_PRESETSKIP_OPT(p)(((p)->fOptState & OPTST_IMMUTABLE_MASK) != 0)NAMED_OPTS(po)(((po)->fOptSet & (OPTPROC_SHORTOPT | OPTPROC_LONGOPT)) == 0)NUM_TO_VER(n)((n) >> 12), ((n) >> 7) & 0x001F, (n) & 0x007Fignore_val(x)(({ __typeof__ (x) __x = (x); (void) __x; }))C(_t,_p)((_t)VOIDP(_p))NLEX_OSERREX_SOFTWAREEX_NOINPUTEX_DATAERREX_USAGEDIRCH'/'CR'\r'FF'\f'VT'\v'LFHT'\t'BS'\b'BEL'\a'EXPORTAO_NAME_SIZE((size_t)(AO_NAME_LIMIT + 1))AO_NAME_LIMITAUTOGEN_AUTOOPTS_HAG_PATH_MAXPATH_MAX__gnu_hurd__defined(PATH_MAX) && (PATH_MAX > MAXPATHLEN)NULdefined(_WIN32) && !defined(__CYGWIN__)C__GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ < 4)HAVE_SYS_MMAN_HPROT_READPROT_WRITEMAP_SHAREDMAP_PRIVATEMAP_FAILED_SC_PAGESIZE_SC_PAGE_SIZEHAVE_STRCHRAUTOOPTS_INTERNALPKGDATADIRdefined(ENABLE_NLS) && defined(HAVE_LIBINTL_H)optionLoadOpttOptions *options *optionPagedUsageoptionPrintVersionao_strdupao_reallocao_mallocVERSIONUSAGELONGUSAGE/**
 * @}
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of autoopts/autoopts.h *//* AUTOGEN_AUTOOPTS_H *//**
 * Automated Options Usage Flags.
 * NB: no entry may be a prefix of another entry
 *//**
 * privately exported functions
 *//**
 *  If provided in the option structure
 *//**
 *  File pointer for usage output
 *//**
 *  Define and initialize all the user visible strings.
 *  We do not do translations.  If translations are to be done, then
 *  the client will provide a callback for that purpose.
 *//**
 * INQUERY_CALL() tests whether the option handling function has been
 * called by an inquery (help text needed, or option being reset),
 * or called by a set-the-option operation.
 *//*
 *  text_mmap structure.  Only active on platforms with mmap(2).
 *//**
 *  C)  handling at "regular" time because it is to be handled twice.
 *      The immediate bit was already tested and found to be set:
 *
 *  3.  OPTST_DISABLED is not set:
 *      IMM           is set (but don't care)
 *      DISABLE_IMM   don't care
 *      TWICE         must be set
 *      DISABLE_TWICE don't care
 *      0 -and-  ? x 1 x
 *
 *  4.  OPTST_DISABLED is set:
 *      IMM           don't care
 *      DISABLE_IMM   is set (but don't care)
 *      TWICE         don't care
 *      DISABLE_TWICE must be set
 *      1 -and-  x ? x 1
 *//**
 *  B) handling at "regular" time because it was not immediate
 *
 *  1.  OPTST_DISABLED is not set:
 *      IMM           must *NOT* be set
 *      DISABLE_IMM   don't care
 *      TWICE         don't care
 *      DISABLE_TWICE don't care
 *      0 -and-  0 x x x
 *
 *  2.  OPTST_DISABLED is set:
 *      IMM           don't care
 *      DISABLE_IMM   don't care
 *      TWICE         must be set
 *      DISABLE_TWICE don't care
 *      1 -and-  x x 1 x
 *//**
 *  DO option handling?
 *
 *  Options are examined at two times:  at immediate handling time and at
 *  normal handling time.  If an option is disabled, the timing may be
 *  different from the handling of the undisabled option.  The OPTST_DIABLED
 *  bit indicates the state of the currently discovered option.
 *  So, here's how it works:
 *
 *  A) handling at "immediate" time, either 1 or 2:
 *
 *  1.  OPTST_DISABLED is not set:
 *      IMM           must be set
 *      DISABLE_IMM   don't care
 *      TWICE         don't care
 *      DISABLE_TWICE don't care
 *      0 -and-  1 x x x
 *
 *  2.  OPTST_DISABLED is set:
 *      IMM           don't care
 *      DISABLE_IMM   must be set
 *      TWICE         don't care
 *      DISABLE_TWICE don't care
 *      1 -and-  x 1 x x
 *//**
 * option argument types.  Used to create usage information for
 * particular options.
 *//**
     *  This is a child process used in creating shell script usage.
     *//**
     * temp file created and optionPagedUsage is scheduled to run at exit
     *///@< initial option paging state/**
 *  The pager state is used by optionPagedUsage() procedure.
 *  When it runs, it sets itself up to be called again on exit.
 *  If, however, a routine needs a child process to do some work
 *  before it is done, then 'pagerState' must be set to
 *  'PAGER_STATE_CHILD' so that optionPagedUsage() will not try
 *  to run the pager program before its time.
 *//**
     * Keep every part of the value between the delimiters.
     *//**
     * Even if the value begins with quote characters, do not do quote
     * processing.  Strip leading and trailing white space.
     *//**
     *  If the value looks like a quoted string, then process it.  Double
     *  quoted strings are processed the way strings are in "C" programs,
     *  except they are treated as regular characters if the following
     *  character is not a well-established escape sequence.  Single quoted
     *  strings (quoted with apostrophies) are handled the way strings are
     *  handled in shell scripts, *except* that backslash escapes are
     *  honored before backslash escapes and apostrophies.
     *//**
 *  When loading a line (or block) of text as an option, the value can
 *  be processed in any of several modes.
 *//**
 * An initialzation phase or an option being loaded from program sources.
 *//**
 * handling normal options.  Start with first config file, then environment
 * variables and finally the command line.
 *//**
 * handling option presets.  Start with command line and work through
 * config settings in reverse order.
 *//*
 *  Convert the number to a list usable in a printf call
 *//* The __attribute__((__warn_unused_result__)) feature
   is available in gcc versions 3.4 and newer,
   while the typeof feature has been available since 2.7 at least.  *//**
 *  Coercive cast.  Compel an address to be interpreted as the type
 *  of the first argument.  No complaints, just do it.
 *//**
    *  Command line usage problem
    *//**
    *  AutoOpts Software failure.
    *//**
    *  option state was requested from a file that cannot be loaded.
    *//**
    *  The input data was incorrect in some way.
    *//*
 *  This file is part of AutoOpts, a companion to AutoGen.
 *  AutoOpts is free software.
 *  AutoOpts is Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
 *
 *  AutoOpts is available under any one of two licenses.  The license
 *  in use must be one of these two and the choice is under the control
 *  of the user of the license.
 *
 *   The GNU Lesser General Public License, version 3 or later
 *      See the files "COPYING.lgplv3" and "COPYING.gplv3"
 *
 *   The Modified Berkeley Software Distribution License
 *      See the file "COPYING.mbsd"
 *
 *  These files have the following sha256 sums:
 *
 *  8584710e9b04216a394078dc156b781d0b47e1729104d666658aecef8ee32e95  COPYING.gplv3
 *  4379e7444a0e2ce2b12dd6f5a52a27a4d02d39d247901d3285c88cf0d37f477b  COPYING.lgplv3
 *  13aa749a5b0a454917a944ed8fffc530b784f5ead522b1aacaf4ec8aa55a6239  COPYING.mbsd
 *//*
 *  \file autoopts.h
 *
 *  This file defines all the global structures and special values
 *  used in the automated option processing library.
 *
 * @group autoopts
 * @{
 */pOptspOptDesc/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/directive.h<inttypes.h>doDir_hdl_tdirective_enum_tDIR_INVALIDDIR_ASSERTDIR_DEFINEDIR_ELIFDIR_ELSEDIR_ENDIFDIR_ENDMACDIR_ENDSHELLDIR_ERRORDIR_IDENTDIR_IFDIR_IFDEFDIR_IFNDEFDIR_INCLUDEDIR_LETDIR_LINEDIR_MACDEFDIR_OPTIONDIR_PRAGMADIR_SHELLDIR_UNDEFDIR_COUNTSTR2ENUM_DIRECTIVE_H_GUARDMISSING_INTTYPES_HdoDir_undefdoDir_shelldoDir_pragmadoDir_optiondoDir_macdefdoDir_linedoDir_letdoDir_includedoDir_ifndefdoDir_ifdefdoDir_ifdoDir_identdoDir_errordoDir_endshelldoDir_endmacdoDir_endifdoDir_elsedoDir_elifdoDir_definedoDir_assertdoDir_invaliddoDir_directive_dispdirective_namefind_directive/* end of directive.h *//* STR2ENUM_DIRECTIVE_H_GUARD *//** \file directive.h
 * Header for string to enumeration values and back again.
 * @addtogroup autogen
 * @{
 *//*   -*- buffer-read-only: t -*- vi: set ro:
 *
 *  DO NOT EDIT THIS FILE   (directive.h)
 *
 *  It has been AutoGen-ed
 *  From the definitions    directive.def
 *  and the template file   str2enum
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name ``Bruce Korb'' nor the name of any other
 *    contributor may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * str2enum IS PROVIDED BY Bruce Korb ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bruce Korb OR ANY OTHER CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Command/Keyword Dispatcher
 */scan_next/usr/include/x86_64-linux-gnu/bits/libc-header-start.h__GLIBC_USE_IEC_60559_TYPES_EXT__GLIBC_USE_IEC_60559_FUNCS_EXT_C2X__GLIBC_USE_IEC_60559_FUNCS_EXT__GLIBC_USE_IEC_60559_EXT__GLIBC_USE_IEC_60559_BFP_EXT_C2X__GLIBC_USE_IEC_60559_BFP_EXT__GLIBC_USE_LIB_EXT2__GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATIONdefined __USE_GNU || defined __STDC_WANT_IEC_60559_BFP_EXT____GLIBC_USE (IEC_60559_BFP_EXT) || __GLIBC_USE (ISOC2X)__GLIBC_USE (IEC_60559_BFP_EXT) || defined __STDC_WANT_IEC_60559_EXT__defined __USE_GNU || defined __STDC_WANT_IEC_60559_FUNCS_EXT____GLIBC_USE (IEC_60559_FUNCS_EXT) || __GLIBC_USE (ISOC2X)defined __USE_GNU || defined __STDC_WANT_IEC_60559_TYPES_EXT__ISOC2XIEC_60559_FUNCS_EXTIEC_60559_BFP_EXT/* ISO/IEC TS 18661-3:2015 defines the
   __STDC_WANT_IEC_60559_TYPES_EXT__ macro.  *//* ISO/IEC TS 18661-4:2015 defines the
   __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
   functions, the symbols from this TS are enabled unconditionally in
   C2X.  *//* ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
   macro.  Most but not all symbols enabled by that macro in TS
   18661-1 are enabled unconditionally in C2X.  In C2X, the symbols in
   Annex F still require a new feature test macro
   __STDC_WANT_IEC_60559_EXT__ instead (C2X does not define
   __STDC_WANT_IEC_60559_BFP_EXT__), while a few features from TS
   18661-1 are not included in C2X (and thus should depend on
   __STDC_WANT_IEC_60559_BFP_EXT__ even when C2X features are
   enabled).

   __GLIBC_USE (IEC_60559_BFP_EXT) controls those features from TS
   18661-1 not included in C2X.

   __GLIBC_USE (IEC_60559_BFP_EXT_C2X) controls those features from TS
   18661-1 that are also included in C2X (with no feature test macro
   required in C2X).

   __GLIBC_USE (IEC_60559_EXT) controls those features from TS 18661-1
   that are included in C2X but conditional on
   __STDC_WANT_IEC_60559_EXT__.  (There are currently no features
   conditional on __STDC_WANT_IEC_60559_EXT__ that are not in TS
   18661-1.)  *//* ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
   macro.  *//* This header is internal to glibc and should not be included outside
   of glibc headers.  Headers including it must define
   __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
   cannot have multiple include guards because ISO C feature test
   macros depend on the definition of the macro when an affected
   header is included, not when the first system header is
   included.  *//* Handle feature test macros at the start of a header.
   Copyright (C) 2016-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/wchar2.hwcsnrtombsalways_inlineartificialchar *__restrict__const wchar_tconst wchar_t *const wchar_t **int **const wchar_t **__restrict__mbstate_t *mbstate_t *__restrict__wcsnrtombs (char *__restrict __dst, const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps)__lensizeof (char)__glibc_objsize (__dst)__builtin_object_size (__dst, 2 > 1)__dst, __src, __nwc, __len, __ps__dst(__SIZE_TYPE__) (__len)(long unsigned int) (__len)__builtin_constant_p__builtin_object_size__wcsnrtombs_chk_warn__wcsnrtombs_alias__wcsnrtombs_chkmbsnrtowcswchar_t *wchar_t *__restrict__const char **const char **__restrict__mbsnrtowcs (wchar_t *__restrict __dst, const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps)sizeof (wchar_t)__dst, __src, __nmc, __len, __ps__mbsnrtowcs_chk_warn__mbsnrtowcs_alias__mbsnrtowcs_chkwcsrtombswcsrtombs (char *__restrict __dst, const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps)__dst, __src, __len, __ps__wcsrtombs_chk_warn__wcsrtombs_alias__wcsrtombs_chkmbsrtowcsmbsrtowcs (wchar_t *__restrict __dst, const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps)__src__nwc__ps__nmc__mbsrtowcs_chk_warn__mbsrtowcs_alias__mbsrtowcs_chkwcrtombwcrtomb (char *__restrict __s, wchar_t __wchar, mbstate_t *__restrict __ps)__s(size_t) -1__WCHAR_MB_LEN_MAX__wcrtomb_alias__wcrtomb_chkfgetws_unlocked__FILE *__FILE *__restrict____n(__SIZE_TYPE__) (__n)(long unsigned int) (__n)__fgetws_unlocked_chk_warn__fgetws_unlocked_alias__fgetws_unlocked_chkfgetws__fgetws_chk_warn__fgetws_alias__fgetws_chkvfwprintfconst wchar_t *__restrict____va_list_tag *vwprintffwprintf__builtin_va_arg_packwprintf__vwprintf_chk__vfwprintf_chk__wprintf_chk__fwprintf_chkvswprintfvswprintf (wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __fmt, __gnuc_va_list __ap)__vswprintf_alias__vswprintf_chkswprintfswprintf (wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __fmt, ...)__swprintf_alias__swprintf_chkwcsncatwcsncat (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n)__dest__wchar__stream__fmt__ap__wcsncat_alias__wcsncat_chkwcscatwcscat (wchar_t *__restrict __dest, const wchar_t *__restrict __src)__wcscat_alias__wcscat_chkwcpncpywcpncpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n)__glibc_objsize (__dest)__builtin_object_size (__dest, 2 > 1)__dest, __src, __n__wcpncpy_chk_warn__wcpncpy_alias__wcpncpy_chkwcsncpywcsncpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n)__wcsncpy_chk_warn__wcsncpy_alias__wcsncpy_chkwcpcpywcpcpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src)__wcpcpy_alias__wcpcpy_chkwcscpywcscpy (wchar_t *__restrict __dest, const wchar_t *__restrict __src)__wcscpy_alias__wcscpy_chkwmemsetwmemset (wchar_t *__s, wchar_t __c, size_t __n)__glibc_objsize0 (__s)__builtin_object_size (__s, 0)__s, __c, __n__c__wmemset_chk_warn__wmemset_alias__wmemset_chkwmempcpywmempcpy (wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n)__glibc_objsize0 (__s1)__builtin_object_size (__s1, 0)__s1, __s2, __n__s1__wmempcpy_chk_warn__wmempcpy_alias__wmempcpy_chkwmemmovewmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)__wmemmove_chk_warn__wmemmove_alias__wmemmove_chkwmemcpywmemcpy (wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n)__wmemcpy_chk_warn__wmemcpy_alias__wmemcpy_chk_WCHAR_H__va_arg_pack!defined __cplusplus__USE_FORTIFY_LEVEL > 1defined MB_LEN_MAX && MB_LEN_MAX != __WCHAR_MB_LEN_MAX"wcsnrtombs called with dst buffer smaller than len"wcsnrtombs called with dst buffer smaller than lenchar[51]warning(char *__restrict __dst, const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen)(char *__restrict __dst, const wchar_t **__restrict __src, size_t __nwc, size_t __len, mbstate_t *__restrict __ps)"mbsnrtowcs called with dst buffer smaller than len " "* sizeof (wchar_t)"mbsnrtowcs called with dst buffer smaller than len * sizeof (wchar_t)char[70](wchar_t *__restrict __dst, const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen)(wchar_t *__restrict __dst, const char **__restrict __src, size_t __nmc, size_t __len, mbstate_t *__restrict __ps)"wcsrtombs called with dst buffer smaller than len"wcsrtombs called with dst buffer smaller than lenchar[50](char *__restrict __dst, const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen)(char *__restrict __dst, const wchar_t **__restrict __src, size_t __len, mbstate_t *__restrict __ps)"mbsrtowcs called with dst buffer smaller than len " "* sizeof (wchar_t)"mbsrtowcs called with dst buffer smaller than len * sizeof (wchar_t)char[69](wchar_t *__restrict __dst, const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps, size_t __dstlen)(wchar_t *__restrict __dst, const char **__restrict __src, size_t __len, mbstate_t *__restrict __ps)(char *__restrict __s, wchar_t __wchar, mbstate_t *__restrict __ps)"fgetws_unlocked called with bigger size than length " "of destination buffer"fgetws_unlocked called with bigger size than length of destination bufferchar[74](wchar_t *__restrict __s, size_t __size, int __n, __FILE *__restrict __stream)(wchar_t *__restrict __s, int __n, __FILE *__restrict __stream)"fgetws called with bigger size than length " "of destination buffer"fgetws called with bigger size than length of destination bufferchar[65](wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __fmt, __gnuc_va_list __ap)(wchar_t *__restrict __s, size_t __n, const wchar_t *__restrict __fmt, ...)(wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n)(wchar_t *__restrict __dest, const wchar_t *__restrict __src)"wcpncpy called with length bigger than size of destination " "buffer"wcpncpy called with length bigger than size of destination bufferchar[66](wchar_t *__restrict __dest, const wchar_t *__restrict __src, size_t __n, size_t __destlen)"wcsncpy called with length bigger than size of destination " "buffer"wcsncpy called with length bigger than size of destination buffer"wmemset called with length bigger than size of destination " "buffer"wmemset called with length bigger than size of destination buffer(wchar_t *__s, wchar_t __c, size_t __n, size_t __ns)(wchar_t *__s, wchar_t __c, size_t __n)"wmempcpy called with length bigger than size of destination " "buffer"wmempcpy called with length bigger than size of destination bufferchar[67](wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n, size_t __ns1)(wchar_t *__restrict __s1, const wchar_t *__restrict __s2, size_t __n)"wmemmove called with length bigger than size of destination " "buffer"wmemmove called with length bigger than size of destination buffer(wchar_t *__s1, const wchar_t *__s2, size_t __n, size_t __ns1)__s2__dstlen__p__size__flag__format__s_len__destlen__ns__ns1(wchar_t *__s1, const wchar_t *__s2, size_t __n)"wmemcpy called with length bigger than size of destination " "buffer"wmemcpy called with length bigger than size of destination buffer"wcpcpy""wcscpy"long unsigned int"__wmemset_chk""wmemset""__wmempcpy_chk""wmempcpy""__mbsrtowcs_chk""mbsrtowcs""wcrtomb""__fgetws_unlocked_chk""fgetws_unlocked""__wcsnrtombs_chk""wcsnrtombs""__mbsnrtowcs_chk""mbsnrtowcs""__wcsrtombs_chk""wcsrtombs""__fgetws_chk""fgetws""vswprintf""swprintf""wcsncat""wcscat""__wcpncpy_chk""wcpncpy""__wcsncpy_chk""wcsncpy""__wmemmove_chk""wmemmove""__wmemcpy_chk""wmemcpy"/* We would have to include <limits.h> to get a definition of MB_LEN_MAX.
     But this would only disturb the namespace.  So we define our own
     version here.  *//* __attribute__ ((__format__ (__wprintf__, 5, 0))) *//* XXX We might want to have support in gcc for swprintf.  *//* __attribute__ ((__format__ (__wprintf__, 5, 6))) *//* Checking macros for wchar functions.
   Copyright (C) 2005-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/wchar.h<bits/floatn.h><bits/wchar2.h><bits/types/locale_t.h><bits/types/FILE.h><bits/types/__FILE.h><bits/types/mbstate_t.h><bits/types/wint_t.h><bits/wchar.h><bits/libc-header-start.h>wcsftime_lconst tmconst tm *tm *const tm *__restrict__wcsftimefputws_unlockedputwchar_unlockedputwc_unlockedfputwc_unlockedfgetwc_unlockedgetwchar_unlockedgetwc_unlockedungetwcfputwsputwcharputwcfputwcgetwchargetwcfgetwcvswscanfvwscanfvfwscanfswscanfwscanffwscanffwideopen_wmemstreamwchar_t **wcstof64x_lwchar_t **__restrict__wcstof32x_lwcstof128_lwcstof64_lwcstof32_lwcstold_lwcstof_lwcstod_lwcstoull_lwcstoll_lwcstoul_lwcstol_lwcstouqwcstoqwcstoullwcstollwcstoulwcstolwcstof64xwcstof32xwcstof128wcstof64wcstof32wcstoldwcstofwcstodwcswidthwcwidthmbrlenmbrlen (const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps)wctobwctob (wint_t __wc)L'\0'L'\x7f'__wctob_aliaswint_tbtowcbtowc (int __c)'\0''\x7f'__btowc_alias__mbrlenmbrtowcmbsinitconst mbstate_tconst mbstate_t *wmemcmpwmemchrwcsnlenwcswcswcslenwcstokwcsstrwcspbrkwcsspnwcscspnwcschrnulwcsrchrwcschrwcsdupwcsxfrm_lwcscoll_lwcsxfrmwcscollwcsncasecmp_lwcscasecmp_lwcsncasecmpwcscasecmpwcsncmpwcscmpWEOF(0xffffffffu)__need___va_listdefined __cplusplus && __GNUC_PREREQ (4, 4)WCHAR_MIN(defined __USE_XOPEN && !defined __USE_GNU \__CORRECT_ISO_CPP_WCHAR_H_PROTO__HAVE_FLOAT16 && defined __USE_GNU__HAVE_FLOAT32 && defined __USE_GNU__HAVE_FLOAT64 && defined __USE_GNU__HAVE_FLOAT128 && defined __USE_GNU__HAVE_FLOAT32X && defined __USE_GNU__HAVE_FLOAT64X && defined __USE_GNU__HAVE_FLOAT128X && defined __USE_GNU__HAVE_FLOAT16__HAVE_FLOAT32__HAVE_FLOAT64__HAVE_FLOAT128__HAVE_FLOAT32X__HAVE_FLOAT64X__HAVE_FLOAT128Xdefined __USE_XOPEN2K8 || __GLIBC_USE (LIB_EXT2)__attr_dealloc_fclosedefined __has_builtin__has_builtin (__builtin_fclose)defined __USE_ISOC95 || defined __USE_UNIX98!__GLIBC_USE (DEPRECATED_SCANF) && !defined __LDBL_COMPAT \!__GLIBC_USE (DEPRECATED_SCANF) \__USE_FORTIFY_LEVEL > 0 && defined __fortify_functiondefined __LDBL_COMPAT || __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI == 1(const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg)__isoc99_vswscanf(const wchar_t *__restrict __format, __gnuc_va_list __arg)__isoc99_vwscanf(__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg)__isoc99_vfwscanf(const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...)__isoc99_swscanf(const wchar_t *__restrict __format, ...)__isoc99_wscanf(__FILE *__restrict __stream, const wchar_t *__restrict __format, ...)__isoc99_fwscanf"__isoc99_wscanf""__isoc99_fwscanf"DEPRECATED_SCANFfcloseLIB_EXT2"__isoc99_vswscanf""__isoc99_vwscanf""__isoc99_vfwscanf""__isoc99_swscanf"__builtin_free/* wchar.h  *//* Define some macros helping to catch buffer overflows.  *//* Similar to `wcsftime' but takes the information from
   the provided locale and not the global locale.  *//* Format TP into S according to FORMAT.
   Write no more than MAXSIZE wide characters and return the number
   of wide characters written, or 0 if it would exceed MAXSIZE.  *//* This function does the same as `fputws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  *//* This function does the same as `fgetws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  *//* These are defined to be equivalent to the `char' functions defined
   in POSIX.1:1996.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  *//* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  *//* This is the wide character version of a GNU extension.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  *//* Push a character back onto the input buffer of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Write a string to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Get a newline-terminated wide character string of finite length
   from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Write a character to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  *//* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  *//* Use ISO C99. *//* __attribute__ ((__format__ (__wscanf__, 2, 0))) *//* __attribute__ ((__format__ (__wscanf__, 1, 0))) *//* Same redirection as above for the v*wscanf family.  *//* Read formatted input from S into argument list ARG.  *//* Read formatted input from stdin into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Read formatted input from S into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Use ISO C95, C99 and Unix98. *//* __attribute__ ((__format__ (__wscanf__, 2, 3))) *//* __attribute__ ((__format__ (__wscanf__, 1, 2))) *//* For historical reasons, the C99-compliant versions of the scanf
   functions are at alternative names.  When __LDBL_COMPAT or
   __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI are in effect, this is handled in
   bits/wchar-ldbl.h.  *//* Read formatted input from S.  *//* Read formatted input from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Read formatted input from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* __attribute__ ((__format__ (__wprintf__, 3, 0))) *//* Write formatted output of at most N character to S from argument
   list ARG.  *//* __attribute__ ((__format__ (__wprintf__, 1, 0))) *//* Write formatted output to stdout from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* __attribute__ ((__format__ (__wprintf__, 2, 0))) *//* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* __attribute__ ((__format__ (__wprintf__, 3, 4))) *//* Write formatted output of at most N characters to S.  *//* __attribute__ ((__format__ (__wprintf__, 1, 2))) *//* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* __attribute__ ((__format__ (__wprintf__, 2, 3))) *//* Write formatted output to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  *//* Select orientation for stream.  *//* Like OPEN_MEMSTREAM, but the stream is wide oriented and produces
   a wide character string.  *//* If the attribute macro hasn't been defined yet (by <stdio.h>) and
   fclose is a built-in, use it.  *//* Wide character I/O functions.  *//* Copy no more than N characters of SRC to DEST, returning the address of
   the last character written into DEST.  *//* Copy SRC to DEST, returning the address of the terminating L'\0' in
   DEST.  *//* use GNU *//* Parallel versions of the functions above which take the locale to
   use as an additional parameter.  These are GNU extensions inspired
   by the POSIX.1-2008 extended locale API.  *//* Use GNU.  *//* Convert initial portion of wide string NPTR to `unsigned long long int'
   representation.  *//* Convert initial portion of wide string NPTR to `long long int'
   representation.  *//* ISO C99.  *//* Convert initial portion of wide string NPTR to `unsigned long int'
   representation.  *//* Convert initial portion of wide string NPTR to `long int'
   representation.  *//* Likewise for `_FloatN' and `_FloatNx' when support is enabled.  *//* C99 *//* Likewise for `float' and `long double' sizes of floating-point numbers.  *//* Convert initial portion of the wide string NPTR to `double'
   representation.  *//* Use X/Open.  *//* Determine number of column positions required for first N wide
   characters (or fewer if S ends before this) in S.  *//* Determine number of column positions required for C.  *//* The following functions are extensions found in X/Open CAE.  *//* use POSIX 2008 *//* Write multibyte character representation of at most NWC characters
   from the wide character string SRC to DST.  *//* Write wide character representation of at most NMC bytes of the
   multibyte character string SRC to DST.  *//* Write multibyte character representation of wide character string
   SRC to DST.  *//* Write wide character representation of multibyte character string
   SRC to DST.  *//* We can use the BTOWC and WCTOB optimizations since we know that all
   locales must use ASCII encoding for the values in the ASCII range
   and because the wchar_t encoding is always ISO 10646.  *//* Define inline function as optimization.  *//* Return number of bytes in multibyte character pointed to by S.  *//* Write multibyte representation of wide character WC to S.  *//* Write wide character representation of multibyte character pointed
   to by S to PWC.  *//* Determine whether PS points to an object representing the initial
   state.  *//* Determine whether C corresponds to a member of the extended
   character set whose multibyte representation is a single byte.  *//* Determine whether C constitutes a valid (one-byte) multibyte
   character.  *//* Copy N wide characters of SRC to DEST and return pointer to following
   wide character.  *//* Set N wide characters of S to C.  *//* Copy N wide characters of SRC to DEST, guaranteeing
   correct behavior for overlapping strings.  *//* Copy N wide characters of SRC to DEST.  *//* Compare N wide characters of S1 and S2.  *//* Search N wide characters of S for C.  *//* Return the number of wide characters in S, but at most MAXLEN.  *//* Another name for `wcsstr' from XPG4.  *//* Return the number of wide characters in S.  *//* Divide WCS into tokens separated by characters in DELIM.  *//* Find the first occurrence of NEEDLE in HAYSTACK.  *//* Find the first occurrence in WCS of any character in ACCEPT.  *//* Return the length of the initial segmet of WCS which
   consists entirely of wide characters in  ACCEPT.  *//* Return the length of the initial segmet of WCS which
   consists entirely of wide characters not in REJECT.  *//* This function is similar to `wcschr'.  But it returns a pointer to
   the closing NUL wide character in case C is not found in S.  *//* Find the last occurrence of WC in WCS.  *//* Find the first occurrence of WC in WCS.  *//* Duplicate S, returning an identical malloc'd string.  *//* Transform S2 into array pointed to by S1 such that if wcscmp is
   applied to two transformed strings the result is the as applying
   `wcscoll' to the original strings.  *//* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the given locale.  *//* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  *//* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the current locale.  *//* Compare no more than N chars of S1 and S2, ignoring case.  *//* Compare S1 and S2, ignoring case.  *//* Compare N wide-characters of S1 and S2.  *//* Compare S1 and S2.  *//* Append no more than N wide-characters of SRC onto DEST.  *//* Append SRC onto DEST.  *//* Copy no more than N wide-characters of SRC to DEST.  *//* Copy SRC to DEST.  *//* This incomplete type is defined in <time.h> but needed here because
   of `wcsftime'.  *//* All versions of XPG prior to the publication of ISO C99 required
   the bulk of <wctype.h>'s declarations to appear in this header
   (because <wctype.h> did not exist prior to C99).  In POSIX.1-2001
   those declarations were marked as XSI extensions; in -2008 they
   were additionally marked as obsolescent.  _GNU_SOURCE mode
   anticipates the removal of these declarations in the next revision
   of POSIX.  *//* These constants might also be defined in <inttypes.h>.  *//* Tell the caller that we provide correct C++ prototypes.  *//* Gather machine dependent type support.  *//*
 *      ISO C99 Standard: 7.24
 *	Extended multibyte and wide character utilities	<wchar.h>
 *//* Copyright (C) 1995-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__wc__maxsize__tp__loc__ws__fp__bufloc__sizeloc__nptr__endptr__base__pwc__maxlen__haystack__needle__delim__ptr__wcs__accept__reject/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/snprintfv/compat.h<stdbool.h><wchar.h><memory.h><errno.h>snv_long_doublesnv_constpointersnv_pointersnv_wint_tsnv_wchar_tABS(a)((a) < 0 ? -(a) : (a))freturn_val_if_fail(stream,expr,val)SNV_STMT_START { if (!(expr)) { fprintf (stream, SNV_ASSERT_FMT, __FILE__, __LINE__, SNV_ASSERT_FCN, _SNV_STR(expr)); return val; }; } SNV_STMT_ENDreturn_val_if_fail(expr,val)freturn_val_if_fail(stderr, expr, val)freturn_if_fail(expr)SNV_STMT_START { if (!(expr)) { fprintf (stream, SNV_ASSERT_FMT, __FILE__, __LINE__, SNV_ASSERT_FCN, _SNV_STR(expr)); return; }; } SNV_STMT_ENDreturn_if_fail(expr)freturn_if_fail(stderr, expr)snv_fassert(stream,expr)SNV_STMT_START { if (!(expr)) { fprintf (stream, SNV_ASSERT_FMT, __FILE__, __LINE__, SNV_ASSERT_FCN, _SNV_STR(expr)); exit(EXIT_FAILURE); }; } SNV_STMT_ENDsnv_assert(expr)snv_fassert(stderr, expr)SNV_ASSERT_FMT"file %s: line %d%s%s%s: assertion \"%s\" failed.\n"SNV_ASSERT_FCN" (", __PRETTY_FUNCTION__, ")"SNV_GNUC_NORETURNSNV_GNUC_PRINTF(args,format_idx,arg_idx)args __attribute__((format (printf, format_idx, arg_idx)))SNV_GNUC_PRINTFSNV_SCOPESNV_STMT_END)SNV_STMT_START(void)(PARAMS(args)SNV_ULONG_TO_POINTER(u)((snv_pointer)(unsigned long)(u))SNV_LONG_TO_POINTER(i)((snv_pointer)(long)(i))SNV_POINTER_TO_ULONG(p)((unsigned long)(p))SNV_POINTER_TO_LONG(p)((long)(p))SNV_WITH_LOCKED_FP(fp,tmp_var)for (tmp_var = 1; tmp_var--; )SNV_PUTC_UNLOCKEDSNV_FPUTC_UNLOCKED_SNV_STR(x)#xsigned__signed__inline__constGCC_VERSION(__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)SNV_USING_STDARG_HVA_END(a)va_end(a)VA_START(a,f)va_start(a, f)NO_FLOAT_PRINTINGSNV_END_EXTERN_C__EXTENSIONS__SNPRINTFV_COMPAT_HHAVE_SYS_TYPES_HHAVE_STDLIB_HHAVE_ERRNO_Herrnodefined( HAVE_LIMITS_H )defined( HAVE_SYS_LIMITS_H )defined( HAVE_VALUES_H )MAXINTdefined( HAVE_STRING_H )defined( HAVE_STRINGS_H )defined( HAVE_MEMORY_H )defined( HAVE_INTTYPES_H )defined( HAVE_STDINT_H )HAVE_UINTMAX_Tdefined( HAVE_LONG_LONG )defined( HAVE_STDARG_H )VA_STARTdefined( HAVE_VARARGS_H )HAVE_RUNETYPE_HHAVE_WCHAR_HHAVE_WCHAR_THAVE_WINT_TGCC_VERSION > 40400GCC diagnostic ignored "-Wextra"GCC diagnostic ignored "-Wconversion"GCC diagnostic ignored "-Wsign-conversion"GCC diagnostic ignored "-Wstrict-overflow"__STDC__defined(HAVE_FPUTC_UNLOCKED) && defined(HAVE_FLOCKFILE)HAVE_STDBOOL_H__CYGWIN32____CYGWIN___WIN32PARAMSdefined (__GNUC__) && !defined (__STRICT_ANSI__) && !defined (__cplusplus)(defined (sun) || defined (__sun__))DLL_EXPORTLIBSNPRINTFV_DLL_IMPORTGCC_VERSION > 20400MAXMINABSHAVE_STRTOUL__GNUC_PATCHLEVEL__/*
 * Local Variables:
 * mode: C
 * c-file-style: "gnu"
 * indent-tabs-mode: nil
 * End:
 * end of snprintfv/compat.h *//* SNPRINTFV_COMPAT_H *//* GCC_VERSION *//*
 * Define macros for storing integers inside pointers.
 * Be aware that it is only safe to use these macros to store `int'
 * values in `char*' (or `void*') words, and then extract them later.
 * Although it will work the other way round on many common
 * architectures, it is not portable to assume a `char*' can be
 * stored in an `int' and extracted later without loss of the msb's
 *//* inline and const keywords are (mostly) handled by config.h *//* VA_START *//* MAXINT *//* Some sytems #define this! *//* __cplusplus *//* and another way to call for it *//* exact same thing as above   *//* for strsignal in GNU's libc *//*  -*- Mode: C -*-
 * --------------------------------------------------------------------
 * compat.h.in --- verbose but portable cpp defines for snprintfv
 * Copyright (C) 1999 Gary V. Vaughan
 * Originally by Gary V. Vaughan, 1999
 * This file is part of Snprintfv
 *
 * Snprintfv is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * Snprintfv program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses>.
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that also links with and
 * uses the libopts library from AutoGen, you may include it under
 * the same distribution terms used by the libopts library.
 *
 * Code:  *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/snprintfv/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/snprintfv/stream.hstream_getSTREAM *stream *stream_putsstream_putstream_detailsstream_deletestream_newStreamGetStreamPutSTREAMSNV_UNLIMITED(~0UL)STREAM_WRITABLE(1 << 1)STREAM_READABLESTREAM_H87 "stream.in"/* STREAM_H *//* This brace is so that emacs can still indent properly: *//**
 * stream_get:
 * @stream: The stream to be read from.
 *
 * This function will try to read a single character from @stream.
 *
 * Return value:
 * If an error occurs or the end of @stream is reached, -1 is returned.
 * Under normal circumstances the value if the character read (cast to
 * an int) is returned.
 **//**
 * stream_puts:
 * @s: A string to be placed in @stream.
 * @stream: The stream to be written to.
 *
 * This function will @ch in @stream if that stream's output limit will
 * not be exceeded.
 *
 * Return value:
 * If any other error occurs, that error code is returned unchanged.
 * This is of course dependant on what the handler function uses to
 * indicate an error.  If the stream becomes full, the remaining
 * characters are not printed.  If the stream's writing function
 * always succeeds, the number of characters emitted or skipped is
 * returned.
 **//**
 * stream_put:
 * @ch: A single character to be placed in @stream.
 * @stream: The stream to be written to.
 *
 * This function will @ch in @stream if that stream's output limit will
 * not be exceeded.
 *
 * Return value:
 * If @stream is full, return 1.  Otherwise, if any other error occurs,
 * that error code is returned unchanged.  This is of course dependant
 * on what the handler function uses to indicate an error.  If the stream
 * is not full and the stream's writing function succeeds, 1 (the number of
 * characters emitted!) is returned.
 **//**
 * stream_details:
 * @stream: the stream being queried.
 *
 * The finalization function specified when @stream was created (if any)
 * is called, and then the memory associated with @stream is recycled.
 * It is the responsibility of the finalization function to recycle, or
 * otherwise manage, any memory associated with the user supplied %dets.
 * Return value:
 * This function returns the stream details associated with @stream
 * when it was originally created.
 **//**
 * stream_delete: destructor
 * @stream: The stream pending deletion
 *
 * The memory associated with @stream is recycled.

 * Return value:
 * The %dets supplied by the user when the stream was created are
 * returned for handling by the calling function.
 **//**
 * stream_new: constructor
 * @dets: user supplied stream details to be passed into the various funcs.
 * @limit: the maximum number of consecutive bytes to fit in @dets.
 * @get_func: function to get a character from @dets stream.
 * @put_func: function to put a character in @dets stream.
 *
 * Allocate and initialize a new %STREAM data type.  The @get_func
 * and @put_func can be NULL if you intend to create a non-readable
 * or non-writable stream, respectively.
 *
 * Return value:
 * The address of the newly allocated and initialised stream is returned.
 **//**
 * StreamGet:
 * @stream:  The stream being read from.
 *
 * Type of the function to get a character from a readable stream.
 *
 * Return value:
 * The function should return the character read from the
 * stream, cast to an int if it was read successfully, or
 * else %EOF, if the read failed.
 **//**
 * StreamPut:
 * @ch: The character to write to @stream cast to an int.
 * @stream:  The stream being written to.
 *
 * Type of the function to put a character in a writeable stream.
 *
 * Return value:
 * The function should return the character written to the
 * stream, cast to an int if it was written successfully, or
 * else %EOF, if the write failed.
 **//**
 * STREAM:
 * Data type used to pass details of streams between functions,
 * much like stdio's %FILE, but more flexible.  A %STREAM can be uni- or
 * bi-directional depending on how it is initialised.
 **//**
 * SNV_UNLIMITED:
 * Used to denote that there is no upper limit to the number of characters
 * that can safely be written to a stream.
 **//* Code: *//* stream.h --- customizable stream routines
 * Copyright (C) 1998, 1999, 2000, 2002 Gary V. Vaughan
 * Originally by Gary V. Vaughan, 1998
 * This file is part of Snprintfv
 *
 * Snprintfv is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * Snprintfv program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses>.
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that also links with and
 * uses the libopts library from AutoGen, you may include it under
 * the same distribution terms used by the libopts library.
 *//*  -*- Mode: C -*-  */detslimitget_funcput_func/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/snprintfv/printf.h<snprintfv/mem.h><snprintfv/stream.h><snprintfv/filament.h><snprintfv/compat.h>snv_asprintfvconst snv_constpointerconst snv_constpointer[]void *[]snv_vasprintfsnv_asprintfsnv_filputcsnv_snprintfvchar[]snv_vsnprintfsnv_snprintfsnv_sprintfvsnv_vsprintfsnv_sprintfsnv_bufputcsnv_fprintfvsnv_vfprintfsnv_fprintfsnv_printfvsnv_vprintfsnv_printfsnv_fileputcsnv_dprintfvsnv_vdprintfsnv_dprintfsnv_fdputcstream_printfstream_vprintfstream_printfvconst snv_constpointer *parse_printf_formatprintf_errorprintf_info *printf_strerrorspec_entry *register_printf_functionprintf_function *const printf_argconst printf_arg *printf_arg *printf_arginfo_function *printf_genericprintf_info *constprintf_generic_infoPA_INTPA_CHARPA_WCHARPA_STRINGPA_WSTRINGPA_POINTERPA_FLOATPA_DOUBLEPA_LASTPA_UNKNOWNregister_callback_functionspec_entryprintf_arginfo_functionprintf_functionprintf_argprintf_infosnv_statusSNV_ERRORSNV_OKspec_keypa_pointerconst snv_wchar_tconst snv_wchar_t *pa_wstringpa_stringpa_long_doublepa_doublepa_floatpa_u_long_long_intpa_u_long_intpa_u_intpa_u_short_intpa_long_long_intpa_long_intpa_intpa_short_intpa_wcharpa_charwideshowsignleftspacealtis_longis_shortis_charis_long_doublespecextrawidthprecdollarargindexFilament *filament *snprintfvprintfvsprintfvfprintfvdprintfvasprintfvvasprintfasprintfvsnprintfsnprintfvsprintfsprintfvfprintffprintfvdprintfdprintfvprintfprintfSNV_EMIT(ch,stream,count)SNV_STMT_START { if ((stream)) { if ((count) >= 0) { int m_status = stream_put((unsigned char) (ch), (stream)); (count) = m_status < 0 ? m_status : (count) + m_status; } } else { (void)(ch); (count)++; } } SNV_STMT_ENDPA_FLAG_PTR(1 << 13)PA_FLAG_CHAR(1 << 12)PA_FLAG_UNSIGNED(1 << 11)PA_FLAG_SHORT(1 << 10)PA_FLAG_LONG(1 << 9)PA_FLAG_LONG_DOUBLEPA_FLAG_LONG_LONG(1 << 8)PA_FLAG_MASK~SNV_TYPE_MASKPA_TYPE_MASK0x00ffPRINTF_ERROR(pi,str)printf_error(pi, __FILE__, __LINE__, SNV_ASSERT_FCN, str);SNV_STATE_USER_MASK~(SNV_STATE_USER_FIRST - 1)SNV_STATE_USER_FIRSTSNV_STATE_SPECIFIER(1 << 5)SNV_STATE_MODIFIER(1 << 4)SNV_STATE_PRECISION(1 << 3)SNV_STATE_WIDTH(1 << 2)SNV_STATE_FLAGSNV_STATE_ENDSNV_STATE_BEGINSNPRINTFV_SNPRINTFV_H266 "printf.in"267 "printf.in"268 "printf.in"COMPILING_PRINTF_C/* snprintfv.h ends here *//* SNPRINTFV_SNPRINTFV_H *//* !COMPILING_SNPRINTFV_C *//* If you don't want to use snprintfv functions for *all* of your string
   formatting API, then define COMPILING_SNPRINTFV_C and use the snv_
   prefix for the entry points below. *//**
 * snv_asprintfv: printf.h
 * @result: the address of a char * variable.
 * @format: a % delimited format string.
 * @args: a vector of argument addresses to match @format.
 *
 * Format the elements of @args according to @format, and write
 * the results to an internally allocated buffer whose address is
 * stored in @result (and should be freed by the caller) unless
 * there is an error.
 *
 * Above moaning for asprintf applies here too.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_vasprintf: printf.h
 * @result: the address of a char * variable.
 * @format: a % delimited format string.
 * @ap: a varargs/stdargs va_list.
 *
 * Format the elements of @ap according to @format, and write
 * the results to an internally allocated buffer whose address is
 * stored in @result (and should be freed by the caller) unless
 * there is an error.
 *
 * Above moaning for asprintf applies here too.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_asprintf: printf.h
 * @result: the address of a char * variable.
 * @format: a % delimited format string.
 * @va_alist: a varargs/stdargs va_list.
 *
 * Format the elements of @va_alist according to @format, and write
 * the results to an internally allocated buffer whose address is
 * stored in @result (and should be freed by the caller) unless
 * there is an error.
 *
 * Yes, this interface is cumbersome and totally useless.  It would
 * have been better to simply return the allocated address, but
 * it turns out that somebody wasn't thinking much when adding
 * asprintf to libiberty a few years ago.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_filputc: printf.h
 * @ch: A single character to be added to @stream.
 * @stream: The stream in which to write @ch.
 *
 * A StreamPut function for use in putting characters
 * into STREAMs holding a Filament*.
 *
 * Return value:
 * The value of @ch that has been put in @stream.
 **//**
 * snv_snprintfv: printf.h
 * @buffer: a preallocated char* buffer.
 * @limit: the maximum number of characters to write into @buffer.
 * @format: a % delimited format string.
 * @args: a vector of argument addresses to match @format.
 *
 * Format the elements of @args according to @format, and write
 * the results to the string @buffer, truncating the formatted string
 * if it reaches @limit characters in length.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_vsnprintf: printf.h
 * @buffer: a preallocated char* buffer.
 * @limit: the maximum number of characters to write into @buffer.
 * @format: a % delimited format string.
 * @ap: a varargs/stdargs va_list.
 *
 * Format the elements of @ap according to @format, and write
 * the results to the string @buffer, truncating the formatted string
 * if it reaches @limit characters in length.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_snprintf: printf.h
 * @buffer: a preallocated char* buffer.
 * @limit: the maximum number of characters to write into @buffer.
 * @format: a % delimited format string.
 * @va_alist: a varargs/stdargs va_list.
 *
 * Format the elements of @va_alist according to @format, and write
 * the results to the string @buffer, truncating the formatted string
 * if it reaches @limit characters in length.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_sprintfv: printf.h
 * @buffer: a preallocated char* buffer.
 * @format: a % delimited format string.
 * @args: a vector of argument addresses to match @format.
 *
 * Format the elements of @args according to @format, and write
 * the results to the string @buffer.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_vsprintf: printf.h
 * @buffer: a preallocated char* buffer.
 * @format: a % delimited format string.
 * @ap: a varargs/stdargs va_list.
 *
 * Format the elements of @ap according to @format, and write
 * the results to the string @buffer.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_sprintf: printf.h
 * @buffer: a preallocated char* buffer.
 * @format: a % delimited format string.
 * @va_alist: a varargs/stdargs va_list.
 *
 * Format the elements of @va_alist according to @format, and write
 * the results to the string @buffer.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_bufputc: printf.h
 * @ch: A single character to be added to @stream.
 * @stream: The stream in which to write @ch.
 *
 * A StreamPut function for use in putting characters
 * into STREAMs holding a char buffer.
 *
 * Return value:
 * The value of @ch that has been put in @stream.
 **//**
 * snv_fprintfv: printf.h
 * @file: a stdio.h FILE* stream.
 * @format: a % delimited format string.
 * @args: a vector of argument addresses to match @format.
 *
 * Format the elements of @args according to @format, and write
 * the results to @file.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_vfprintf: printf.h
 * @file: a stdio.h FILE* stream.
 * @format: a % delimited format string.
 * @ap: a varargs/stdargs va_list.
 *
 * Format the elements of @ap according to @format, and write
 * the results to the @file stream.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_fprintf: printf.h
 * @file: a stdio.h FILE* stream.
 * @format: a % delimited format string.
 * @va_alist: a varargs/stdargs va_list.
 *
 * Format the elements of @va_alist according to @format, and write
 * the results to the @file stream.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_printfv: printf.h
 * @format: a % delimited format string.
 * @args: a vector of argument addresses to match @format.
 *
 * Format the elements of @args according to the string @format,
 * and write the result to the standard output stream.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_vprintf: printf.h
 * @format: a % delimited format string.
 * @ap: a varargs/stdargs va_list.
 *
 * Format the elements of @ap according to @format, and write
 * the results to the standard output stream.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_printf: printf.h
 * @format: a % delimited format string.
 * @va_alist: a varargs/stdargs va_list.
 *
 * Format the elements of @va_alist according to @format, and write
 * the results to the standard output stream.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_fileputc: printf.h
 * @ch: A single character to be added to @stream.
 * @stream: The stream in which to write @ch.
 *
 * A StreamPut function for use in putting characters
 * into STREAMs holding a FILE*.
 *
 * Return value:
 * The value of @ch that has been put in @stream.
 **//**
 * snv_dprintfv: printf.h
 * @fd: an open file descriptor.
 * @format: a % delimited format string.
 * @args: a vector of argument addresses to match @format.
 *
 * Format the elements of @args according to @format, and write
 * the results to file descriptor @fd.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_vdprintf: printf.h
 * @fd: an open file descriptor.
 * @format: a % delimited format string.
 * @ap: a varargs/stdargs va_list.
 *
 * Format the elements of @ap according to @format, and write
 * the results to the file descriptor @fd.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_dprintf: printf.h
 * @fd: an open file descriptor.
 * @format: a % delimited format string.
 * @va_alist: a varargs/stdargs va_list.
 *
 * Format the elements of @va_alist according to @format, and write
 * the results to the file descriptor @fd.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * snv_fdputc: printf.h
 * @ch: A single character to be added to @stream.
 * @stream: The stream in which to write @ch.
 *
 * A StreamPut function for use in putting characters
 * into STREAMs holding a file descriptor.
 *
 * Return value:
 * The value of @ch that has been put in @stream, or -1 in case of
 * an error (errno will be set to indicate the type of error).
 **//**
 * stream_printf: printf.h
 * @stream: an initialised stream structure.
 * @format: a % delimited format string.
 * @va_alist: a varargs/stdargs va_list.
 *
 * Format the elements of @va_alist according to @format, and write
 * the results to @stream.  If @stream is %NULL, only count the
 * number of characters needed to output the format.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * stream_vprintf: printf.h
 * @stream: an initialised stream structure.
 * @format: a % delimited format string.
 * @ap: a varargs/stdargs va_list.
 *
 * Format the elements of @ap according to @format, and write
 * the results to @stream.  If @stream is %NULL, only count the
 * number of characters needed to output the format.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * stream_printfv: printf.h
 * @stream: an initialised stream structure.
 * @format: a % delimited format string.
 * @args: a vector of argument addresses to match @format.
 *
 * Format the elements of @args according to @format, and write
 * the results to @stream.  If @stream is %NULL, only count the
 * number of characters needed to output the format.
 *
 * Return value:
 * The number of characters written is returned, unless there is
 * an error, when %SNV_ERROR is returned.
 **//**
 * parse_printf_format: printf.h
 * @format: a % delimited format string.
 * @n: the size of the @argtypes vector
 * @argtypes: a vector of ints, to be filled with the argument types from @format
 *
 * Returns information about the number and types of
 * arguments expected by the template string @format.
 * The argument @n specifies the number of elements in the array
 * @argtypes.  This is the maximum number of elements that
 * the function will try to write.
 *
 * Return value:
 * The total number of arguments required by @format.  If this
 * number is greater than @n, then the information returned
 * describes only the first @n arguments.  If you want information
 * about additional arguments, allocate a bigger array and call
 * this function again. If there is an error, then %SNV_ERROR
 * is returned instead.
 **//**
 * printf_error: printf.h
 * @pinfo: pointer to the current parser state.
 * @file: file where error was detected.
 * @line: line where error was detected.
 * @func1: " (" if function is supplied by compiler.
 * @func2: function where error was detected, if supplied by compiler.
 * @func3: ")" if function is supplied by compiler.
 * @error_message: new error message to append to @pinfo.
 *
 * The contents of @error_message are appended to the @pinfo internal
 * error string, so it is safe to pass static strings or recycle the
 * original when this function returns.
 *
 * Return value:
 * The address of the full accumulated error message in @pinfo is
 * returned.
 **//**
 * printf_strerror: printf.h
 *
 * Communicate information on the last error in a printf
 * format string.
 *
 * Return value:
 * A string describing the last error which occurred during the
 * parsing of a printf format string.  It is the responsibility
 * of the caller to free the string.
 *//**
 * register_printf_function: printf.h
 * @spec: the character which will trigger @func, cast to an unsigned int.
 * @fmt: the handler function to actually print the arguments to the specifier
 * @arg: the handler function to tell %printf about the types of the arguments
 *       to the specifier
 *
 * Register the pair made of @fmt and @arg, so that it is called
 * when @spec is encountered in a format string.
 *
 * Return value:
 * Returns %NULL if @func was not successfully registered, a
 * %spec_entry with the information on the function if it was.
 **//**
 * printf_generic:
 * @stream: the stream (possibly a struct printfv_stream appropriately
 * cast) on which to write output.
 * @pinfo: the current state information for the format string parser.
 * @args: the pointer to the first argument to be read by the handler
 *
 * An example implementation of a %printf_function, used to provide easy
 * access to justification, width and precision options.
 *
 * Return value:
 * The number of characters output.
 **//**
 * printf_generic_info:
 * @pinfo: the current state information for the format
 * string parser.
 * @n: the number of available slots in the @argtypes array
 * @argtypes: the pointer to the first slot to be filled by the
 * function
 *
 * An example implementation of a %printf_arginfo_function, which
 * takes the basic type from the type given in the %spec_entry
 * and adds flags depending on what was parsed (e.g. %PA_FLAG_SHORT
 * is %pparser->is_short and so on).
 *
 * Return value:
 * Always 1.
 *//**
 * SNV_EMIT:
 * @ch: the character to be printed
 * @stream: the stream on which to print
 * @count: a variable to be updated with the count of printed
 * characters
 *
 * Maintain the count while putting @ch in @stream, also be careful about
 * handling %NULL stream if the handler is being called purely to count
 * output size.
 **//* Flag bits that can be set in a type. *//* double *//* float *//* void * *//* const wchar_t *, wide character string *//* const char *, a '\0'-terminated string *//* wide char *//* int, cast to char *//* int *//* Codes to determine basic types.

   These values cover all the standard format specifications.
   Users can add new values after PA_LAST for their own types.  *//**
 * register_callback_function: printf.h
 * @spec: the character which will trigger the functions, cast to an unsigned int.
 * @fmt: the handler function to actually print the arguments to the specifier
 * @arg: the handler function to tell %printf about the types of the arguments to the specifier
 *
 * Register the pair made of @fmt and @arg, so that it is called
 * when @spec is encountered in a format string.  If you create
 * a shared library with an entry point named
 * %snv_register_printf_funcs, and put the library in the
 * search path given by the environment library %LTDL_LIBRARY_PATH,
 * that entry point will be called when %libsnprintfv is initialized,
 * passing a pointer to this kind of function (actually, a pointer
 * to %register_printf_function) to it.  This functionality is only
 * present when the library is installed, not when it is built as
 * a convenience library.
 *
 * Return value:
 * Returns %NULL if @func was not successfully registered, a
 * %spec_entry with the information on the function if it was.
 **//* for binary compatibility *//**
 * spec_entry:
 * @spec: the specifier character that was matched
 * @type: when @arg is NULL, the type of the only argument to the specifier
 * @fmt: the handler function to actually print the arguments to the specifier
 * @arg: the handler function to tell %printf about the types of the arguments to the specifier
 * @user: the user data for the specifier, accessible to the handler function
 *
 * This is returned by register_printf_function.
 *//**
 * PRINTF_ERROR:
 * @pi: A pointer to the current state for the parser
 * @str: The error message
 *
 * Append an error that will be returned by printf_strerror.
 *//**
 * printf_arg:
 * @pa_char: an unsigned %char
 * @pa_wchar: a %wchar_t
 * @pa_short_int: a %short integer
 * @pa_int: an %int
 * @pa_long_int: a %long integer
 * @pa_long_long_int: the widest signed integer type in use on the host
 * @pa_u_short_int: an unsigned %short integer
 * @pa_u_int: an unsigned %int
 * @pa_u_long_int: an unsigned %long integer
 * @pa_u_long_long_int: the widest unsigned integer type in use on the host
 * @pa_float: a %float
 * @pa_double: a %double
 * @pa_long_double: a long %double, or a simple %double if it is the widest floating-point type in use on the host
 * @pa_string: a %const pointer to %char
 * @pa_wstring: a %const pointer to %wchar_t
 * @pa_pointer: a generic pointer
 *
 * The various kinds of arguments that can be passed to printf.
 *//* from this field on, as in glibc *//* standard parser state, as in glibc *//* number of non-dollar arguments used so far *//* number of arguments used by format *//* pointer to format string *//* accumulated error details *//* one of the defines above *//* accumulated count, or SNV_ERROR *//* Mask for states available to the user *//* First state available to the user *//* States needed to support:
   %[<number>$]<flags>[<width>|\*][.<precision>|\*]<modifiers><specifier> *//* Basic states required by the parser.  On initialisation the parser
   will be in SNV_STATE_BEGIN, and tokens will be parsed by the registered
   functions until the parser reached SNV_STATE_END. *//* The type of each element in the table of printf specifiers. *//* printf.in --- printf clone for argv arrays
 * Copyright (C) 1998, 1999, 2000, 2002 Gary V. Vaughan
 * Originally by Gary V. Vaughan, 1998
 * This file is part of Snprintfv
 *
 * Snprintfv is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * Snprintfv program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses>.
 *
 * As a special exception to the GNU General Public License, if you
 * distribute this file as part of a program that also links with and
 * uses the libopts library from AutoGen, you may include it under
 * the same distribution terms used by the libopts library.
 */argtypespinfofunc1func2func3error_message/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/scribble.hSCRIBBLE_Hxscribble_getscribble_getscribble_freescribble_deinitscribble_init/* SCRIBBLE_H *//*  This file is part of AutoGen.
 *  Copyright (C) 1992-2015 Bruce Korb - all rights reserved
 *
 * AutoGen is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AutoGen is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/cgi-fsm.hte_cgi_eventCGI_EV_ALPHACGI_EV_NAME_CHARCGI_EV_EQUALCGI_EV_SPACECGI_EV_ESCAPECGI_EV_OTHERCGI_EV_SEPARATORCGI_EV_ENDCGI_EV_INVALIDte_cgi_stateCGI_ST_INITCGI_ST_NAMECGI_ST_VALUECGI_ST_INVALIDCGI_ST_DONECGI_EVENT_CTCGI_STATE_CTAUTOFSM_CGI_FSM_H_GUARDcgi_run_fsm/*
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of cgi-fsm.h *//* AUTOFSM_CGI_FSM_H_GUARD *//**
 *  Run the FSM.  Will return CGI_ST_DONE or CGI_ST_INVALID
 *//**
 *  Finite State machine transition Events.
 *
 *  Count of the valid transition events
 *//**
 *  Finite State machine States
 *
 *  Count of non-terminal states.  The generated states INVALID and DONE
 *  are terminal, but INIT is not  :-).
 *//*
 *  This file enumerates the states and transition events for a FSM.
 *
 *  te_cgi_state
 *      The available states.  FSS_INIT is always defined to be zero
 *      and FSS_INVALID and FSS_DONE are always made the last entries.
 *
 *  te_cgi_event
 *      The transition events.  These enumerate the event values used
 *      to select the next state from the current state.
 *      CGI_EV_INVALID is always defined at the end.
 *//*   -*- buffer-read-only: t -*- vi: set ro:
 *
 *  DO NOT EDIT THIS FILE   (cgi-fsm.h)
 *
 *  It has been AutoGen-ed
 *  From the definitions    cgi.def
 *  and the template file   fsm
 *
 *  Automated Finite State Machine
 *
 *  Copyright (C) 1992-2015 Bruce Korb - all rights reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name ``Bruce Korb'' nor the name of any other
 *    contributor may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * AutoFSM IS PROVIDED BY Bruce Korb ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bruce Korb OR ANY OTHER CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */pzSrcinlenpzOutoutlen/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/defParse-fsm.hte_dp_eventDP_EV_AUTOGENDP_EV_DEFINITIONSDP_EV_ENDDP_EV_VAR_NAMEDP_EV_OTHER_NAMEDP_EV_STRINGDP_EV_HERE_STRINGDP_EV_DELETE_ENTDP_EV_NUMBERDP_EV_LIT_SEMIDP_EV_LIT_EQDP_EV_LIT_COMMADP_EV_LIT_O_BRACEDP_EV_LIT_C_BRACEDP_EV_LIT_OPEN_BKTDP_EV_LIT_CLOSE_BKTDP_EV_INVALIDte_dp_stateDP_ST_INITDP_ST_NEED_DEFDP_ST_NEED_TPLDP_ST_NEED_SEMIDP_ST_NEED_NAMEDP_ST_HAVE_NAMEDP_ST_NEED_VALUEDP_ST_NEED_IDXDP_ST_NEED_CBKTDP_ST_INDX_NAMEDP_ST_HAVE_VALUEDP_ST_INVALIDDP_ST_DONEDP_EVENT_CTDP_STATE_CTAUTOFSM_DEFPARSE_FSM_H_GUARDdp_run_fsm/*
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of defParse-fsm.h *//* AUTOFSM_DEFPARSE_FSM_H_GUARD *//**
 *  Run the FSM.  Will return DP_ST_DONE or DP_ST_INVALID
 *//*
 *  This file enumerates the states and transition events for a FSM.
 *
 *  te_dp_state
 *      The available states.  FSS_INIT is always defined to be zero
 *      and FSS_INVALID and FSS_DONE are always made the last entries.
 *
 *  te_dp_event
 *      The transition events.  These enumerate the event values used
 *      to select the next state from the current state.
 *      DP_EV_INVALID is always defined at the end.
 *//*   -*- buffer-read-only: t -*- vi: set ro:
 *
 *  DO NOT EDIT THIS FILE   (defParse-fsm.h)
 *
 *  It has been AutoGen-ed
 *  From the definitions    defParse.def
 *  and the template file   fsm
 *
 *  Automated Finite State Machine
 *
 *  Copyright (C) 1992-2015 Bruce Korb - all rights reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name ``Bruce Korb'' nor the name of any other
 *    contributor may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * AutoFSM IS PROVIDED BY Bruce Korb ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bruce Korb OR ANY OTHER CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/functions.hfn_name_type_tfn_name_typemac_func_tFTYP_BOGUSFTYP_BREAKFTYP_CASEFTYP_COMMENTFTYP_CONTINUEFTYP_DEBUGFTYP_DEFINEFTYP_ELIFFTYP_ELSEFTYP_ENDDEFFTYP_ENDFORFTYP_ENDIFFTYP_ENDWHILEFTYP_ESACFTYP_EXPRFTYP_FORFTYP_IFFTYP_INCLUDEFTYP_INVOKEFTYP_RETURNFTYP_SELECTFTYP_TEXTFTYP_UNKNOWNFTYP_WHILEFTYP_SELECT_COMPARE_FULL327680x8000FTYP_SELECT_COMPARE_SKP_START327690x8001FTYP_SELECT_COMPARE_SKP_END327700x8002FTYP_SELECT_COMPARE327710x8003FTYP_SELECT_EQUIVALENT_FULL327720x8004FTYP_SELECT_EQUIVALENT_SKP_START327730x8005FTYP_SELECT_EQUIVALENT_SKP_END327740x8006FTYP_SELECT_EQUIVALENT327750x8007FTYP_SELECT_MATCH_FULL327760x8008FTYP_SELECT_MATCH_SKP_START327770x8009FTYP_SELECT_MATCH_SKP_END327780x800AFTYP_SELECT_MATCH327790x800BFTYP_SELECT_EQV_MATCH_FULL327800x800CFTYP_SELECT_EQV_MATCH_SKP_START327810x800DFTYP_SELECT_EQV_MATCH_SKP_END327820x800EFTYP_SELECT_EQV_MATCH327830x800FFTYP_SELECT_MATCH_ANYTHING327960x801CFTYP_SELECT_MATCH_EXISTENCE327970x801DFTYP_SELECT_MATCH_NONEXISTENCE327980x801EfTypepNamecmpLenconst unload_proc_p_tmacro_t *macro_desc *const unload_proc_p_t[24]..(*[24])(..)FUNC_CTunload_procsunload_proc_t *const hdlr_proc_p_ttempl_t *template_desc *const hdlr_proc_p_t[24]load_procshdlr_proc_t *const char *const[24]char *[24]ag_fun_namesBogus"Bogus"char[6]const char[144]char[144]144COMMENT"COMMENT"char[8]65EXPR"EXPR"char[5]99106114121SELECT"SELECT"char[7]Text"Text"Unknown"Unknown"138const fn_name_type_tconst fn_name_type_t[34]fn_name_type[34]FUNCTION_NAME_CTfn_name_types134831321361308189zFnStrgBREAK CASE # CONTINUE DEBUG DEFINE ELIF ELSE ENDDEF ENDFOR ENDIF ENDWHILE ESAC - ? % ; ( ` " ' . { FOR IF INCLUDE INVOKE RETURN ~ = * ! + WHILE"BREAK\0"    "CASE\0"     "#\0"        "CONTINUE\0" "DEBUG\0"
    "DEFINE\0"   "ELIF\0"     "ELSE\0"     "ENDDEF\0"   "ENDFOR\0"
    "ENDIF\0"    "ENDWHILE\0" "ESAC\0"     "-\0"        "?\0"
    "%\0"        ";\0"        "(\0"        "`\0"        "\"\0"
    "'\0"        ".\0"        "{\0"        "FOR\0"      "IF\0"
    "INCLUDE\0"  "INVOKE\0"   "RETURN\0"   "~\0"        "=\0"
    "*\0"        "!\0"        "+\0"        "WHILE\0"const load_proc_p_tconst load_proc_p_t *load_proc_tableconst load_proc_p_t[24]base_load_tableload_proc_t *FUNCTION_CKSUM0x9B56FUNC_NAMES_HIGH_INDEXFUNC_NAMES_LOW_INDEXFUNC_ALIAS_HIGH_INDEXFUNC_ALIAS_LOW_INDEXAUTOGEN_FUNCTIONS_H_GUARDmUnload_SelectmUnload_DefinemLoad_WhilemLoad_UnknownmLoad_LeavemLoad_IfmLoad_FormLoad_ExprmLoad_EndingmLoad_DefinemLoad_DebugmLoad_CommentmLoad_CasemLoad_BogusmFunc_WhilemFunc_UnknownmFunc_TextmFunc_ReturnmFunc_InvokemFunc_IncludemFunc_IfmFunc_FormFunc_ExprmFunc_DefinemFunc_DebugmFunc_CasemFunc_BreakmFunc_Bogus/* end of functions.h *//* AUTOGEN_FUNCTIONS_H_GUARD *//**
 *  Template Unloading Function Table
 *
 *  Pointers to the procedure to call when the function code
 *  is encountered in a template being unloaded.
 *//* * * * * * * * * * tpLoad.c use only * * * * * * * * * * * * * *//* WHILE    *//* UNKNOWN  *//* TEXT     *//* SELECT   *//* RETURN   *//* INVOKE   *//* INCLUDE  *//* IF       *//* FOR      *//* EXPR     *//* ESAC     *//* ENDWHILE *//* ENDIF    *//* ENDFOR   *//* ENDDEF   *//* ELSE     *//* ELIF     *//* DEFINE   *//* DEBUG    *//* CONTINUE *//* COMMENT  *//* CASE     *//* BREAK    *//* BOGUS    *//**
 *  Template Processing Function Table
 *
 *  Pointers to the procedure to call when the function code
 *  is encountered.
 *//* * * * * * * * tpProcess.c use only * * * * * * * * * * * * * *//**
 *  The table separated by aliasing and then sorted by string content
 *//* * * * * * * * tpParse.c use only * * * * * * * * * * * * * * *//**
 *  The number of names by which the macros go.
 *  Some have multiple names (aliases, e.g. selection clauses).
 *//**
 *  Define all the strings that are used to determine the function enumeration
 *  number.  These are used in a table separated by aliases and sorted by these
 *  ASCII values.
 *///!< function type enum//!< ptr to name//!< compare length (sans NUL)/**
 *  name-to-function type mapping table.
 *  This table must be sorted alphabetically by the content
 *  of the naming string.
 *//**
 *  This global pointer is used to switch parsing tables.  The block
 *  functions (CASE, DEFINE, FOR, and IF) change this to point
 *  to their tables that include relevant additional functions.
 *//*default*//*dynamic*//**
 *  Parsing function tables for load processing (template scanning phase).
 *//* tpParse.c use only * * * * * * * * * * * * * * * *//**
 *  Template Loading Functions.
 *//**
 *  The function processing procedures.
 *//* !E   *//* +E   *//*  *   *//*  ~   *//*  ~*  *//* *~   *//* *~*  *//*  ~~  *//*  ~~* *//* *~~  *//* *~~* *//*  =   *//*  =*  *//* *=   *//* *=*  *//*  ==  *//*  ==* *//* *==  *//* *==* *//**
 *  Enumerate all the AutoGen macro types.
 *//**
 * The number of native AutoGen functions, omitting the
 * comparison type / selection functions.
 *//** \file functions.h
 *
 *  Tables of Text Functions for AutoGen
 *
 *  Copyright (C) 1992-2014 by Bruce Korb - all rights reserved
 *
 *  AutoGen is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AutoGen is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  The 24 AutoGen macros are tagged with special attributes:
 *
 *  A - is invoked via an alias
 *
 *  U - is unnamed.  May *not* be explicitly invoked.  May not have
 *      have an alias.  These three are used by AutoGen for its purposes.
 *
 *  L - has a special load procedure defined
 *
 *  C - in context.  May be explicitly invoked in certain situations.
 *      For example, "ELSE" may only be specified within an "IF" block.
 *      Their load procedures are enabled by the block macro (e.g. IF),
 *      and disabled by the block ending macro (e.g. ENDIF).
 *      While disabled, the load procedure is the "Bogus" method.
 *
 *      If a function is neither has a special load procedure nor is
 *      situational, then the "Unknown" load method is applied.
 *
 *  R - has a special remove (unload) procedure
 *
 *  H - has a handler procedure defined.  Only these procedures should
 *      be encountered by the dispatcher during processing.
 *
 *  U L   H - BOGUS     Out-of-context or unknown functions are bogus.
 *    L   H - BREAK     Leave a FOR or WHILE macro
 *    L   H - CASE      Select one of several template blocks
 *  A L     - COMMENT   A block of comment to be ignored
 *    L   H - CONTINUE  Skip to end of a FOR or WHILE macro.
 *    L   H - DEBUG     Print debug message to trace output
 *    L R H - DEFINE    Define a user AutoGen macro
 *    C     - ELIF      Alternate Conditional Template Block
 *    C     - ELSE      Alternate Template Block
 *    C     - ENDDEF    Ends a macro definition.
 *    C     - ENDFOR    Terminates the @code{FOR} function template block
 *    C     - ENDIF     Terminate the @code{IF} Template Block
 *    C     - ENDWHILE  Terminate the @code{WHILE} Template Block
 *    C     - ESAC      Terminate the @code{CASE} Template Block
 *  A L   H - EXPR      Evaluate and emit an Expression
 *    L   H - FOR       Emit a template block multiple times
 *    L   H - IF        Conditionally Emit a Template Block
 *    L   H - INCLUDE   Read in and emit a template block
 *        H - INVOKE    Invoke a User Defined Macro
 *    L   H - RETURN    Leave an INVOKE-d (DEFINE) macro
 *  A C R   - SELECT    Selection block for CASE function
 *  U     H - TEXT      A block of text to be emitted.
 *  U L   H - UNKNOWN   Either a user macro or a value name.
 *    L   H - WHILE     Conditionally loop over a Template Block
 *
 * @addtogroup autogen
 * @{
 *//*   -*- buffer-read-only: t -*- vi: set ro:
 *
 *  DO NOT EDIT THIS FILE   (functions.h)
 *
 *  It has been AutoGen-ed
 *  From the definitions    functions.def
 *  and the template file   functions.tpl
 */ppzScan/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/guile-iface.hAG_SCM_VEC_P(_v)scm_is_vector(_v)AG_SCM_TO_ULONG(_v)((unsigned long)scm_to_ulong(_v))AG_SCM_TO_LONG(_v)scm_to_long(_v)AG_SCM_TO_INT(_i)scm_to_int(_i)AG_SCM_SYM_P(_s)scm_is_symbol(_s)AG_SCM_STRLEN(_s)scm_c_string_length(_s)AG_SCM_STRING_P(_s)scm_is_string(_s)AG_SCM_TO_NEWSTR(_s)scm_to_latin1_string(_s)AG_SCM_STR2SCM(_st,_sz)scm_from_latin1_stringn(_st,_sz)AG_SCM_STR02SCM(_s)scm_from_latin1_string(_s)AG_SCM_PAIR_P(_p)scm_is_true( scm_pair_p(_p))AG_SCM_LIST_P(_l)scm_is_true( scm_list_p(_l))AG_SCM_IS_PROC(_p)scm_is_true( scm_procedure_p(_p))MUTATING_GUILE_IFACE_H_GUARD(GUILE_VERSION >= 200000) && (GUILE_VERSION <= 200003)(GUILE_VERSION <= 106999)GUILE_VERSION < 201000/* MUTATING_GUILE_IFACE_H_GUARD *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/proto.hAGEN5_PROTO_H_GUARDDEBUG_ENABLEDout_closeprocess_tplout_spec_t *out_spec *next_out_specgen_blockparse_tplcleanuptpl_unloadtpl_loadfind_fileconst char *const *find_tplload_pseudo_macdo_suffixgen_new_blockcall_gen_blockfree_for_contextevaleval_mac_exprbool *scm2displayparse_mac_argsdo_multi_subsrun_printfopen_output_filemake_readonlyag_scm_c_eval_string_from_file_lineag_scm_type_eag_scm2zcharsload_fileunload_defsread_defsdef_ent_t *def_entry *number_and_insert_entdelete_entprint_entnew_def_entyyerroryylexdef_ent_t **def_entry **find_def_ent_listprint_used_definesfind_def_entcanonical_nameprocessDirectiveag_abend_atskip_exprskip_schemespan_quoteget_define_strprocess_ag_optsaprffswarnshell_cmdclose_server_shellprep_envconfig_depinitializewrap_up_dependsstart_dep_filerm_target_fileadd_target_filerm_source_fileadd_source_fileloadCgi/* AGEN5_PROTO_H_GUARD *//*
 *  Extracted from tpProcess.c
 *//*
 *  Extracted from tpParse.c
 *//*
 *  Extracted from tpLoad.c
 *//*
 *  Extracted from loadPseudo.c
 *//*
 *  Extracted from functions.c
 *//*
 *  Extracted from funcFor.c
 *//*
 *  Extracted from funcEval.c
 *//*
 *  Extracted from funcDef.c
 *//*
 *  Extracted from expString.c
 *//*
 *  Extracted from expPrint.c
 *//*
 *  Extracted from expOutput.c
 *//*
 *  Extracted from expGuile.c
 *//*
 *  Extracted from expExtract.c
 *//*
 *  Extracted from defLoad.c
 *//*
 *  Extracted from defLex.c
 *//*
 *  Extracted from defFind.c
 *//*
 *  Extracted from defDirect.c
 *//*
 *  Extracted from autogen.c
 *//*
 *  Extracted from agUtils.c
 *//*
 *  Extracted from agShell.c
 *//*
 *  Extracted from agInit.c
 *//*
 *  Extracted from agDep.c
 *//*
 *  Extracted from agCgi.c
 *//* -*- buffer-read-only: t -*- vi: set ro:
 *
 * Prototypes for agen5
 * Generated Sun Dec  6 16:04:14 PST 2015
 */purgetplosmacemacp_scanreferrerin_nameres_namesfx_listreferring_tpltpl_nametextlineNojbufend_macpop_ctallocatedpTppzStrpStrLenmatchreplpzFmtnmszpzExprtypidx_strdeindexedpzDpzSsrcLenscanmsgin_qde_namecheck_envarg_ctarg_vecoptsodpz/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/autogen.h"proto.h""guile-iface.h""functions.h""defParse-fsm.h""cgi-fsm.h""scribble.h""snprintfv/printf.h""directive.h""autoopts/autoopts.h""expr.h""opts.h""ag-text.h"<libguile/scmconfig.h>REGEX_HEADER"compat/unlocked-io.h"ag_evalressvv2c_tivk_info_tivk_infoloop_jmp_type_tLOOP_JMP_OKAYLOOP_JMP_NEXTLOOP_JMP_BREAKhdlr_proc_p_thdlr_proc_tunload_proc_p_tunload_proc_tload_proc_p_tload_proc_tfor_state_tfor_statedef_ctx_tdef_ctxtempl_ttemplate_desctlib_mark_ttlib_markmacro_tmacro_descdef_ent_tdef_entryval_typ_tVALTYP_UNKNOWNVALTYP_TEXTVALTYP_BLOCKdef_val_uscan_ctx_tscan_contextout_spec_tout_specout_stack_tout_stackproc_state_tPROC_STATE_INITPROC_STATE_OPTIONSPROC_STATE_GUILE_PRELOADPROC_STATE_LOAD_DEFSPROC_STATE_LIB_LOADPROC_STATE_LOAD_TPLPROC_STATE_EMITTINGPROC_STATE_INCLUDINGPROC_STATE_CLEANUPPROC_STATE_ABORTINGPROC_STATE_DONECOUNT_PROC_STATEdef_token_u_tfp_pair_tfd_pair_tcpfor_state_t *for_state *ii_for_dataii_for_allocii_for_depthii_envii_depthivk_info_t *ivk_info *ii_prevfor_envfor_not_foundfor_isfirstfor_islastfor_loadingfor_indexfor_byfor_tofor_fromfor_namefor_sep_strfor_ctxdef_ctx_t *def_ctx *dcx_prevdcx_defentmacro_t[1]macro_desc[1]td_macrosMAX_SUFFIX_LENtd_end_mactd_start_mactd_texttd_nametd_filetd_mac_cttd_scantd_sizetd_magictlm_cksumtlm_revisiontlm_magicunsigned int[1]unsigned char[4]md_pvtmd_resmd_txt_offmd_name_offmd_sib_idxmd_end_idxmd_linemd_codede_typede_linede_filede_valdvu_textdvu_entryde_indexde_etwinde_ptwinde_twinde_nextscx_linescx_datascx_fnamescx_scanscan_ctx_t *scan_context *scx_nextchar[1]os_sfxos_dealloc_fmtos_file_fmtos_nextstk_fnamestk_fpout_stack_t *out_stack *stk_prevstk_flagsfp_writefp_readfd_writefd_readp2p{ NULL }{ ((void *)0) }ag_exit_codecurr_entent_stackdef_ent_t *[16]def_entry *[16]dft_ent_stack{ 0 }ent_stack_szent_stack_depthtoken_codetoken_strout_rootst_mac_mark""st_mac_lenend_mac_markend_mac_lenend_ctxcctxbase_ctxtpl_lineconst tlib_mark_tmagic_markerTEMPLATE_MAGIC_MARKER{{{'A', 'G', 'L', 'B'}}, 1, 0x9B56 }7639766cur_macrolast_scm_cmdcurrent_tplroot_def_ctxcurr_def_ctxlibguile_vershell_programMK_STR(CONFIG_SHELL)"/bin/bash"CONFIG_SHELL/bin/bashchar[10]const char *[2]char *[2]server_argscgi_stderrdep_phoniesfalsesource_usedsource_sizesource_listpz_targ_basedep_filedep_targetdep_fptemp_tpl_dir_lenpz_temp_tpltrace_fpcurr_ivk_info&root_ivk_inforoot_ivk_infoabort_jmp_bufoutput_specscur_fpstackstart_timemaxfile_timeoutfile_timecurr_sfxconst char[1]no_def_stroops_pfxnamed_tplsdefining_macroinclude_depthprocessing_stateLOCALHIDE_FN(_t)_tAG_SCM_CHAR_P(_c)SCM_CHARP(_c)AG_SCM_APPLY2(_op,_f,_tst)scm_apply(_op, _f, scm_cons(_tst, scm_list_1(SCM_EOL)))AG_SCM_BOOT_GUILE(_ac,_av,_im)scm_boot_guile((_ac), (_av), (_im), NULL)AG_SCM_DISPLAY(_s)scm_display(_s, scm_current_output_port())AG_ABEND_IN(t,m,s)STMTS( current_tpl=(t); cur_macro=(m); AG_ABEND(s);)DEBUGAG_CANT(_op,_wh)AG_ABEND(aprf(CANNOT_FMT, errno, _op, _wh, strerror(errno)))AG_ABEND(s)ag_abend_at(s)name_sep_ch'.'ag_pnameautogenOptions.pzProgNameSCM_EVAL_CONST(_s)do { static int const line = __LINE__ - 1; static char const file[] = __FILE__; static char const * text = _s; last_scm_cmd = text; ag_scm_c_eval_string_from_file_line(text, file, line); } while (false)MK_STR(_s)_MkStr(_s)#_sIVK_INFO_INITIALIZER(_p){ .ii_prev = (_p), .ii_depth = curr_ivk_info->ii_depth + 1, .ii_for_depth = 0, .ii_for_alloc = 0, .ii_for_data = NULL }FPF_TEMPFILE0x0020FPF_NOCHMOD0x0010FPF_STATIC_NM0x0008FPF_NOUNLINK0x0004FPF_UNLINK0x0002FPF_FREE0x0001NO_INDEX((short)0x80DEAD)EMIT_NO_DEFINE0x0800EMIT_FORMATTED0x0400EMIT_ALWAYS0x0200EMIT_IF_ABSENT0x0100EMIT_SECONDARY_SHIFTEMIT_SECONDARY_TYPE0x0070EMIT_PRIMARY_TYPE0x0007EMIT_STRING0x0003EMIT_SHELLEMIT_EXPRESSIONEMIT_VALUE0x0000{{{'A', 'G', 'L', 'B'}}, TEMPLATE_REVISION, FUNCTION_CKSUM }TEMPLATE_REVISIONSCRIBBLE_SIZEMAX_HEREMARK_LEN_State__State_(n)PROC_STATE_ ## n,STATE_TABLE_State_( INIT ) _State_( OPTIONS ) _State_( GUILE_PRELOAD ) _State_( LOAD_DEFS ) _State_( LIB_LOAD ) _State_( LOAD_TPL ) _State_( EMITTING ) _State_( INCLUDING ) _State_( CLEANUP ) _State_( ABORTING ) _State_( DONE )TABNULLPROCESS((pid_t)0)NOPROCESS((pid_t)-1)ag_offsetof(TYPE,MEMBER)((unsigned long) &((TYPE *)0)->MEMBER)YYSTYPEt_wordLOG10_2to32AUTOGEN_BUILD!defined(__GNUC__)! defined(GCC_VERSION)GCC diagnostic pushGCC diagnostic popdefined(SHELL_ENABLED)HAVE_WORKING_FORKENABLE_FMEMOPENDEBUG_FSM__STDC_VERSION__ < 199901L__GNUC__ >= 2ag_fmemioctlag_fmemopenDONEABORTINGCLEANUPINCLUDINGEMITTINGLOAD_TPLLIB_LOADLOAD_DEFSGUILE_PRELOADOPTIONSINIT/** @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/autogen.h *//* AUTOGEN_BUILD *//**
 * Hide dummy functions from complexity measurement tools
 *//**
 *  Extracted from guile-iface stuff.  Seems to be stable since for at least
 *  1.6.0 through 2.0.0.  1.4.x is thoroughly dead now (May, 2011).
 *//* Watch for nested calls *//**
 * Evaluate a scheme expression, setting the file and line number from
 * the file and line of the currently active macro.
 *
 * @param[in] str  the scheme expression
 * @returns the SCM result.  That may be SCM_UNDEFINED.
 *//*
 *  Code variations based on the version of Guile:
 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  IF we have fopencookie or funopen, then we also have our own fmemopen
 *//*
 *  Definition Parsing Globals
 *//*
 *  Template Parsing Globals
 *//*
 *  Current Macro
 *
 *  This may be set in exactly three places:
 *  1.  The dispatch routine (gen_block) that steps through
 *      a list of macros
 *  2.  mFunc_If may transfer to one of its 'ELIF' or 'ELSE'
 *      alternation macros
 *  3.  mFunc_Case may transfer to one of its selection clauses.
 *//*
 *  AutoGen definiton and template context
 *
 *  curr_def_ctx is the current, active list of name/value pairs.
 *  Points to its parent list for full search resolution.
 *
 *  current_tpl the template (and DEFINE macro) from which
 *  the current set of macros is being extracted.
 *
 *  These are set in exactly ONE place:
 *  On entry to the dispatch routine (gen_block).  Two routines, however,
 *  must restore the values: mFunc_Define and mFunc_For.  They are the only
 *  routines that dynamically push name/value pairs on the definition stack.
 *//**
 * The actual list of input (source) files.
 *//**
 * base name of both source and derived files.
 * Either "_TList" or "_SList" gets put on the end.
 *//**
 * name of dependency file
 *//**
 * name of target of rule
 *//**
 * dependency file file pointer.
 *//**
 * Length of the template that is the temp directory
 *//**
 * temporary file name template
 *//**
 * The original time autogen started
 *//**
 * The time to set for the modification times of the output files.
 *//*
 *  Template Processing Globals
 *//*
 *  "eval_mac_expr" must be able to return a distinct empty string so that
 *  the "CASE" function can distinguish an empty string due to it being a
 *  value from an empty string due to an absent definition.
 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  GLOBAL VARIABLES
 *
 *  General Processing Globals
 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Parsing stuff
 *///!< array of "for" macro states//!< for state buffer allocation count//!< for depth for this invocation//!< long jump buffer (RETURN)//!< Invocation nesting depth//!< previous layer/**
 *  Invocation of a defined macro processing state
 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *///!< long jump buffer (BREAK, CONTINUE)//!< usually false, true with sparse arrays//!< true for first iteration//!< true for last iteration//!< the FOR macro is getting ready//!< the current index//!< the loop increment (usually 1)//!< the last index of loop//!< the first index of loop//!< name of iterator (not allocated)//!< inter-iteration string (allocated)//!< saved def context for for loop/**
 * The current state of each active FOR loop.
 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  FOR loop processing state
 *//*!< the file is a temp      *//*!< do not chmod(2) file    *//*!< name statically alloced *//*!< do not unlink file      *//*!< unlink file (temp file) *//*!< free the fp structure   *//**
 * Output stack handling flags.
 *///!< text/block/not defined yet//!< def file source line//!< definition file name//!< string or list of children//!< index among twins//!< name of this member//!< head of chain to end ptr//!< previous memb. of level//!< next member with same name//!< next member of same level//!< ptr to previous def set//!< ptr to current def set/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Name/Value Definitions Layout
 *///  char          td_text[...];  * strings are at end of macros//!< Array of Macros//!< base address of the text//!< Defined Macro Name//!< Name of template file//!< Count of Macros//!< Next Pointer//!< Structure Size//!< TEMPLATE_MAGIC_MARKER/**
 * AutoGen template descriptor.
 * A full template or a defined macro is managed with this structure.
 *///!< private data for particular macro//!< some sort of result//!< associated text//!< macro name (sometimes)//!< Sibling macro (ELIF or SELECT)//!< End of block macro//!< of macro def//!< Macro function/**
 * template macro descriptor.
 *///!< don't get defined value//!< format, if val present//!< emit one of two exprs//!< emit text when value non-existant//!< bit offset for secondary type//!< mask for secondary emission type//!< mask for primary emission type//!< emit content of expr//!< emit shell output//!< Emit Scheme result//!< emit value of variable/**
 *  Defines for conditional expressions.  The first four are an enumeration
 *  that appear in the low four bits and the next-to-lowest four bits.
 *  "PRIMARY_TYPE" and "SECONDARY_TYPE" are masks for extracting this
 *  enumeration.  The rest are flags.
 *//* FUNCTION_CKSUM       *//* TEMPLATE_REVISION    *//* {'A', 'G', 'L', 'B'} *//*
 *  This must be included after the function prototypes
 *  (the prototypes are used in the generated tables),
 *  but before the macro descriptor structure (the function
 *  enumeration is generated here).
 *//*
 *  Procedure for handling a template function
 *  during the text emission phase.
 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Template Library Layout
 *
 *  Procedure for loading a template function
 *//* much larger than any short name *//* max length of a here mark *//* maximum length of a file name suffix *//* `exit' has been called           *//* Clean up code in error response  *//* end of processing before exit()  *//* loading an included template     *//* processing templates             *//* Loading primary template         *//* Loading library template         *//* Loading value definitions        *//* Loading guile at option time     *//* processing command line options  *//* set up `atexit' and load Guile   *//* parent write fp *//* parent read fp  *//*
 *  Dual pipe opening of a child process
 *//* rounded up *//*  This file is part of AutoGen.
 *  AutoGen Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
 *
 * AutoGen is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AutoGen is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *//**
 * @mainpage
 * @section Introduction
 * Autogen is a multi-component project.  There is the basic engine itself
 * ("autogen"), a library ("libopts") and its support templates (collectively,
 * "AutoOpts"), several support and utility programs ("columns", "getdefs" and
 * "xml2ag"), *plus* several handy embedded utility templates.  They are all
 * bundled together because they all require each other.  They each do completely
 * separate things, but they each are not useful without the other.  Thus,
 * they are bundled together.
 *
 * @group autogen
 * @{
 *//**
 * @file autogen.h
 *
 *  Global header file for AutoGen
 *//usr/include/x86_64-linux-gnu/bits/types/struct_rusage.hru_stimeru_utime__ru_nivcsw_wordru_nivcsw__ru_nvcsw_wordru_nvcsw__ru_nsignals_wordru_nsignals__ru_msgrcv_wordru_msgrcv__ru_msgsnd_wordru_msgsnd__ru_oublock_wordru_oublock__ru_inblock_wordru_inblock__ru_nswap_wordru_nswap__ru_majflt_wordru_majflt__ru_minflt_wordru_minflt__ru_isrss_wordru_isrss__ru_idrss_wordru_idrss__ru_ixrss_wordru_ixrss__ru_maxrss_wordru_maxrss__rusage_defined/* Number of involuntary context switches, i.e. a higher priority process
       became runnable or the current process used up its time slice.  *//* Number of voluntary context switches, i.e. because the process
       gave up the process before it had to (usually to wait for some
       resource to be available).  *//* Number of signals delivered.  *//* Number of IPC messages received.  *//* Number of IPC messages sent.  *//* Number of output operations via the file system.  *//* Number of input operations via the file system.  Note: This
       and `ru_oublock' do not include operations with the cache.  *//* Number of times a process was swapped out of physical memory.  *//* Number of hard page faults (i.e. those that required I/O).  *//* Number of soft page faults (i.e. those serviced by reclaiming
       a page from the list of pages awaiting reallocation.  *//* Amount of stack memory used (kilobyte-seconds).  *//* Amount of data segment memory used (kilobyte-seconds).  *//* Amount of sharing of text segment memory
       with other processes (kilobyte-seconds).  *//* Maximum resident set size (in kilobytes).  *//* Total amount of system time used.  *//* Total amount of user time used.  *//* The purpose of all the unions is to have the kernel-compatible layout
   while keeping the API type as 'long int', and among machines where
   __syscall_slong_t is not 'long int', this only does the right thing
   for little-endian ones, like x32.  *//* Structure which says how much of each resource has been used.  If
   the system does not keep track of a particular value, the struct
   field is always zero.  *//* Define struct rusage.
   Copyright (C) 1994-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/resource.h<bits/types/struct_rusage.h>prlimit64const rlimit64const rlimit64 *rlimit64 *prlimitconst rlimitconst rlimit *rlimit *__priority_whichPRIO_PROCESSPRIO_PGRPPRIO_USER__rusage_whoRUSAGE_SELFRUSAGE_CHILDRENRUSAGE_THREADrlimit64rlimitrlim64_trlim_t__rlimit_resourceRLIMIT_CPURLIMIT_FSIZERLIMIT_DATARLIMIT_STACKRLIMIT_CORE__RLIMIT_RSSRLIMIT_NOFILE__RLIMIT_OFILERLIMIT_AS__RLIMIT_NPROC__RLIMIT_MEMLOCK__RLIMIT_LOCKS__RLIMIT_SIGPENDING__RLIMIT_MSGQUEUE__RLIMIT_NICE__RLIMIT_RTPRIO__RLIMIT_RTTIME__RLIMIT_NLIMITS__RLIM_NLIMITSrlim_maxrlim_curPRIO_MAXPRIO_MIN-20RUSAGE_LWPRLIM_SAVED_CURRLIM_INFINITYRLIM_SAVED_MAXRLIM64_INFINITY0xffffffffffffffffuLL((__rlim_t) -1)RLIM_NLIMITSRLIMIT_NLIMITSRLIMIT_RTTIMERLIMIT_RTPRIORLIMIT_NICERLIMIT_MSGQUEUERLIMIT_SIGPENDINGRLIMIT_LOCKSRLIMIT_MEMLOCKRLIMIT_NPROCRLIMIT_OFILERLIMIT_RSS_SYS_RESOURCE_H/* Modify and return resource limits of a process atomically.  *//* WHO is a user ID.  *//* WHO is a process group ID.  *//* WHO is a process ID.  *//* The type of the WHICH argument to `getpriority' and `setpriority',
   indicating what flavor of entity the WHO argument specifies.  *//* Maximum priority a process can have.  *//* Minimum priority a process can have.  *//* Priority limits.  *//* Name for the same functionality on Solaris.  *//* The calling thread.  *//* All of its terminated child processes.  *//* The calling process.  *//* Whose usage statistics do you want?  *//* The hard limit.  *//* The current (soft) limit.  *//* Type for resource quantity measurement.  *//* We can represent all limits.  *//* Value to indicate that there is no limit.  *//* Maximum CPU time in microseconds that a process scheduled under a real-time
     scheduling policy may consume without making a blocking system
     call before being forcibly descheduled.  *//* Maximum realtime priority allowed for non-priviledged
     processes.  *//* Maximum nice priority allowed to raise to.
     Nice levels 19 .. -20 correspond to 0 .. 39
     values of this resource limit.  *//* Maximum bytes in POSIX message queues.  *//* Maximum number of pending signals.  *//* Maximum number of file locks.  *//* Locked-in-memory address space.  *//* Number of processes.  *//* Address space limit.  *//* BSD name for same.  *//* Number of open files.  *//* Largest resident set size, in bytes.
     This affects swapping; processes that are exceeding their
     resident set size will be more likely to have physical memory
     taken from them.  *//* Largest core file that can be created, in bytes.  *//* Maximum size of stack segment, in bytes.  *//* Maximum size of data segment, in bytes.  *//* Largest file that can be created, in bytes.  *//* Per-process CPU limit, in seconds.  *//* Kinds of resource limit.  *//* Transmute defines to enumerations.  The macro re-definitions are
   necessary because some programs want to test for operating system
   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
   definition is a no-op.  *//* Bit values & structures for resource limits.  Linux version.
   Copyright (C) 1994-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__resource__new_limit__old_limit/usr/include/x86_64-linux-gnu/sys/resource.h<bits/resource.h>setprioritygetprioritygetrusagesetrlimit64setrlimitgetrlimit64getrlimit__priority_which_t__rusage_who_t__rlimit_resource_tdefined(__REDIRECT_NTH)/* sys/resource.h  *//* Set the priority of all processes specified by WHICH and WHO (see above)
   to PRIO.  Returns 0 on success, -1 on errors.  *//* Return the highest priority of any process specified by WHICH and WHO
   (see above); if WHO is zero, the current process, process group, or user
   (as specified by WHO) is used.  A lower priority number means higher
   priority.  Priorities range from PRIO_MIN to PRIO_MAX (above).  *//* Return resource usage information on process indicated by WHO
   and put it in *USAGE.  Returns 0 for success, -1 for failure.  *//* Set the soft and hard limits for RESOURCE to *RLIMITS.
   Only the super-user can increase hard limits.
   Return 0 if successful, -1 if not (and sets errno).  *//* Put the soft and hard limits for RESOURCE in *RLIMITS.
   Returns 0 if successful, -1 if not (and sets errno).  *//* The X/Open standard defines that all the functions below must use
   `int' as the type for the first argument.  When we are compiling with
   GNU extensions we change this slightly to provide better error
   checking.  *//* Get the system-dependent definitions of structures and bit values.  *//* Copyright (C) 1992-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  */__who__rlimits/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/autogen.c<sys/resource.h>ignore_vars1438579165125setup_signalssighandler_proc_t *sasigNo 1maxSigSIGCHLDSIGABRTSIGKILLSIGSTOPSIGTSTPSIGPROFSIGWINCHSIGTTINSIGTTOUSIG_IGNconst sigactionconst sigaction *sigaction *const sigaction *__restrict__sigaction *__restrict__stderrFILE *__restrict__16319l_no2199o_state__jmp_buf_tag *EXIT_FAILUREdone_checkdone_check_doneTRACEtOptDesc *const1849stdout8258const char *const[11]char *[11]autogen_aborts3466"stderr redir"(size_t)1(size_t)posrdlen__cntconst void *__restrict__hdl_chldhdl_abrthdl_dflt1832EXIT_PCLOSE_WAITignore_signalcatch_sig_and_bailcleanup_and_abort216279776EXIT_PCLOSE_NOWAITSIG_DFLfnCdpzFnpzFl7225(mac_func_t)-16764CORE& DESC(CORE)& (autogenOptions.pOptDesc[INDEX_OPT_CORE])rlimexit_cleanupexit_cleanup_done23652398168167const char[]autogen.cconst char[10]231524922387mainlcLC_ALL"LC_ALL""C"char[2]LC_ALL=C"LC_ALL=C"char[9]char *constchar *const *execvp"execvp"inner_mainsighandler_proc_twait_for_pclose_enum_tvoid_main_proc_tconst char *const[]state_nameschar[14]#n,HAVE_SYS_RESOURCE_HHAVE_CHMODSIGRTMINdefined(DEBUG_ENABLED)HAVE_STRFTIMEHAVE_STRSIGNAL/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/autogen.c *//* tty output *//* tty input  *//* cannot happen, but the following might not be defined *//*
             *  Signals to ignore with SIG_IGN.
             *//*
             *  While debugging AutoGen, we want seg faults to happen and
             *  trigger core dumps.  Make sure this happens.
             *//*
             *  Signals we choose to leave alone.
             *//*
             *  Signals we must leave alone.
             *//*
             *  Signal handling for SIGCHLD needs to be ignored.  Do *NOT* use
             *  SIG_IGN to do this.  That gets inherited by programs that need
             *  to be able to use wait(2) calls.  At the same time, we don't
             *  want our children to become zombies.  We may run out of zombie
             *  space.  Therefore, set the handler to an empty procedure.
             *  POSIX oversight.  Allowed to be fixed for next POSIX rev, tho
             *  it is "optional" to reset SIGCHLD on exec(2).
             *//*
     *  When processing options, return so that the option processing exit code
     *  is used.  Otherwise, terminate execution now with the decided upon
     *  exit code.  (Always EXIT_FAILURE, unless this was called at the end
     *  of inner_main().)
     *//*
             *  Don't bother with the overhead if there is no work to do.
             *//*
     *  IF we diverted stderr, then now is the time to copy the text to stdout.
     *  This is done for CGI mode wherein we produce an error page in case of
     *  an error, but otherwise discard stderr.
     *//* continue normal exit *//* Exiting in option processing state is verbose enough *//* continue failure exit *//*
             *  Emit the CGI page header for an error message.  We will rewind
             *  stderr and write the contents to stdout momentarily.
             *//* FALLTHROUGH *//*
         *  We got here because someone called exit early.
         *//*
         * A library (viz., Guile) procedure has called exit(3C).  The
         * AutoGen abort paths all set processing_state to PROC_STATE_ABORTING.
         *//*
     *  There are contexts wherein this function can get called twice.
     *//**
 *  This is _always_ called for exit processing.
 *  This only returns if "exit(3C)" is called during option processing.
 *  We have no way of determining the correct exit code.
 *  (Requested version or help exits EXIT_SUCCESS.  Option failures
 *  are EXIT_FAILURE.  We cannot determine here.)
 *//**
 *  ignore_signal is the handler for SIGCHLD.  If we set it to default,
 *  it will kill us.  If we set it to ignore, it will be inherited.
 *  Therefore, always in all programs set it to call a procedure.
 *  The "wait(3)" call will do magical things, but will not override SIGIGN.
 *
 *  @param[in] sig the signal number
 *//**
 *  catch_sig_and_bail catches signals we abend on.  The "siglongjmp"
 *  goes back to the real "main()" procedure and it will call
 *  "cleanup_and_abort()", above.
 *
 *  @param[in] sig the signal number
 *//*
     *  If `--core' has been specified and if we have get/set rlimit,
     *  then try to set the core limit to the "hard" maximum before aborting.
     *//*
     *  IF there is a current template, then we should report where we are
     *  so that the template writer knows where to look for their problem.
     *//**
 *  A signal was caught, siglongjmp called and main() has called this.
 *  We do not deallocate stuff so it can be found in the core dump.
 *
 *  @param[in] sig the signal number
 *//*
     *  There are contexts wherein this function can get run twice.
     *//**
 * This code must run regardless of which exit path is taken
 *
 * @param [in] cl_wait Whether or not a child process should be waited for.
 */// setlocale(LC_ALL, "");/**
 * main() called from _start()
 *
 * @param  argc    argument count
 * @param  argv    argument vector
 * @return nothing -- Guile never returns, but calls exit(2).
 *//*
     *  Activate the AutoGen specific Scheme functions.
     *  Then load, process and unload the main template
     *//**
 * main routine under Guile guidance
 *
 * @param  closure Guile closure parameter.  Not used.
 * @param  argc    argument count
 * @param  argv    argument vector
 *//* = = = END-STATIC-FORWARD = = = *//* = = = START-STATIC-FORWARD = = = *///#include <locale.h>/**
 *  @file autogen.c
 *
 *  This is the main routine for autogen.
 *  @addtogroup autogen
 *  @{
 */cl_wait/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/defParse.xpz_new_nameFSM_USER_HEADERSFSM_FIND_TRANSITIONFSM_HANDLER_CODE/*
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/defParse.x *//* FSM_HANDLER_CODE *//*
     *  Allow this routine to be called multiple times.
     *  This may happen if we include another definition file.
     *//*
     *  The "here string" marker is the line before where the text starts.
     *//* in case not yet determined *//*
     *  Clone the entry name of the current entry.
     *//*
     *  The seed has now done its job.  The real root of the
     *  definitions is the first entry off of the seed.
     *//*
     *  We won't be using the parse stack any more.
     *  We only process definitions once.
     *//*
     *  Create a new entry with a specified indes, but defer "makeMacro" call
     *  until we have the assigned value.
     *//*
     *  Create a new entry but defer "makeMacro" call until we have the
     *  assigned value.
     *//*
     *  Our state is either "have-name" or "indx-name" and we found a ';',
     *  end of statement.  It is a string value with an empty string.
     *//*
 *  Print out an invalid transition message and return EXIT_FAILURE
 *//* FSM_FIND_TRANSITION *//* FSM_USER_HEADERS *//**
 * @file defParse.x
 *
 * Definition parser functions.
 *
 *  This file is part of AutoGen.
 *  AutoGen Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
 *
 * AutoGen is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AutoGen is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */dp_do_tpl_nameOVERRIDE_TPL& DESC(OVERRIDE_TPL)& (autogenOptions.pOptDesc[INDEX_OPT_OVERRIDE_TPL])zBogus@BOGUS@"@BOGUS@"const char[8]dp_do_str_value"assigning a block value to text name"assigning a block value to text namedp_do_start_blockent_stack_sz * sizeof(void *)"def stack""stretch def stack"ppDEsizeof(dft_ent_stack)dp_do_next_valdp_do_need_name_var_namedp_do_need_name_end"definition blocks were left open"definition blocks were left openchar[33]dp_do_invalid"invalid transition"invalid transitionchar[19]dp_do_indexed_namedp_do_have_name_lit_eqdp_do_need_value_delete_entdp_do_end_block"Too many close braces"Too many close braceschar[22]dp_do_empty_valpDEdp_invalid_transitionfmt_pzconst char[290]char[290]290DpFsmErr_offstevtconst size_t[11]unsigned long[11]const size_t *const size_t[17]unsigned long[17]initialmaybe_nexttrans_evt/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/defParse-fsm.c"defParse.x"dp_statenxtStdp_callback_t *const t_dp_transitionconst t_dp_transition *transition *ttblconst t_dp_transition[16]transition[16]const t_dp_transition[11][16]transition[11][16]const t_dp_transition(*)[16]transition(*)[16]t_dp_transitiontransitiondp_callback_ttrans_procnext_stateaszDpEvents18719520721922823924625826927627828028228428628875aszDpStates88116126147156176zDpStrings** OUT-OF-RANGE ** FSM Error:  in state %d (%s), event %d (%s) is invalid
 invalid init need_def need_tpl need_semi need_name have_name need_value need_idx need_cbkt indx_name have_value autogen definitions End-Of-File var_name other_name string here_string delete_ent number ; = , { } [ ]"** OUT-OF-RANGE **\0"
/*    19 */ "FSM Error:  in state %d (%s), event %d (%s) is invalid\n\0"
/*    75 */ "invalid\0"
/*    83 */ "init\0"
/*    88 */ "need_def\0"
/*    97 */ "need_tpl\0"
/*   106 */ "need_semi\0"
/*   116 */ "need_name\0"
/*   126 */ "have_name\0"
/*   136 */ "need_value\0"
/*   147 */ "need_idx\0"
/*   156 */ "need_cbkt\0"
/*   166 */ "indx_name\0"
/*   176 */ "have_value\0"
/*   187 */ "autogen\0"
/*   195 */ "definitions\0"
/*   207 */ "End-Of-File\0"
/*   219 */ "var_name\0"
/*   228 */ "other_name\0"
/*   239 */ "string\0"
/*   246 */ "here_string\0"
/*   258 */ "delete_ent\0"
/*   269 */ "number\0"
/*   276 */ ";\0"
/*   278 */ "=\0"
/*   280 */ ",\0"
/*   282 */ "{\0"
/*   284 */ "}\0"
/*   286 */ "[\0"
/*   288 */ "]"dp_trans_tableDP_STATE_NAME(s)( (((unsigned)(s)) >= 11) ? zDpStrings : zDpStrings + aszDpStates[s])DP_EVT_NAME(t)( (((unsigned)(t)) >= 17) ? zDpStrings : zDpStrings + aszDpEvents[t])DpStInit_offDpEvInvalid_offDEFINE_FSM__COVERITY__/*
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of defParse-fsm.c *//* __COVERITY__ *//*   288 *//*   286 *//*   284 *//*   282 *//*   280 *//*   278 *//*   276 *//*   269 *//*   258 *//*   246 *//*   239 *//*   219 *//*   207 *//*   195 *//*   187 *//*   176 *//*   166 *//*   156 *//*   147 *//*   136 *//*   126 *//*   116 *//*   106 *//*    97 *//*    88 *//*    75 *//*    19 *//* EVT:  ] *//* EVT:  [ *//* EVT:  } *//* EVT:  { *//* EVT:  , *//* EVT:  = *//* EVT:  ; *//* EVT:  NUMBER *//* EVT:  DELETE_ENT *//* EVT:  HERE_STRING *//* EVT:  STRING *//* EVT:  OTHER_NAME *//* EVT:  VAR_NAME *//* EVT:  End-Of-File *//* EVT:  DEFINITIONS *//* EVT:  AUTOGEN *//* STATE 10:  DP_ST_HAVE_VALUE *//* STATE 9:  DP_ST_INDX_NAME *//* STATE 8:  DP_ST_NEED_CBKT *//* STATE 7:  DP_ST_NEED_IDX *//* STATE 6:  DP_ST_NEED_VALUE *//* STATE 5:  DP_ST_HAVE_NAME *//* STATE 4:  DP_ST_NEED_NAME *//* STATE 3:  DP_ST_NEED_SEMI *//* STATE 2:  DP_ST_NEED_TPL *//* STATE 1:  DP_ST_NEED_DEF *//* STATE 0:  DP_ST_INIT *//**
 *  State transition maps.  Map the enumeration and the event enumeration
 *  to the new state and the transition enumeration code (in that order).
 *  It is indexed by first the current state and then the event code.
 *//**
 *  Declare all the state transition handling routines.
 *//**
 *  Callback routine prototype.  They return the next state.  Normally, that
 *  should be the value of the "maybe_next" argument.
 *//*   -*- buffer-read-only: t -*- vi: set ro:
 *
 *  DO NOT EDIT THIS FILE   (defParse-fsm.c)
 *
 *  It has been AutoGen-ed
 *  From the definitions    defParse.def
 *  and the template file   fsm
 *
 *  Automated Finite State Machine
 *
 *  Copyright (C) 1992-2015 Bruce Korb - all rights reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name ``Bruce Korb'' nor the name of any other
 *    contributor may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * AutoFSM IS PROVIDED BY Bruce Korb ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bruce Korb OR ANY OTHER CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/defLex.cbuild_here_strno_tabsmarkLenhere_str_linechar[64]here_mark'-'trueaprf(DEF_ERR_FMT, ag_pname, HERE_MISS_MARK_STR, cctx->scx_fname, cctx->scx_line)aprf((ag_text_strtable+1027), autogenOptions.pzProgName, (ag_text_strtable+3764), cctx->scx_fname, cctx->scx_line)10273764aprf(DEF_ERR_FMT, ag_pname, HERE_MARK_TOO_LONG, cctx->scx_fname, cctx->scx_line)aprf((ag_text_strtable+1027), autogenOptions.pzProgName, (ag_text_strtable+3824), cctx->scx_fname, cctx->scx_line)sizeof(here_mark)3824aprf(DEF_ERR_FMT, ag_pname, HERE_ENDLESS_STR, cctx->scx_fname, cctx->scx_line)aprf((ag_text_strtable+1027), autogenOptions.pzProgName, (ag_text_strtable+3740), cctx->scx_fname, cctx->scx_line)3740scan[1]scan[markLen]aprf(DEF_ERR_FMT, ag_pname, HERE_ENDLESS_STR, cctx->scx_fname, here_str_line)aprf((ag_text_strtable+1027), autogenOptions.pzProgName, (ag_text_strtable+3740), cctx->scx_fname, here_str_line)next_line92'\\'1769536gather_namete_dp_event *enum <unnamed> **scanscan + 2scan + 1196608'0'120'x''X'aprf(ASSEMBLE_NAME_ERR, ag_pname, *scan, cctx->scx_fname, cctx->scx_line)aprf((ag_text_strtable+510), autogenOptions.pzProgName, *scan, cctx->scx_fname, cctx->scx_line)8388608510*pzpz+1sv_chkw_ix 0const char *const[2](int)KEYWORD_CTte_dp_event[2]enum <unnamed>[2]alist_to_autogen_defpzTextpzEndres_lenpCtxendCh408327sizeof(scan_ctx_t) + 4 + res_len"lex ctx"pCtx->scx_fname"scheme text"380pCtx->scx_scanscm_i_string_chars(res)loadSchemeret_valschemeLennext_lnaprf(DEF_ERR_FMT, ag_pname, LOAD_SCM_ENDLESS, cctx->scx_fname, cctx->scx_line)aprf((ag_text_strtable+1027), autogenOptions.pzProgName, (ag_text_strtable+5020), cctx->scx_fname, cctx->scx_line)5020"SCM Result"1627316108aprf(YYLEX_ERR_FMT, s, cctx->scx_fname, cctx->scx_line, pz, cctx->scx_scan)aprf((ag_text_strtable+16114), s, cctx->scx_fname, cctx->scx_line, pz, cctx->scx_scan)16114scan_again*cctx->scx_scan3073O_BRACEEQC_BRACEOPEN_BKTCLOSE_BKTSEMICOMMA'#'123'{''=''}''['']'';'',''\'''"''$'60'('14382(size_t)2'`'bad_tokenNUL_erroraprf(DEF_ERR_FMT, ag_pname, YYLEX_UNENDING_QUOTE, cctx->scx_fname, cctx->scx_line)aprf((ag_text_strtable+1027), autogenOptions.pzProgName, (ag_text_strtable+16286), cctx->scx_fname, cctx->scx_line)16286lex_donelex_here_stringlex_dollarcctx->scx_scan+3fnsfne-1fne')'svclex_comment'*'2190lex_backquoteline_nolex_escaped_charsemi_colonpz[1](char)semi_colontrim_whitespacecount_nlctpop_contextpCXte_dp_event[]enum <unnamed>[]kword_tknsAUTOGENDEFINITIONSkword_tableconst char[12]zDEFINITIONSzAUTOGENSET_LIT_TKNSET_LIT_TKN(t)token_code = DP_EV_LIT_ ## t; *(cctx->scx_scan++) = NUL;FINISHERRORKEYWORD_CT(sizeof(kword_table) / sizeof(kword_table[0]))_KW__KW_(w)DP_EV_ ## w,z ## w,static char const z ## w [] = #w;KEYWORD_TABLE_KW_( AUTOGEN ) _KW_( DEFINITIONS )/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/defLex.c *//*
     *  dest may still equal token_str, if no data were copied
     *//* while strncmp ... *//*
         *  If we recognize the end mark, break out.
         *//*
     *  And skip the first new line + conditionally skip tabs
     *//*
     *  Skip forward to the EOL after the marker.
     *//*
     *  Copy the marker, noting its length
     *//*
     *  Skip white space up to the marker or EOL
     *//*
     *  See if we are to strip leading tab chars
     *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  A quoted string has been found.
 *  Find the end of it and compress any escape sequences.
 *//* restore the following character  *//*
                 *  Return the keyword token code instead of DP_EV_NAME
                 *//* NUL terminate the name           *//* preserve the following character *//*
     *  Now scan the keyword table.
     *//*
         *  Return a NAME token, maybe.
         *  If the name is actually a keyword,
         *  we will return that token code instead.
         *//*
     *  Check for a number.  We don't care about leading zeros, that
     *  is a user's problem, so no distinction between octal and decimal.
     *  However, we look for "0x" and "0X" prefixes for hex numbers.
     *//**
 *  It may be a number, a name, a keyword or garbage.
 *  Figure out which.
 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//*
     *  At this point, the next token will be obtained from the newly
     *  allocated context structure.  When empty, input will resume
     *  from the '}' that we left as the next input token in the old
     *  context.
     *//*
     *  Set up the rest of the context structure
     *//*
     *  Now, push the resulting string onto the input stack
     *  and link the new scan data into the context stack
     *//*
     *  The result *must* be a string, or we choke.
     *//*
     *  Run the scheme expression.  The result is autogen definition text.
     *//*
     *  Wrap the scheme expression with the `alist->autogen-def' function
     *//*
 *  process a single scheme expression, yielding text that gets processed
 *  into AutoGen definitions.
 *//*
         *  We know the result is smaller than the source.  Copy in place.
         *//* ignore const-ness *//*
     *  NUL terminate the Scheme expression, run it, then restore
     *  the NUL-ed character.
     *//*
     *  First time through, return the DP_EV_END token.
     *  Second time through, we really finish.
     *//* switch (*cctx->scx_scan) *//* to Invalid input char *//*
         *  Ensure that the compiler doesn't try to save a copy of
         *  "cctx" in a register.  It must be reloaded from memory.
         *//*
         *  IF we are not inside an include context,
         *  THEN go finish.
         *//*
     *  Start the process of locating a token.
     *  We branch here after skipping over a comment
     *  or processing a directive (which may change our context).
     *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   LEXICAL SCANNER
 *//* done -- we've loaded the file. *//*
     * Find the start and end of the file name and load the file text.
     *//*
     * First, ensure the string starts with what we recognize
     *//**
 * process a dollar character introduced value.
 *
 * '$(<...)' load a file that must be there.
 * '$(?...)' load a file that may be there. If not there, then delete
 *           the named value associated with it.
 *//*
     *  Allow for a comment, C or C++ style
     *//*
     *  This ensures that any names found previously
     *  are NUL terminated.
     *//**
 * Remove leading white space from the current scan point.
 *//**
 * Count the newlines in a NUL terminated string
 *//**
 *  Pop off an include context and resume from the including file.
 *//*
 *  This keyword table must match those found in agParse.y.
 *  You will find them in a %token statement that follows
 *  a comment  "Keywords"
 *//*
 *  This file is part of AutoGen.
 *  AutoGen Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
 *
 * AutoGen is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AutoGen is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *//**
 * @file defLex.c
 *
 *  This module scans the template variable declarations and passes
 *  tokens back to the parser.
 *
 * @addtogroup autogen
 * @{
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/directive.c<ctype.h>doDir_hdl_t *doDir_hdl_t *constdoDir_hdl_t *const[22]..(*[22])(..)dispatchunsigned int[]keywd_lenklenunsigned int[21]dispdoDir_hdl_t *const *undef* UNDEFINED *"* UNDEFINED *"nm_tableconst char[14]const char *const[21]char *[21]assert"assert"define"define"elif"elif"else"else"endif"endif"endmac"endmac"endshell"endshell""error"ident"ident"if"if"char[3]ifdef"ifdef"ifndef"ifndef"include"include"let"let"char[4]"line"macdef"macdef"option"option"pragma"pragma"shell"shell""undef"const directive_map_tconst directive_map_t *mapacceptacdefghilmnoprstu"acdefghilmnoprstu"char[18]clenconst char[18](unsigned char)str[clen]((unsigned char)str[clen])_ISalnumconst unsigned shortconst unsigned short *const unsigned short **unsigned short **find_directive_nameregisterconst directive_map_t[37]struct <unnamed>[37]directive_hashconst unsigned char[]unsigned char[]asso_valueshvalconst unsigned char[256]directive_map_tdir_iddir_nameconst directive_map_t[]struct <unnamed>[]directive_table/* end of directive.c *//**
 * Dispatch a directive function, based on the keyword.
 *
 * @param[in] str  a string that should start with a known key word.
 * @returns char *, returned by the dispatched function.
 *//**
 * Convert an directive_enum_t value into a string.
 *
 * @param[in] id  the enumeration value
 * @returns the associated string, or "* UNDEFINED *" if \a id
 * is out of range.
 *//**
 * Convert a command (keyword) to a directive_enum_t enumeration value.
 * The length of the command is computed by calling \a strspn()
 * on the input argument.
 *
 * @param[in] str   a string that should start with a known key word.
 * @returns the enumeration value.
 * If not found, that value is DIR_INVALID.
 *//*FALLTHROUGH*//* maximum key range = 34, duplicates = 0 *///// %define initializer-suffix      ,DIR_COUNT// %define word-array-name         directive_table// %define lookup-function-name    find_directive_name// %define hash-function-name      directive_hash// %define slot-name               dir_name// %compare-strncmp// %readonly-tables// %omit-struct-type// %global-table// %includes// %language=ANSI-C// %struct-type/* gperf build options: *//* Computed positions: -k'2,4' *//* Command-line: gperf directive.gp  *//* ANSI-C code produced by gperf version 3.0.4 *//** \file directive.c
 * Code for string to enumeration values and back again.
 * @addtogroup autogen
 * @{
 *//*   -*- buffer-read-only: t -*- vi: set ro:
 *
 *  DO NOT EDIT THIS FILE   (directive.c)
 *
 *  It has been AutoGen-ed
 *  From the definitions    directive.def
 *  and the template file   str2enum
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name ``Bruce Korb'' nor the name of any other
 *    contributor may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * str2enum IS PROVIDED BY Bruce Korb ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bruce Korb OR ANY OTHER CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/funcCase.ct_match_procregexpregex_t *re_pattern_buffer *mLoad_Selectsel_argarg_lenload_proc_p_t[24]load_proc_p_t *current_tpl=(tpl); cur_macro=(mac); AG_ABEND((ag_text_strtable+4622));current_tpl=(tpl); cur_macro=(mac); ag_abend_at((ag_text_strtable+4622));4622current_tpl=(tpl); cur_macro=(mac); AG_ABEND((ag_text_strtable+4639));current_tpl=(tpl); cur_macro=(mac); ag_abend_at((ag_text_strtable+4639));4639(int)FTYP_SELECT_EQV_MATCH_FULL( unsigned int)FTYP_SELECT_EQUIVALENT_FULL4294934523~( unsigned int)FTYP_SELECT_EQUIVALENT_FULL(unsigned int)FTYP_SELECT_COMPARE_FULL4294967291~( unsigned int)FTYP_SELECT_EQUIVALENT_FULL
            | (unsigned int)FTYP_SELECT_COMPARE_FULLconst unsigned intREG_EXTENDEDREG_ICASEsvdest(uint8_t)*(sel_arg++)toupper*__ctype_toupper_loc ()((uint8_t)*(sel_arg++))__res-128const __int32_tconst __int32_t *const __int32_t **selection_doneselection_type_completefcode*src3075(unsigned int)FTYP_SELECT_COMPARE_SKP_START(unsigned int)FTYP_SELECT_COMPARE_FULL |
            (unsigned int)FTYP_SELECT_COMPARE_SKP_START(mac_func_t)(
            (unsigned int)FTYP_SELECT_COMPARE_FULL |
            (unsigned int)FTYP_SELECT_COMPARE_SKP_START)src[1]'~'(unsigned int)FTYP_SELECT_MATCH_FULL(unsigned int)FTYP_SELECT_EQUIVALENT_FULL'+''e''E'bad_sel(unsigned int)FTYP_SELECT_COMPARE_SKP_ENDleave_donesave_stackpEsacMacpapLPpMaccurrent_tpl=(pT); cur_macro=(pMac); AG_ABEND((ag_text_strtable+4354));current_tpl=(pT); cur_macro=(pMac); ag_abend_at((ag_text_strtable+4354));4354apCaseLoad192sizeof( base_load_table )current_tpl=(pT); cur_macro=(pMac); AG_ABEND((ag_text_strtable+4339));current_tpl=(pT); cur_macro=(pMac); ag_abend_at((ag_text_strtable+4339));4339pscanpsrct_match_proc *t_match_proc *constt_match_proc *const[]..(*[])(..)match_procsmatch_namesfree_txtsamp_textmRes1471214528t_match_proc *const[15]..(*[15])(..)t_match_proc *const *0x0F14744const char *const[15]char *[15]14778COMPARE_FULL"COMPARE_FULL"char[13]COMPARE_END"COMPARE_END"COMPARE_START"COMPARE_START"CONTAINS"CONTAINS"EQUIVALENT_FULL"EQUIVALENT_FULL"char[16]EQUIVALENT_END"EQUIVALENT_END"char[15]EQUIVALENT_START"EQUIVALENT_START"char[17]EQUIV_CONTAINS"EQUIV_CONTAINS"MATCH_FULL"MATCH_FULL"char[11]MATCH_END"MATCH_END"MATCH_START"MATCH_START"MATCH_WITHIN"MATCH_WITHIN"MATCH_ALWAYS"MATCH_ALWAYS"MATCH_EXISTENCE"MATCH_EXISTENCE"MATCH_NONEXISTENCE"MATCH_NONEXISTENCE"Select_Match_NonExistenceSelect_Match_ExistenceSelect_Match_Alwaystext to match"text to match"pzSubstrmatch expr"match expr"regmatch_t[2]struct <unnamed>[2](((((0)) << 8) + scm_tc8_flag))(((((4)) << 8) + scm_tc8_flag))(4)const regex_tconst regex_t *const regex_t *__restrict__regmatch_t *regmatch_t *__restrict__1028Select_Match_Fullpatternsizeof(*re)"select match full re"mat15429samplesubstrSelect_Match_Start"select match start re"Select_Match_End"select match end re"(size_t)0Select_Match"select match re"tt"text"m expr"m expr"Select_Equivalent_FullSelect_Equivalent_Start(pzText, pzSubstr)Select_Equivalent_StartvlenSelect_Equivalent_End( pzText, pzSubstr )Select_Equivalent_Endtlenag_scm2zchars(substr, "search")"substr"searchSelect_Equivalent(ag_scm2zchars(text, "sample"), pzSubstr)Select_Equivalent"equiv chars"Select_Compare_FullSelect_Compare_Start(pzText, pzSubstr)Select_Compare_StartSelect_Compare_End(pzText, pzSubstr)Select_Compare_EndSelect_Compareup_case(int)*pz524288compile_repatrerrregex_t *__restrict__char[256]erbfsizeof(erbf)1101tCaseStackcase_stacktSelectProcpSelectpCaseapSelectOnlycurrent_case_toupper__toupper/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/funcCase.c *//**
 * Free data for a selection macro.  Regular expression selections
 * allocate the compiled re.
 *//*
     *  Link this selection macro to the list of selectors for CASE.
     *//*
         * If the value is a quoted string, strip the quotes and
         * process the string (backslash fixup).
         *//*
     *  Copy the selection expression, double NUL terminate.
     *//*
     *  See if we are doing case insensitive regular expressions
     *  Turn off the case comparison mode for regular expressions.
     *  We don't have to worry about it.  It is done for us.
     *//*
     *  Set the global macro loading mode
     *//* macro len  *//*=macfunc SELECT
 *
 *  what:    Selection block for CASE function
 *  in-context:
 *  alias:   | ~ | = | * | ! | + |
 *  unload-proc:
 *
 *  desc:
 *    This macro selects a block of text by matching an expression
 *    against the sample text expression evaluated in the @code{CASE}
 *    macro.  @xref{CASE}.
 *
 *    You do not specify a @code{SELECT} macro with the word ``select''.
 *    Instead, you must use one of the 19 match operators described in
 *    the @code{CASE} macro description.
=*//*
     *  md_code has been set.  Zero out md_txt_off to indicate
     *  no argument text.  NULL the selection argument pointer.
     *//*
     *  IF the last character is an asterisk,
     *  THEN the match may end before the test string ends.
     *       OR in the "may end early" bit.
     *//*
         *  IF the '~' or '=' is doubled,
         *  THEN it is a case sensitive match.  Skip over the char.
         *  ELSE or in the case insensitive bit
         *//*
         *  Or in the pattern matching bit
         *//*
     *  The next character must indicate whether we are
     *  pattern matching ('~') or doing string compares ('=')
     *//*
     *  IF the first character is an asterisk,
     *  THEN the match can start anywhere in the string
     *//**
 *  Figure out the selection type.  Return "true" (it is complete) if
 *  no argument is required.  That is, if it is a "match anything" or
 *  an existence/non-existence test.
 *
 *  @param[in]      tpl  The active template
 *  @param[in,out]  mac  The selection macro structure
 *  @param[out]     psrc The scan pointer for the selection argument
 *//*
     *  Return the next available macro descriptor
     *//*
     *  Restore the global macro loading mode
     *//*
     *  Restore any enclosing CASE function's context.
     *//*
     *  Tell the last select macro where its end is.
     *  (It ends with the "next" sibling.  Since there
     *  is no "next" at the end, it is a tiny lie.)
     *
     *  Also, make sure the CASE macro knows where the end is.
     *//*
     *  Continue parsing the template from this nested level
     *//*
     *  Save global pointers to the current macro entry.
     *  We will need this to link the CASE, SELECT and ESAC
     *  functions together.
     *//*
     *  Set the "select macro only" loading mode
     *//*
         *  Until there is a selection clause, only comment and select
         *  macros are allowed.
         *//*
     *  IF this is the first time here,
     *  THEN set up the "CASE" mode callout tables.
     *  It is the standard table, except entries are inserted
     *  for SELECT and ESAC.
     *//*
     *  Load the expression
     *//*
     *  IF there is no associated text expression
     *  THEN woops!  what are we to case on?
     *//*
     *  Save the global macro loading mode
     *//*
 *  mLoad_CASE
 *
 *  This function is called to set up (load) the macro
 *  when the template is first read in (before processing).
 *//*
         *  IF match, THEN generate and stop looking for a match.
         *//*
         *  The current macro becomes the selected selection macro
         *//*
     *  Search through the selection clauses until we either
     *  reach the end of the list for this CASE macro, or we match.
     *//*
     *  There are only 15 procedures because the case insenstive matching
     *  get mapped into the previous four.  The last three are "match always",
     *  "match if a value was found" "match if no value found".
     *//*=macfunc ESAC
 *
 *  what:   Terminate the @code{CASE} Template Block
 *  in-context:
 *
 *  desc:
 *    This macro ends the @code{CASE} function template block.
 *    For a complete description, @xref{CASE}.
=*//*=macfunc CASE
 *
 *  what:   Select one of several template blocks
 *  handler_proc:
 *  load_proc:
 *
 *  desc:
 *
 *  The arguments are evaluated and converted to a string, if necessary.  A
 *  simple name will be interpreted as an AutoGen value name and its value will
 *  be used by the @code{SELECT} macros (see the example below and the
 *  expression evaluation function, @pxref{EXPR}).  The scope of the macro is
 *  up to the matching @code{ESAC} macro.  Within the scope of a @code{CASE},
 *  this string is matched against case selection macros.  There are sixteen
 *  match macros that are derived from four different ways matches may be
 *  performed, plus an "always true", "true if the AutoGen value was found",
 *  and "true if no AutoGen value was found" matches.  The codes for the
 *  nineteen match macros are formed as follows:
 *
 *  @enumerate
 *  @item
 *  Must the match start matching from the beginning of the string?
 *  If not, then the match macro code starts with an asterisk (@code{*}).
 *  @item
 *  Must the match finish matching at the end of the string?
 *  If not, then the match macro code ends with an asterisk (@code{*}).
 *  @item
 *  Is the match a pattern match or a string comparison?
 *  If a comparison, use an equal sign (@code{=}).
 *  If a pattern match, use a tilde (@code{~}).
 *  @item
 *  Is the match case sensitive?
 *  If alphabetic case is important, double the tilde or equal sign.
 *  @item
 *  Do you need a default match when none of the others match?
 *  Use a single asterisk (@code{*}).
 *  @item
 *  Do you need to distinguish between an empty string value and a value
 *  that was not found?  Use the non-existence test (@code{!E}) before
 *  testing a full match against an empty string (@code{== ''}).
 *  There is also an existence test (@code{+E}), more for symmetry than
 *  for practical use.
 *  @end enumerate
 *
 *  @noindent
 *  For example:
 *
 *  @example
 *  [+ CASE <full-expression> +]
 *  [+ ~~*  "[Tt]est" +]reg exp must match at start, not at end
 *  [+ ==   "TeSt"    +]a full-string, case sensitive compare
 *  [+ =    "TEST"    +]a full-string, case insensitive compare
 *  [+ !E             +]not exists - matches if no AutoGen value found
 *  [+ ==   ""        +]expression yielded a zero-length string
 *  [+ +E             +]exists - matches if there is any value result
 *  [+ *              +]always match - no testing
 *  [+ ESAC +]
 *  @end example
 *
 *  @code{<full-expression>} (@pxref{expression syntax}) may be any expression,
 *  including the use of apply-codes and value-names.  If the expression yields
 *  a number, it is converted to a decimal string.
 *
 *  These case selection codes have also been implemented as
 *  Scheme expression functions using the same codes.  They are documented
 *  in this texi doc as ``string-*?'' predicates (@pxref{Common Functions}).
=*//**
 *  If the "sample" addresses "zUndefined", then we couldn't find a value and
 *  defaulted to an empty string.  So, the result false if the sample address
 *  is anything except "zUndefined".
 *//**
 *  If the "sample" addresses "zNil", then we couldn't find a value and
 *  defaulted to an empty string.  So, the result is true if the sample
 *  address is anything except "zNil".
 *//**
 *  We don't bother making a Guile function for any of these :)
 *//*
     *  On the first call for this macro, compile the expression
     *//*=gfunc string_eqv_match_p
 *
 * what:   caseless regex match
 * general_use:
 *
 * exparg: text, text to test for pattern
 * exparg: match, pattern/substring to search for
 *
 * string: "~"
 *
 * doc:  Test to see if a string fully matches a pattern.
 *       Case is not significant, but any character equivalences
 *       must be expressed in your regular expression.
=*//*=gfunc string_match_p
 *
 * what:   regex match
 * general_use:
 *
 * exparg: text, text to test for pattern
 * exparg: match, pattern/substring to search for
 *
 * string: "~~"
 *
 * doc:  Test to see if a string fully matches a pattern.
 *       Case is significant.
=*//*=gfunc string_start_eqv_match_p
 *
 * what:   caseless regex start
 * general_use:
 *
 * exparg: text, text to test for pattern
 * exparg: match, pattern/substring to search for
 *
 * string: "~*"
 *
 * doc:  Test to see if a string starts with a pattern.
 *       Case is not significant.
=*//*=gfunc string_start_match_p
 *
 * what:   regex match start
 * general_use:
 *
 * exparg: text, text to test for pattern
 * exparg: match, pattern/substring to search for
 *
 * string: "~~*"
 *
 * doc:  Test to see if a string starts with a pattern.
 *       Case is significant.
=*//*=gfunc string_end_eqv_match_p
 *
 * what:   caseless regex ending
 * general_use:
 *
 * exparg: text, text to test for pattern
 * exparg: match, pattern/substring to search for
 *
 * string: "*~"
 *
 * doc:  Test to see if a string ends with a pattern.
 *       Case is not significant.
=*//*=gfunc string_end_match_p
 *
 * what:   regex match end
 * general_use:
 *
 * exparg: text, text to test for pattern
 * exparg: match, pattern/substring to search for
 *
 * string: "*~~"
 *
 * doc:  Test to see if a string ends with a pattern.
 *       Case is significant.
=*//*=gfunc string_has_eqv_match_p
 *
 * what:   caseless regex contains
 * general_use:
 *
 * exparg: text, text to test for pattern
 * exparg: match, pattern/substring to search for
 *
 * string: "*~*"
 *
 * doc:  Test to see if a string contains a pattern.
 *       Case is not significant.
=*//*=gfunc string_has_match_p
 *
 * what:   contained regex match
 * general_use:
 *
 * exparg: text, text to test for pattern
 * exparg: match, pattern/substring to search for
 *
 * string: "*~~*"
 *
 * doc:  Test to see if a string contains a pattern.
 *       Case is significant.
=*//*
     *  We are overloading the "=" operator.  Our arguments may be
     *  numbers or booleans...
     *//*=gfunc string_eqv_p
 *
 * what:   caseless match
 * general_use:
 *
 * exparg: text, text to test for pattern
 * exparg: match, pattern/substring to search for
 *
 * string: "="
 *
 * doc:  Test to see if two strings are equivalent.  `equivalent' means the
 *       strings match, but without regard to character case and certain
 *       characters are considered `equivalent'.  Viz., '-', '_' and '^' are
 *       equivalent.  If the arguments are not strings, then the result of the
 *       numeric comparison is returned.
 *
 *       This is an overloaded operation.  If the arguments are both
 *       numbers, then the query is passed through to @code{scm_num_eq_p()},
 *       otherwise the result depends on the SCMs being strictly equal.
=*//*=gfunc string_starts_eqv_p
 *
 * what:   caseless string start
 * general_use:
 *
 * exparg: text, text to test for pattern
 * exparg: match, pattern/substring to search for
 *
 * string: "=*"
 *
 * doc:  Test to see if a string starts with an equivalent string.
=*//*=gfunc string_ends_eqv_p
 *
 * what:   caseless string ending
 * general_use:
 *
 * exparg: text, text to test for pattern
 * exparg: match, pattern/substring to search for
 *
 * string: "*="
 *
 * doc:  Test to see if a string ends with an equivalent string.
=*//*=gfunc string_contains_eqv_p
 *
 * what:   caseless substring
 * general_use:
 *
 * exparg: text, text to test for pattern
 * exparg: match, pattern/substring to search for
 *
 * string: "*=*"
 *
 * doc:  Test to see if a string contains an equivalent string.
 *       `equivalent' means the strings match, but without regard
 *       to character case and certain characters are considered `equivalent'.
 *       Viz., '-', '_' and '^' are equivalent.
=*//*=gfunc string_equals_p
 *
 * what:   string matching
 * general_use:
 *
 * exparg: text, text to test for pattern
 * exparg: match, pattern/substring to search for
 *
 * string: "=="
 *
 * doc:  Test to see if two strings exactly match.
=*//*=gfunc string_starts_with_p
 *
 * what:   string starting
 * general_use:
 *
 * exparg: text, text to test for pattern
 * exparg: match, pattern/substring to search for
 *
 * string: "==*"
 *
 * doc:  Test to see if a string starts with a substring.
=*//*=gfunc string_ends_with_p
 *
 * what:   string ending
 * general_use:
 * exparg: text, text to test for pattern
 * exparg: match, pattern/substring to search for
 *
 * string: "*=="
 *
 * doc:  Test to see if a string ends with a substring.
 *       strcmp(3) returns zero for comparing the string ends.
=*//*=gfunc string_contains_p
 *
 * what:   substring match
 * general_use:
 * exparg: text, text to test for pattern
 * exparg: match, pattern/substring to search for
 *
 * string: "*==*"
 *
 * doc:  Test to see if a string contains a substring.  "strstr(3)"
 *       will find an address.
=*//*
 *  This is global data used to keep track of the current CASE
 *  statement being processed.  When CASE statements nest,
 *  these data are copied onto the stack and restored when
 *  the nested CASE statement's ESAC function is found.
 *//**
 * @file funcCase.c
 *
 *  This module implements the CASE text function.
 *
 * @addtogroup autogen
 * @{
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/funcDef.capDefineLoadnew_tplsave_load_procsori_tplcurrent_tpl=(ori_tpl); cur_macro=(mac); AG_ABEND((ag_text_strtable+4374));current_tpl=(ori_tpl); cur_macro=(mac); ag_abend_at((ag_text_strtable+4374));4374sizeof(base_load_table)VOIDP(new_tpl)((void *)(uintptr_t)(new_tpl))new_tpl->td_size"resize mac"sizeof(*mac)load_define_tpllast_mactpl->td_macroscurrent_tpl=(tpl); cur_macro=(tpl->td_macros); AG_ABEND((ag_text_strtable+4397));current_tpl=(tpl); cur_macro=(tpl->td_macros); ag_abend_at((ag_text_strtable+4397));4397(int)sizeof(macro_t)new_templatentplaloc_szsizeof(*ntpl)sizeof(macro_t)18446744073709551600(size_t)~0x0F"new tpl"ntpl->td_macros + ctbase_tplcurrent_tpl=(base_tpl); cur_macro=(mac); AG_ABEND((ag_text_strtable+4374));current_tpl=(base_tpl); cur_macro=(mac); ag_abend_at((ag_text_strtable+4374));1572928386672015372tpl->td_text[ mac->md_name_off ]find_tpl(tpl->td_text + mac->md_name_off)aprf(BAD_MAC_NM_FMT, p)aprf((ag_text_strtable+592), p)current_tpl=(tpl); cur_macro=(mac); AG_ABEND(aprf((ag_text_strtable+592), p));current_tpl=(tpl); cur_macro=(mac); ag_abend_at(aprf((ag_text_strtable+592), p));592macNamemac name"mac name"current_tpl=(tpl); cur_macro=(mac); AG_ABEND(pz);current_tpl=(tpl); cur_macro=(mac); ag_abend_at(pz);mac->md_resdef_list_t *def_list *pListdefCtctx14607pList->de.de_val.dvu_textbuild_defspz + 1def_list->de.de_val.dvu_textag_scm2zchars(res, "res")"ev res""num buf""nil str"retryExpression14817(size_t)16794dummy3186'A''G'110'n'78'N'163843287prep_invoke_argscurrent_tpl=(pT); cur_macro=(mac); AG_ABEND((ag_text_strtable+7255));current_tpl=(pT); cur_macro=(mac); ag_abend_at((ag_text_strtable+7255));7255*pzTextcurrent_tpl=(pT); cur_macro=(mac); AG_ABEND((ag_text_strtable+7288));current_tpl=(pT); cur_macro=(mac); ag_abend_at((ag_text_strtable+7288));pzText + 17288pzScanpDLpNct * sizeof(def_list_t)"array of def desc"80sizeof(def_list_t)uint_t *fill_in_valuescurrent_tpl=(pT); cur_macro=(mac); AG_ABEND((ag_text_strtable+2931));current_tpl=(pT); cur_macro=(mac); ag_abend_at((ag_text_strtable+2931));*pzScancurrent_tpl=(pT); cur_macro=(mac); AG_ABEND((ag_text_strtable+2956));current_tpl=(pT); cur_macro=(mac); ag_abend_at((ag_text_strtable+2956));2931' 'def_ctdef_list2956gather_assigned_valuepDL->pzExpr"macro arg expr""quoted string"count_named_valuescurrent_tpl=(pT); cur_macro=(mac); AG_ABEND((ag_text_strtable+6644));current_tpl=(pT); cur_macro=(mac); ag_abend_at((ag_text_strtable+6644));pzScan+168216644link_twinsorder_def_listpDL1pDL2def_list_ttCmpProc/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/funcDef.c *//*
     *  Adjust the sizes.  Remove absolute pointers.  Reallocate to the correct
     *  size.  Restore the offsets to pointer values.
     *//*
     *  IF this is the first time here, THEN set up the "DEFINE" block
     *  callout table.  It is the standard table, except entries are
     *  inserted for functions that are enabled only while processing
     *  a DEFINE block (viz. "ENDDEF" and removing "DEFINE").
     *//**
     *  Save the global macro loading mode
     *//*
     *  IF there are empty macro slots,
     *  THEN pack the text
     *//*
     *  Make sure all of the input string was *NOT* scanned.
     *//*
     *  Allocate a new template block that is much larger than needed.
     *//**
 * Loads the debug function for load time breakpoints.
 * @param pT     containing template
 * @param pMac   the debug macro data
 * @param ppzSan pointer to scanning pointer
 * @returns      the next open macro slot
 *//*
     *  Call `eval' to determine the macro name.  Every invocation
     *  may be different!!
     *//*
         *  IF the name is constant and not an expression,
         *  THEN go find the template now and bind the macro call
         *       to a particular template macro
         *//*
     *  IF this is the first time through,
     *  THEN separate the name from the rest of the arguments.
     *//*=macfunc INVOKE
 *
 *  handler_proc:
 *  what:  Invoke a User Defined Macro
 *
 *  desc:
 *
 *  User defined macros may be invoked explicitly or implicitly.
 *  If you invoke one implicitly, the macro must begin with the
 *  name of the defined macro.  Consequently, this may @strong{not}
 *  be a computed value.  If you explicitly invoke a user defined macro,
 *  the macro begins with the macro name @code{INVOKE} followed by
 *  a @i{basic expression} that must yield a known user defined macro.
 *  A macro name _must_ be found, or AutoGen will issue a diagnostic
 *  and exit.
 *
 *  Arguments are passed to the invoked macro by name.
 *  The text following the macro name must consist of a series of
 *  names each of which is followed by an equal sign (@code{=}) and
 *  a @i{basic expression} that yields a string.
 *
 *  The string values may contain template macros that are parsed
 *  the first time the macro is processed and evaluated again every
 *  time the macro is evaluated.
=*//**
 * unload a defined macro
 *
 * @param[in,out] mac macro containing the data to unload
 *//*
     *  IF we have no special definitions, then do not nest definitions
     *//**
 *  This routine runs the invocation of a defined macro.
 *
 * @param tpl not used
 * @param[in] mac the macro that holds the data for the defined macro
 *//*=macfunc ENDDEF
 *
 *  what:   Ends a macro definition.
 *  in-context:
 *
 *  desc:
 *    This macro ends the @code{DEFINE} function template block.
 *    For a complete description @xref{DEFINE}.
=*//*=macfunc DEFINE
 *
 *  what:    Define a user AutoGen macro
 *  cindex:  define macro
 *  handler_proc:
 *  load_proc:
 *  unload-proc:
 *
 *  desc:
 *
 *  This function will define a new macro.  You must provide a name for the
 *  macro.  You do not specify any arguments, though the invocation may
 *  specify a set of name/value pairs that are to be active during the
 *  processing of the macro.
 *
 *  @example
 *  [+ define foo +]
 *  ... macro body with macro functions ...
 *  [+ enddef +]
 *  ... [+ foo bar='raw text' baz=<<text expression>> +]
 *  @end example
 *
 *  Once the macro has been defined, this new macro can be invoked by
 *  specifying the macro name as the first token after the start macro marker.
 *  Alternatively, you may make the invocation explicitly invoke a defined
 *  macro by specifying @code{INVOKE} (@pxref{INVOKE}) in the macro
 *  invocation.  If you do that, the macro name can be computed with an
 *  expression that gets evaluated every time the INVOKE macro is encountered.
 *
 *  Any remaining text in the macro invocation will be used to create new
 *  name/value pairs that only persist for the duration of the processing of
 *  the macro.  The expressions are evaluated the same way basic
 *  expressions are evaluated.  @xref{expression syntax}.
 *
 *  The resulting definitions are handled much like regular
 *  definitions, except:
 *
 *  @enumerate
 *  @item
 *  The values may not be compound.  That is, they may not contain
 *  nested name/value pairs.
 *  @item
 *  The bindings go away when the macro is complete.
 *  @item
 *  The name/value pairs are separated by whitespace instead of
 *  semi-colons.
 *  @item
 *  Sequences of strings are not concatenated.
 *  @end enumerate
 *
 *  @quotation
 *  @strong{NB:} The macro is extracted from the template as the template is
 *  scanned.  You cannot conditionally define a macro by enclosing it in an
 *  @code{IF}/@code{ENDIF} (@pxref{IF}) macro pair.  If you need to dynamically
 *  select the format of a @code{DEFINE}d macro, then put the flavors into
 *  separate template files that simply define macros.  @code{INCLUDE}
 *  (@pxref{INCLUDE}) the appropriate template when you have computed which
 *  you need.
 *  @end quotation
 *
 *  Due to this, it is acceptable and even a good idea to place all the
 *  @code{DEFINE} macros at the end of the template.  That puts the main
 *  body of the template at the beginning of the file.
=*//*
             *  It is a scheme expression.  Accept only string
             *  and number results.
             *//*
     *  FOR each definition, evaluate the associated expression
     *      and set the text value to it.
     *//**
 *  Build up a definition context.
 *  It is created by passed-in macro arguments.
 *
 * @param def_ct    number of definitions
 * @param def_list  list of definitions
 *//*
     *  The case element values were chosen to thwart most
     *  optimizers that might be too bright for its own good.
     *  (`dummy' is write-only and could be ignored)
     *//*=macfunc DEBUG
 *
 *  handler-proc:
 *  load-proc:
 *
 *  what:  Print debug message to trace output
 *  desc:
 *
 *      If the tracing level is at "debug-message" or above
 *      (@pxref{autogen trace}), this macro prints a debug message to trace
 *      output.  This message is not evaluated.  This macro can also be used to
 *      set useful debugger breakpoints.  By inserting [+DEBUG n+] into your
 *      template, you can set a debugger breakpoint on the #n case element
 *      below (in the AutoGen source) and step through the processing of
 *      interesting parts of your template.
 *
 *      To be useful, you have to have access to the source tree where autogen
 *      was built and the template being processed.  The definitions are also
 *      helpful, but not crucial.  Please contact the author if you think you
 *      might actually want to use this.
=*//*
     *  OTHERWISE, skip to the start of the text and process
     *  the arguments to the macro
     *//*
     *  IF there is no more text,
     *  THEN there are no arguments
     *//**
 * prepare the args for INVOKE macro.
 * See if there's any text following the name of the DEFINE macro to invoke.
 * If there is, then set up the arguments now so it's easy to deal with
 * next time around.  The name of the macro to invoke may be dynamic.
 * "skip_expr" skips over either a name or a scheme expression that
 * is supposed to yield a name.
 *
 * @param mac  the macro structure describing the invocation
 *//* pN is now invalid *//*
             *  IF the next entry has the same name,
             *  THEN it is a "twin".  Link twins on the twin list.
             *//*
         *  Now, link them all together.  Singly linked list.
         *//*
         *  There was more than one value assignment.
         *  Sort them just so we know the siblings are together.
         *  Order is preserved by comparing string addresses,
         *  if the strings compare equal.
         *//*
     *  Fill in the array of value assignments
     *//*
     *  Allocate the array of definition descriptors
     *//*
     *  The result is zero if we don't have any
     *//*
     *  If there is no argument text, then the arg count is zero.
     *//*
 *  parse_mac_args
 *
 *  This routine is called just before the first call to mFunc_Define
 *  for a particular macro invocation.  It scans the text of the invocation
 *  for name-value assignments that are only to live for the duration
 *  of the processing of the user defined macro.
 *//*
         *  Terminate the string value and skip over any additional space
         *//*
         *  IF the next char is NUL, we are done.
         *  OTHERWISE, the next character must be a space
         *//*
         *  When we arrive here, we have just clobbered a '=' char.
         *  Now we have gather up the assigned value.
         *//*
             *  The name was separated by space, but has no value
             *//*
         *  Default:  the raw sequence of characters is the value
         *//*
         *  Process the quoted strings now
         *//*
         *  Process the quoted string, but leave a '`' marker, too
         *//*
         *  These expressions will need evaluation
         *//*
     *  Figure out what kind of expression we have
     *//* If ct is zero, then this is invalid *//* in case ct == 0      *//* NULL terminated list *//*
         *  We have found another twin.  Link it in and advance
         *//* count each successive twin   *//* We return this, valid or not *//*
     *  IF the names are the same, then we order them based on which name
     *  appears first.  Do not reorder entries with the same name.
     *//**
 * @file funcDef.c
 *
 *  This module implements the DEFINE text function.
 *
 * @addtogroup autogen
 * @{
 */pNextpCt/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/funcEval.csrc_lenend_srccurrent_tpl=(tpl); cur_macro=(mac); AG_ABEND((ag_text_strtable+4286));current_tpl=(tpl); cur_macro=(mac); ag_abend_at((ag_text_strtable+4286));4286512'%'2048205020512049remLencurrent_tpl=(tpl); cur_macro=(mac); AG_ABEND((ag_text_strtable+4422));current_tpl=(tpl); cur_macro=(mac); ag_abend_at((ag_text_strtable+4422));4422current_tpl=(tpl); cur_macro=(mac); AG_ABEND((ag_text_strtable+4501));current_tpl=(tpl); cur_macro=(mac); ag_abend_at((ag_text_strtable+4501));current_tpl=(tpl); cur_macro=(mac); AG_ABEND((ag_text_strtable+4446));current_tpl=(tpl); cur_macro=(mac); ag_abend_at((ag_text_strtable+4446));*pzNextExprcurrent_tpl=(tpl); cur_macro=(mac); AG_ABEND((ag_text_strtable+4472));current_tpl=(tpl); cur_macro=(mac); ag_abend_at((ag_text_strtable+4472));pzNextExpr450144464472expr_typeallocated_strcur_fpstack->stk_fppzTemp"shell script"(char *)expraprf(EMIT_INVAL_PORT, AG_SCM_TO_ULONG(val))aprf((ag_text_strtable+2163), ((unsigned long)scm_to_uint64(val)))(((((9)) << 8) + scm_tc8_flag))(9)pSaveFppnum216323042308(val)((SCM) ((((((1)) << 8) + scm_tc8_flag))))((SCM) ((((((3)) << 8) + scm_tc8_flag))))(((((1)) << 8) + scm_tc8_flag))(((((3)) << 8) + scm_tc8_flag))SCM_CELL_OBJECT_0 (val)((((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((val)))): ((val))))))) [(0)]))((val))SCM_GC_CELL_OBJECT (((val)), (0))(((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((val)))): ((val))))))) [(0)])SCM_CELL_OBJECT_1 (val)((((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((val)))): ((val))))))) [(1)]))SCM_GC_CELL_OBJECT (((val)), (1))(((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((val)))): ((val))))))) [(1)])26076877218446744073709551103emit val"emit val"emit_insertion_filetxtENOENTloading"loading"outfp"fputs""fflush"(char *)ag_scm2zchars(val, "emit val")scm2display(val)12308codeentcurrent_tpl=(tpl); cur_macro=(mac); AG_ABEND((ag_text_strtable+2279));current_tpl=(tpl); cur_macro=(mac); ag_abend_at((ag_text_strtable+2279));(EMIT_IF_ABSENT | EMIT_ALWAYS)11222792231ent != NULLent != ((void *)0)funcEval.c261__PRETTY_FUNCTION__tpl_warning14647tpl_textchar[48](s)((SCM) ((((((0)) << 8) + scm_tc8_flag))))18446744073709551359'1'SCM Result78817832sizeof(z)** PROCEDURE **"** PROCEDURE **"7821780777957867SCM_SUBR_ENTRY/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/funcEval.c *//*
             *  NUL terminate the first expression, skip intervening
             *  white space and put the secondary expression's type
             *  into the macro type code as the "secondary type".
             *//*
             *  The next expression must be within bounds and space separated
             *//*
         *  IF this expression has an "if-present" and "if-not-present"
         *  THEN find the ending expression...
         *//* double terminate *//*
         *  Copy the expression
         *//* zero *//* macro text *//* next text dest   *//**
 *  mLoad_Expr
 *//**
 * Determine the expression type.  It may be Scheme (starts with a semi-colon
 * or an opening parenthesis), a shell command (starts with a back tick),
 * a quoted string (either single or double), or it is some sort of plain
 * string.  In that case, just return the text.
 *
 * @param pz pointer to string to diagnose
 * @returns the EMIT_* compound value, though actually only
 * EXPRESSION, SHELL or STRING can really ever be returned.
 *//*=macfunc EXPR
 *
 *  what:  Evaluate and emit an Expression
 *  alias: + - + ? + % + ; + ( + '`' + '"' + "'" + . + { +
 *
 *  handler_proc:
 *  load_proc:
 *
 *  desc:
 *   This macro does not have a name to cause it to be invoked
 *   explicitly, though if a macro starts with one of the apply codes
 *   or one of the simple expression markers, then an expression
 *   macro is inferred.  The result of the expression evaluation
 *   (@pxref{expression syntax}) is written to the current output.
=*//**
 *  The global evaluation function.
 *
 *  The string to "evaluate" may be a literal string, or may need Scheme
 *  interpretation.  So, we do one of three things: if the string starts with
 *  a Scheme comment character or evaluation character (';' or '('), then run
 *  a Scheme eval.  If it starts with a quote character ('\'' or '"'), then
 *  digest the string and return that.  Otherwise, just return the string.
 *
 * @param expr input expression string
 * @returns an SCM value representing the result
 */// initialize the first time through/*=gfunc insert_file
 *
 * what: insert the contents of a (list of) files.
 *
 * exparg: alist, list of files to emit, , list
 *
 * doc:  Insert the contents of one or more files.
=*//**
 * read in a file and write it to the passed in file pointer.
 *
 * @param [in]  fname  the name of the file to read
 * @param [in]  outfp  the file pointer to write the data to.
 *//*=gfunc emit
 *
 * what: emit the text for each argument
 *
 * exparg: alist, list of arguments to stringify and emit, , list
 *
 * doc:  Walk the tree of arguments, displaying the values of displayable
 *       SCM types.  EXCEPTION: if the first argument is a number, then
 *       that number is used to index the output stack.  "0" is the default,
 *       the current output.
=*//*=gfunc error_source_line
 *
 * what: display of file & line
 * general_use:
 * doc:  This function is only invoked just before Guile displays
 *       an error message.  It displays the file name and line number
 *       that triggered the evaluation error.  You should not need to
 *       invoke this routine directly.  Guile will do it automatically.
=*//*
     *  The "code" tells us how to handle the expression
     *//*
                 *  And make sure what we found is a text value
                 *//*
             *  Compute the expression string.  There are three possibilities:
             *  1.  There is an expression string in the macro, but it must
             *      be formatted with the text value.
             *      Make sure we have a value.
             *  2.  There is an expression string in the macro, but it is *NOT*
             *      to be formatted.  Use it as is.  Do *NOT* verify that
             *      the define value is text.
             *  3.  There is no expression with the macro invocation.
             *      The define value *must* be text.
             *//*
         *  OTHERWISE, we found an entry.  Make sure we were supposed to.
         *//*
                 *  Emit inconsistently :-}
                 *//*
                 *  Emit only if found
                 *//*
                 *  There are two expressions.  Take the second one.
                 *//*
                 *  There is only one expression.  It applies because
                 *  we did not find a definition.
                 *//*
         *  Get the named definition entry, maybe
         *//* warning patrol *//**
 *  Evaluate an expression and return a string pointer.  Always.
 *  It may need to be deallocated, so a boolean pointer is used
 *  to tell the caller.  Also, the match existence and non-existence
 *  pay attention to the address of the empty string that gets
 *  returned.  If it is, specifically, "zNil", then this code is
 *  saying, "we could not compute a value, so we're returning this
 *  empty string".  This is used by the Select_Match_Existence and
 *  Select_Match_NonExistence code to distinguish non-existence from
 *  an empty string value.
 *
 * @param allocated tell caller if result has been allocated
 * @returns a string representing the result.
 *//**
 * Return the text associated with a macro.
 *//**
 * Convert SCM to displayable string.
 * @param s the input scm
 * @returns a string a human can read
 *//**
 * @file funcEval.c
 *
 *  This module evaluates macro expressions.
 *
 * @addtogroup autogen
 * @{
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/funcFor.cscan_outscan_inin_lenload_for_macro_procscurrent_tpl=(tpl); cur_macro=(mac); AG_ABEND((ag_text_strtable+4253));current_tpl=(tpl); cur_macro=(mac); ag_abend_at((ag_text_strtable+4253));4253*scan_incurrent_tpl=(tpl); cur_macro=(mac); AG_ABEND((ag_text_strtable+4530));current_tpl=(tpl); cur_macro=(mac); ag_abend_at((ag_text_strtable+4530));4530scan_in[2]*scan_out45274096next_maccurrent_tpl=(tpl); cur_macro=(mac); AG_ABEND((ag_text_strtable+4556));current_tpl=(tpl); cur_macro=(mac); ag_abend_at((ag_text_strtable+4556));4556for_state->for_sep_strcurr_ivk_info->ii_for_datanew_for_context"Init FOR sate"dta"FOR state"sizeof(for_state_t)ret_macdeflp_ct1498714949tpl->td_text + mac->md_txt_off"ss"2074938285UNASSIGNED14892load_for_inpzNameixprev_entpzSrc + 3current_tpl=(pT); cur_macro=(pMac); AG_ABEND((ag_text_strtable+3305));current_tpl=(pT); cur_macro=(pMac); ag_abend_at((ag_text_strtable+3305));3305nmlensrcLen + 2 + nmlen"copy FOR text"pDeffor_eachloopCttxt_def_ent3337each"each"yes"yes"no"no"leave_loopfor_by_stepinvertloop_limLOOP_LIMITnext_ixtextDef1533315270by-step"by-step"set_loop_limitldedef_entfoundnext_defmatchedag_scm2zchars(obj, "sep")"seps"byfind_for_statesrchwhich_scmwhich for"which for"fs0x7BAD0BADENTRY_ENDINT_MAX/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/funcFor.c *//*
     * * * * *//* * * * *
     *
     *  *EITHER* a:  FOR foo "<<separator>>"
     *  *OR*         FOR foo (scheme ...) ...
     *//* * * * *
     *
     *  FOR foo IN ...  -> no text, but we create an array of text values
     *//* * * * *
     *
     *  No source -> zero offset to text
     *//*
     *  Skip space to the start of the text following the iterator name
     *//* force an error *//*
     *  src points to the name of the iteration "variable"
     *  Special hack:  if the name is preceded by a `.',
     *  then the lookup is local-only and we will accept it.
     *//*
     *  IF this is the first time here, THEN set up the "FOR" mode callout
     *  table.  It is the standard table, except entries are inserted for
     *  functions that are enabled only while processing a FOR macro
     *//**
 * Function to initiate loading of FOR block.
 * It must replace the dispatch table to handle the ENDFOR function,
 * which will unload the dispatch table.
 *//**
 * Free up for loop contexts.
 * @param [in] pop_ct  the maximum number to free up
 *//*
     *  Push the current FOR context onto a stack.
     *//**
 * allocate and zero out a FOR macro context.
 *
 * @returns the top of thecurr_ivk_info stack of contexts.
 *//*
         *  The FOR iterates over a list of definitions
         *//*
     *  Check for a FOR iterating based on scheme macros
     *//*
     *  "md_pvt" is used by the "FOR x IN ..." variation of the macro.
     *  When parsed, a chain of text definitions are hung off of "md_pvt".
     *  "for_each()" will then chase through the linked list of text
     *  values.  This winds up being identical to [+ FOR var +] where
     *  a list of "var" values has been set.
     *//*=macfunc ENDFOR
 *
 *  what:   Terminates the @code{FOR} function template block
 *  in-context:
 *
 *  desc:
 *    This macro ends the @code{FOR} function template block.
 *    For a complete description @xref{FOR}.
=*//*=macfunc FOR
 *
 *  what:    Emit a template block multiple times
 *  cindex:  looping, for
 *  cindex:  for loop
 *  handler_proc:
 *  load_proc:
 *
 *  desc:
 *  This macro has a slight variation on the standard syntax:
 *  @example
 *  FOR <value-name> [ <separator-string> ]
 *
 *  FOR <value-name> (...Scheme expression list)
 *
 *  FOR <value-name> IN "string" [ ... ]
 *  @end example
 *
 *  Other than for the last form, the first macro argument must be the name of
 *  an AutoGen value.  If there is no value associated with the name, the
 *  @code{FOR} template block is skipped entirely.  The scope of the @code{FOR}
 *  macro extends to the corresponding @code{ENDFOR} macro.  The last form will
 *  create an array of string values named @code{<value-name>} that only exists
 *  within the context of this @code{FOR} loop.  With this form, in order to
 *  use a @code{separator-string}, you must code it into the end of the
 *  template block using the @code{(last-for?)} predicate function
 *  (@pxref{SCM last-for?}).
 *
 *  If there are any arguments after the @code{value-name}, the initial
 *  characters are used to determine the form.  If the first character is
 *  either a semi-colon (@code{;}) or an opening parenthesis (@code{(}), then
 *  it is presumed to be a Scheme expression containing the FOR macro specific
 *  functions @code{for-from}, @code{for-by}, @code{for-to}, and/or
 *  @code{for-sep}.  @xref{AutoGen Functions}.  If it consists of an '@code{i}'
 *  an '@code{n}' and separated by white space from more text, then the
 *  @code{FOR x IN} form is processed.  Otherwise, the remaining text is
 *  presumed to be a string for inserting between each iteration of the loop.
 *  This string will be emitted one time less than the number of iterations of
 *  the loop.  That is, it is emitted after each loop, excepting for the last
 *  iteration.
 *
 *  If the from/by/to functions are invoked, they will specify which copies of
 *  the named value are to be processed.  If there is no copy of the named
 *  value associated with a particular index, the @code{FOR} template block
 *  will be instantiated anyway.  The template must use @code{found-for?}
 *  (@pxref{SCM found-for?}) or other methods for detecting missing
 *  definitions and emitting default text.  In this fashion, you can insert
 *  entries from a sparse or non-zero based array into a dense, zero based
 *  array.
 *
 *  @strong{NB:} the @code{for-from}, @code{for-to}, @code{for-by} and
 *  @code{for-sep} functions are disabled outside of the context of the
 *  @code{FOR} macro.  Likewise, the @code{first-for?}, @code{last-for?}
 *  @code{for-index}, and @code{found-for?} functions are disabled outside
 *  of the range of a @code{FOR} block.
 *
 *  @strong{Also:} the @code{<value-name>} must be a single level name,
 *  not a compound name (@pxref{naming values}).
 *
 *  @example
 *  [+FOR var (for-from 0) (for-to <number>) (for-sep ",") +]
 *  ... text with @code{var}ious substitutions ...[+
 *  ENDFOR var+]
 *  @end example
 *
 *  @noindent
 *  this will repeat the @code{... text with @code{var}ious
 *  substitutions ...} <number>+1 times.  Each repetition,
 *  except for the last, will have a comma @code{,} after it.
 *
 *  @example
 *  [+FOR var ",\n" +]
 *  ... text with @code{var}ious substitutions ...[+
 *  ENDFOR var +]
 *  @end example
 *
 *  @noindent
 *  This will do the same thing, but only for the index
 *  values of @code{var} that have actually been defined.
=*//*
         *  IF there is a previous entry, link its twin to this one.
         *  OTHERWISE, it is the head of the twin list.
         *  Link to md_pvt.
         *//*
         *  Clean up trailing white space
         *//*
             *  Clean up trailing commas
             *//*
     *  Find the first text value
     *//*
         *  Emit the iteration separation
         *//*
         *  Advance to the next twin
         *//*
         *  Set the global current index
         *//*
         *  IF this loops over a text macro,
         *  THEN create a definition that will be found *before*
         *       the repeated (twinned) copy.  That way, when it
         *       is found as a macro invocation, the current value
         *       will be extracted, instead of the value list.
         *//*
         *  ELSE the current definitions are based on the block
         *       macro's values
         *//*
         *  ELSE IF this macro is a text type
         *  THEN create an un-twinned version of it to be found first
         *//*
         *  IF we have a non-base definition, use the old def context
         *//* last iteration !! *//*
     *  FROM `from' THROUGH `to' BY `by',
     *  DO...
     *//*
     *  Make sure we have some work to do before we start.
     *//*
     *  "loop limit" is intended to catch runaway ending conditions.
     *  However, if you really have a gazillion entries, who am I
     *  to stop you?
     *//**
 *  IF the for-from and for-to values have not been set,
 *  THEN we set them from the indices of the first and last
 *       entries of the twin set.
 *//*
     *  Save our restart point and return the find indication
     *//*
         *  The current index (for_state->for_index) is past the current value
         *  (pB->de_index), so advance to the next entry and test again.
         *//*
             *  When the "by" step is zero, force syncronization.
             *//*
         *  IF the next definition is beyond our current index,
         *       (that is, the current index is inside of a gap),
         *  THEN we have no current definition and will use
         *       only the set passed in.
         *//*
         *  Loop until we find or pass the current index value
         *
         *  IF we found an entry for the current index,
         *  THEN break out and use it
         *//**
 * search for matching definition entry.
 * Only the current level is traversed, via the "de_twin" link.
 *
 * @param[in] invert  invert the sense of the search
 *                    ("FOR" is running backwards)
 * @param[in,out] de_lst  linked list of definitions
 *//*=gfunc for_sep
 *
 * what:   set loop separation string
 * exparg: separator, the text to insert between the output of
 *         each FOR iteration
 *
 * doc:  This function records the separation string that is to be inserted
 *       between each iteration of an AutoGen FOR function.  This is often
 *       nothing more than a comma.
 *       Outside of the FOR macro itself, this function will emit an error.
=*//*=gfunc for_by
 *
 * what:   set iteration step
 * exparg: by, the iteration increment for the AutoGen FOR macro
 *
 * doc:  This function records the "step by" information
 *       for an AutoGen FOR function.
 *       Outside of the FOR macro itself, this function will emit an error.
 *       @xref{FOR}.
=*//*=gfunc for_to
 *
 * what:   set ending index
 * exparg: to, the final index for the AutoGen FOR macro
 *
 * doc:  This function records the terminating value information
 *       for an AutoGen FOR function.
 *       Outside of the FOR macro itself, this function will emit an error.
 *       @xref{FOR}.
=*//*=gfunc for_from
 *
 * what:   set initial index
 * exparg: from, the initial index for the AutoGen FOR macro
 *
 * doc:  This function records the initial index information
 *       for an AutoGen FOR function.
 *       Outside of the FOR macro itself, this function will emit an error.
 *       @xref{FOR}.
=*//*=gfunc for_index
 *
 * what:    get current loop index
 * exparg:  for_var, which for loop, opt
 * doc:
 *
 *    Returns the current index for the named @code{FOR} loop.
 *    If not named, then the index for the innermost loop.
 *    Outside of any FOR loop, it returns @code{SCM_UNDEFINED}, @xref{FOR}.
=*//*=gfunc found_for_p
 *
 * what:    is current index in list?
 * exparg:  for_var, which for loop, opt
 * doc:
 *  Returns SCM_BOOL_T if the currently indexed value is present,
 *  otherwise SCM_BOOL_F.  Outside of any FOR loop, it returns
 *  SCM_UNDEFINED. @xref{FOR}.
=*//*=gfunc last_for_p
 *
 * what:    detect last iteration
 * exparg:  for_var, which for loop, opt
 * doc:     Returns SCM_BOOL_T if the named FOR loop (or, if not named, the
 *          current innermost loop) is on the last pass through the data.
 *          Outside of any FOR loop, it returns SCM_UNDEFINED.
 *          @xref{FOR}.
=*//*=gfunc first_for_p
 *
 * what:    detect first iteration
 * exparg:  for_var, which for loop, opt
 * doc:
 *
 *    Returns @code{SCM_BOOL_T} if the named FOR loop (or, if not named, the
 *    current innermost loop) is on the first pass through the data.  Outside
 *    of any @code{FOR} loop, it returns @code{SCM_UNDEFINED}, @pxref{FOR}.
=*//*
         * If "which" is not specified, then accept first found
         *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Operational Functions *//**
 * @file funcFor.c
 *
 *  This module implements the FOR text macro.
 *
 * @addtogroup autogen
 * @{
 */de_lst/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/funcIf.cWRITABLEset(set)((SCM) ((((((4)) << 8) + scm_tc8_flag))))DESC(WRITABLE).fOptState &= OPTST_PERSISTENT_MASK; if ((DESC(WRITABLE).fOptState & OPTST_INITENABLED) == 0) DESC(WRITABLE).fOptState |= OPTST_DISABLED; DESC(WRITABLE).optCookie = NULL(autogenOptions.pOptDesc[INDEX_OPT_WRITABLE]).fOptState &= 0xFFFFF00U; if (((autogenOptions.pOptDesc[INDEX_OPT_WRITABLE]).fOptState & 0x0000800U) == 0) (autogenOptions.pOptDesc[INDEX_OPT_WRITABLE]).fOptState |= 0x0000020U; (autogenOptions.pOptDesc[INDEX_OPT_WRITABLE]).optCookie = ((void *)0)DESC(WRITABLE).optActualIndex = 11; DESC(WRITABLE).optActualValue = VALUE_OPT_WRITABLE; DESC(WRITABLE).fOptState &= OPTST_PERSISTENT_MASK; DESC(WRITABLE).fOptState |= OPTST_SET(autogenOptions.pOptDesc[INDEX_OPT_WRITABLE]).optActualIndex = 11; (autogenOptions.pOptDesc[INDEX_OPT_WRITABLE]).optActualValue = 0x1005; (autogenOptions.pOptDesc[INDEX_OPT_WRITABLE]).fOptState &= 0xFFFFF00U; (autogenOptions.pOptDesc[INDEX_OPT_WRITABLE]).fOptState |= 0x0000001UOPTST_DEFINEDOPTST_PRESET126231280184467440737095503352684352004101while_tbllptcurrent_tpl=(pT); cur_macro=(mac); AG_ABEND((ag_text_strtable+4683));current_tpl=(pT); cur_macro=(mac); ag_abend_at((ag_text_strtable+4683));4683current_tpl=(pT); cur_macro=(mac); AG_ABEND((ag_text_strtable+4664));current_tpl=(pT); cur_macro=(mac); ag_abend_at((ag_text_strtable+4664));4664pEndifMacapIfLoadcurrent_tpl=(tpl); cur_macro=(mac); AG_ABEND((ag_text_strtable+6717));current_tpl=(tpl); cur_macro=(mac); ag_abend_at((ag_text_strtable+6717));6717current_tpl=(tpl); cur_macro=(mac); AG_ABEND((ag_text_strtable+4573));current_tpl=(tpl); cur_macro=(mac); ag_abend_at((ag_text_strtable+4573));4573mLoad_Elseload_for_if_after_else_procsmLoad_Elifcurrent_tpl=(pT); cur_macro=(pMac); AG_ABEND((ag_text_strtable+6717));current_tpl=(pT); cur_macro=(pMac); ag_abend_at((ag_text_strtable+6717));1522815197pRetpIf15030329315074eval_trueneedFree102'f''F'2359tIfStackif_stackpElsecurrent_if/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/funcIf.c *//*=gfunc set_writable
 *
 * what:   Make the output file be writable
 *
 * exparg: + set? + boolean arg, false to make output non-writable + opt
 *
 * doc:    This function will set the current output file to be writable
 *         (or not).  This is only effective if neither the @code{--writable}
 *         nor @code{--not-writable} have been specified.  This state
 *         is reset when the current suffix's output is complete.
=*/// restore context/*
     *  Now, do a nested parse of the template.  When the matching 'ENDWHILE'
     *  macro is encountered, the handler routine will cause 'parse_tpl()'
     *  to return with the text scanning pointer pointing to the remaining
     *  text.
     *///!< save current table/*
     *  While processing a "WHILE" macro,
     *  we have handler a handler function for ENDWHILE, NEXT and BREAK.
     *//**
 * load the @code{WHILE} macro.  Sets up the while loop parsing table, which
 * is a copy of the global "base_load_table" with added entries for
 * @code{ENDWHILE}, @code{NEXT} and @code{BREAK}.
 *
 *  @param[in,out] tpl   Template we are filling in with macros
 *  @param[in,out] mac   Linked into the "if" macro segments
 *  @param[in,out] scan  pointer to scanning pointer.  We advance it
 *                       past the ending @code{ENDWHILE} macro.
 *
 *  @returns the address of the next macro slot for insertion.
 *//*
     *  Restore the context of any encompassing block macros
     *//*
     *  Now, do a nested parse of the template.
     *  When the matching 'ENDIF' macro is encountered,
     *  the handler routine will cause 'parse_tpl()'
     *  to return with the text scanning pointer pointing
     *  to the remaining text.
     *//*
     *  We will need to chain together the 'IF', 'ELIF', and 'ELSE'
     *  macros.  The 'ENDIF' gets absorbed.
     *//*
     *  While processing an "IF" macro,
     *  we have handler functions for 'ELIF', 'ELSE' and 'ENDIF'
     *  Otherwise, we do not.  Switch the callout function table.
     *//**
 * Load template macros until matching @code{ENDIF} is found.
 *
 *  @param[in,out] tpl   Template we are filling in with macros
 *  @param[in,out] mac   Linked into the "if" macro segments
 *  @param[in,out] scan  pointer to scanning pointer.  We advance it
 *                       past the ending @code{ENDIF} macro.
 *
 *  @returns the address of the next macro slot for insertion.
 *//**
 *  End any of the block macros.  It ends @code{ENDDEF},
 *  @code{ENDFOR}, @code{ENDIF}, @code{ENDWHILE} and @code{ESAC}.  It
 *  leaves no entry in the dispatch tables for itself.  By returning
 *  NULL, it tells the macro parsing loop to return.
 *
 *  @param      tpl   ignored
 *  @param[out] mac   zeroed out for re-use
 *  @param      scan  ignored
 *//*
     *  After processing an "ELSE" macro,
     *  we have a special handler function for 'ENDIF' only.
     *//*=macfunc ELSE
 *
 *  what:   Alternate Template Block
 *  in-context:
 *
 *  desc:
 *    This macro must only appear after an @code{IF} function,
 *    and before the associated @code{ENDIF} function.
 *    It denotes the start of an alternate template block for
 *    the @code{IF} function.  For a complete description @xref{IF}.
=*//*=macfunc ELIF
 *
 *  what:   Alternate Conditional Template Block
 *  in-context:
 *
 *  desc:
 *    This macro must only appear after an @code{IF} function, and
 *    before any associated @code{ELSE} or @code{ENDIF} functions.
 *    It denotes the start of an alternate template block for the
 *    @code{IF} function.  Its expression argument is evaluated as are
 *    the arguments to @code{IF}.  For a complete description @xref{IF}.
=*//*=macfunc ENDWHILE
 *
 *  what:   Terminate the @code{WHILE} Template Block
 *  in-context:
 *
 *  desc:
 *    This macro ends the @code{WHILE} function template block.
 *    For a complete description @xref{WHILE}.
=*//*=macfunc WHILE
 *
 *  what:    Conditionally loop over a Template Block
 *  cindex:  conditional emit
 *  cindex:  while test
 *  handler_proc:
 *  load_proc:
 *
 *  desc:
 *  Conditionally repeated block.  Its arguments are evaluated (@pxref{EXPR})
 *  and as long as the result is non-zero or a string with one or more bytes,
 *  then the condition is true and the text from that point
 *  until a matched @code{ENDWHILE} is emitted.
 *
 *  @example
 *  [+WHILE <full-expression> +]
 *  emit things that are for the true condition[+
 *
 *  ENDWHILE +]
 *  @end example
 *
 *  @noindent
 *  @code{<full-expression>} may be any expression described in the
 *  @code{EXPR} expression function, including the use of apply-codes
 *  and value-names.  If the expression yields an empty string, it
 *  is interpreted as @i{false}.
=*//*
         *  'ELSE' is equivalent to 'ELIF true'
         *//*
         *  The current macro becomes the 'ELIF' or 'ELSE' macro
         *//*=macfunc ENDIF
 *
 *  what:   Terminate the @code{IF} Template Block
 *  in-context:
 *
 *  desc:
 *    This macro ends the @code{IF} function template block.
 *    For a complete description @xref{IF}.
=*//*=macfunc IF
 *
 *  what:    Conditionally Emit a Template Block
 *  cindex:  conditional emit
 *  cindex:  if test
 *  handler_proc:
 *  load_proc:
 *
 *  desc:
 *  Conditional block.  Its arguments are evaluated (@pxref{EXPR}) and
 *  if the result is non-zero or a string with one or more bytes,
 *  then the condition is true and the text from that point
 *  until a matched @code{ELIF}, @code{ELSE} or @code{ENDIF} is emitted.
 *  @code{ELIF} introduces a conditional alternative if the @code{IF}
 *  clause evaluated FALSE and @code{ELSE} introduces an unconditional
 *  alternative.
 *
 *  @example
 *  [+IF <full-expression> +]
 *  emit things that are for the true condition[+
 *
 *  ELIF <full-expression-2> +]
 *  emit things that are true maybe[+
 *
 *  ELSE "This may be a comment" +]
 *  emit this if all but else fails[+
 *
 *  ENDIF "This may *also* be a comment" +]
 *  @end example
 *
 *  @noindent
 *  @code{<full-expression>} may be any expression described in the
 *  @code{EXPR} expression function, including the use of apply-codes
 *  and value-names.  If the expression yields an empty string, it
 *  is interpreted as @i{false}.
=*//*
 *  eval_true - should a string be interpreted as TRUE?
 *
 *  It is always true unless:
 *
 *  1.  it is the empty string
 *  2.  it starts with a digit and the number evaluates to zero
 *  3.  it starts with either "#f" or "#F"
 *  4.  For its length or its first five characters (whichever is less)
 *      it matches the string "false"
 *//**
 * @file funcIf.c
 *
 *  This module implements the _IF text function.
 *
 * @addtogroup autogen
 * @{
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/functions.cpzMac58':'(size_t)604199current_tpl=(tpl); cur_macro=(mac); AG_ABEND(pzSrc);current_tpl=(tpl); cur_macro=(mac); ag_abend_at(pzSrc);scan[-1]cnamecname_lenrem_lenreturn_emtpy_exprpT->td_text + pMac->md_txt_off32173273current_tpl=(pT); cur_macro=(pMac); AG_ABEND(pz);current_tpl=(pT); cur_macro=(pMac); ag_abend_at(pz);pInv1515615149151441513015868allocated_namepe15108oldtiiii.ii_envcurrent_tpl=(tpl); cur_macro=(mac); AG_ABEND((ag_text_strtable+7894));current_tpl=(tpl); cur_macro=(mac); ag_abend_at((ag_text_strtable+7894));7894fstaprf(BAD_BREAK_FMT, which)aprf((ag_text_strtable+562), which)7881124562/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/functions.c *//**
 *  Some functions are known to AutoGen, but invalid out of context.
 *  For example, ELIF, ELSE and ENDIF are all known to AutoGen.
 *  However, the load function pointer for those functions points
 *  here, until an "IF" function is encountered.
 *
 *  @param tpl     template being loaded
 *  @param mac     the macro descriptor
 *  @param p_scan  the input text scanning pointer
 *
 *  @returns the macro table entry after mac
 *//*
     *  Copy the expression (the remaining text)
     *//*
         *  Where we are stashing text ("td_scan") gets set to just past the
         *  NUL byte terminating the name.  "cname" is now longer than before.
         *//*
         *  Now copy over the full canonical name.  Check for errors.
         *  Advance the scan pointer to just past the name we've copied.
         *//*
         *  Move back the source pointer.  We may have skipped blanks,
         *  so skip over however many first, then back up over the name.
         *  We have found a name, so we won't back up past the start.
         *//*
         *  We are going to recopy the definition name, this time as a
         *  canonical name (i.e. including '[', ']' and '.'  characters,
         *  but with all blanks squeezed out)
         *//*
         *  Strip off scheme comments
         *//**
 *  The default (unknown) load function.
 *
 *  Move any text into the text offset field.  This macro will change to
 *  either INVOKE or an expression function, depending on whether or not a
 *  DEFINE macro corresponds to the name.  This is determined at instantiation
 *  time.  This is used as the default load mechanism.
 *
 *  @param tpl     template being loaded
 *  @param mac     the macro descriptor
 *  @param p_scan  the input text scanning pointer
 *
 *  @returns the macro table entry after mac
 *//*=macfunc COMMENT
 *
 *  what:  A block of comment to be ignored
 *  load_proc:
 *  alias: "#"
 *
 *  desc:
 *    This function can be specified by the user, but there will
 *    never be a situation where it will be invoked at emit time.
 *    The macro is actually removed from the internal representation.
 *
 *    If the native macro name code is @code{#}, then the
 *    entire macro function is treated as a comment and ignored.
 *
 *    @example
 *    [+ # say what you want, but no '+' before any ']' chars +]
 *    @end example
=*//*=macfunc TEXT
 *
 *  what:  A block of text to be emitted.
 *  handler_proc:
 *  unnamed:
=*//*=macfunc BOGUS
 *
 *  what:  Out-of-context or unknown functions are bogus.
 *  handler_proc:
 *  load_proc:
 *  unnamed:
=*//*=macfunc UNKNOWN
 *
 *  what:  Either a user macro or a value name.
 *  handler_proc:
 *  load_proc:
 *  unnamed:
 *
 *  desc:
 *
 *  The macro text has started with a name not known to AutoGen.  If, at run
 *  time, it turns out to be the name of a defined macro, then that macro is
 *  invoked.  If it is not, then it is a conditional expression that is
 *  evaluated only if the name is defined at the time the macro is invoked.
 *
 *  You may not specify @code{UNKNOWN} explicitly.
=*//*
             *  IF there is no text left, remove the macro entirely
             *//*
             *  Strip off trailing white space from included templates
             *//*=macfunc INCLUDE
 *
 *  what:   Read in and emit a template block
 *  handler_proc:
 *  load_proc:    Expr
 *
 *  desc:
 *
 *  The entire contents of the named file is inserted at this point.
 *  The contents of the file are processed for macro expansion.  The
 *  arguments are eval-ed, so you may compute the name of the file to
 *  be included.  The included file must not contain any incomplete
 *  function blocks.  Function blocks are template text beginning with
 *  any of the macro functions @samp{CASE}, @samp{DEFINE}, @samp{FOR},
 *  @samp{IF} and @samp{WHILE}; extending through their respective
 *  terminating macro functions.
=*//*
         * Check returns at load time.  "break" and "continue" at
         * instantiation time.
         *//**
 * Validate the context for leaving early.  @code{FOR} and @code{WHILE} loops
 * may leave an interation early with @code{CONTINUE} or @code{BREAK}.
 * @code{DEFINE}-d macros and @code{INCLUDE}-d files may leave early with
 * @code{RETURN}.  Loops may not be left early from an @code{INVOKE}-d macro
 * or an @code{INCLUDE}-d template.
 *
 * This load function handles @code{BREAK}, @code{CONTINUE} and @code{RETURN}.
 * It is always defined, so it must check for itself whether the
 * context is correct or not.
 *
 *  @param tpl     template being loaded
 *  @param mac     the macro descriptor
 *  @param p_scan  the input text scanning pointer
 *
 *  @returns the macro table entry after mac
 *//**
 * Generate a block with a new template context.  It may be either
 * an @code{INCLUDE}-d template or a user @code{DEFINE}-d macro.
 * If @code{gen_block} returns with a long jump, the long jump value
 * is ignored.  It was terminated early with a @code{RETURN}.
 *
 * @param[in] tpl new template block (included or invoked).
 *//*=macfunc RETURN
 *
 *  handler-proc:
 *  load-proc:      Leave
 *
 *  what:           Leave an INVOKE-d (DEFINE) macro
 *
 *  desc:
 *  This will unwind looping constructs inside of a DEFINE-d macro and
 *  return to the invocation point.  The output files and diversions
 *  @i{are left alone}.  This means it is unwise to start diversions
 *  in a DEFINEd macro and RETURN from it before you have handled the
 *  diversion.  Unless you are careful.  Here is some rope for you.
 *  Please be careful using it.
=*/// 0/**
 * wrapper function for calling gen_block in a loop.
 * It sets up and handles the jump buffer, returning the jump result.
 *
 * @param[in,out] jbuf     the jump buffer
 * @param[in]     tpl      the new active template
 * @param[in]     mac      the looping macro
 * @param[in]     end_mac  pointer to the first macro after the block
 *
 * @returns either LOOP_JMP_OKAY (0) or LOOP_JMP_BREAK (the caller should
 * exit the loop).
 *//*=macfunc BREAK
 *
 *  handler-proc:   Break
 *  load-proc:      Leave
 *  what:           Leave a FOR or WHILE macro
 *
 *  desc:
 *  This will unwind the loop context and resume after ENDFOR/ENDWHILE.
 *  Note that unless this happens to be the last iteration anyway,
 *  the (last-for?) function will never yield "#t".
=*//*=macfunc CONTINUE
 *
 *  handler-proc:   Break
 *  load-proc:      Leave
 *  what:           Skip to end of a FOR or WHILE macro.
 *
 *  desc:
 *  This will skip the remainder of the loop and start the next.
=*//**
 * @file functions.c
 *
 *  This module implements text functions.
 *
 * @addtogroup autogen
 * @{
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/expExtract.c3035char[4097]4097file-name"file-name"find_file(pz, z, (char const **)apz, NULL)find_file(pz, z, (char __const **)apz, ((void *)0))find_file(pz, z, NULL, NULL)find_file(pz, z, ((void *)0), ((void *)0))apzfile suffix"file suffix"markerextr"extr""mark"careful2904caveat"caveat"29902984get_textpzE(size_t)(pzE - pzS)mk_empty_textmlen4704pzDefdft extr str"dft extr str"load_extract_filelast_fnamefile_textsbufsbuf.st_mode(sbuf.st_mode)__S_IFREG0100000stat *stat *__restrict__61440new_fil"extract file"& DESC(WRITABLE)& (autogenOptions.pOptDesc[INDEX_OPT_WRITABLE])"r"fszstbffsz + 1"load_file""fread"/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/expExtract.c *//*
         *  The suffix is optional.  If provided, it will be a string.
         *//*=gfunc find_file
 *
 * what:   locate a file in the search path
 * exparg: file-name,  name of file with text
 * exparg: @suffix  @  file suffix to try, too   @ opt @
 *
 * doc:
 *
 * AutoGen has a search path that it uses to locate template and definition
 * files.  This function will search the same list for @file{file-name}, both
 * with and without the @file{.suffix}, if provided.
=*//*=gfunc extract
 *
 * what:   extract text from another file
 * general_use:
 * exparg: file-name,  name of file with text
 * exparg: marker-fmt, format for marker text
 * exparg: caveat,     warn about changing marker, opt
 * exparg: default,    default initial text,       opt
 *
 * doc:
 *
 * This function is used to help construct output files that may contain
 * text that is carried from one version of the output to the next.
 *
 * The first two arguments are required, the second are optional:
 *
 * @itemize @bullet
 * @item
 *      The @code{file-name} argument is used to name the file that
 *      contains the demarcated text.
 * @item
 *      The @code{marker-fmt} is a formatting string that is used to construct
 *      the starting and ending demarcation strings.  The sprintf function is
 *      given the @code{marker-fmt} with two arguments.  The first is either
 *      "START" or "END".  The second is either "DO NOT CHANGE THIS COMMENT"
 *      or the optional @code{caveat} argument.
 * @item
 *      @code{caveat} is presumed to be absent if it is the empty string
 *      (@code{""}).  If absent, ``DO NOT CHANGE THIS COMMENT'' is used
 *      as the second string argument to the @code{marker-fmt}.
 * @item
 *      When a @code{default} argument is supplied and no pre-existing text
 *      is found, then this text will be inserted between the START and END
 *      markers.
 * @end itemize
 *
 * @noindent
 * The resulting strings are presumed to be unique within
 * the subject file.  As a simplified example:
 *
 * @example
 * [+ (extract "fname" "// %s - SOMETHING - %s" ""
 *             "example default") +]
 * @end example
 * @noindent
 * will result in the following text being inserted into the output:
 *
 * @example
 * // START - SOMETHING - DO NOT CHANGE THIS COMMENT
 * example default
 * // END   - SOMETHING - DO NOT CHANGE THIS COMMENT
 * @end example
 *
 * @noindent
 * The ``@code{example default}'' string can then be carried forward to
 * the next generation of the output, @strong{@i{provided}} the output
 * is not named "@code{fname}" @i{and} the old output is renamed to
 * "@code{fname}" before AutoGen-eration begins.
 *
 * @table @strong
 * @item NB:
 * You can set aside previously generated source files inside the pseudo
 * macro with a Guile/scheme function, extract the text you want to keep
 * with this extract function.  Just remember you should delete it at the
 * end, too.  Here is an example from my Finite State Machine generator:
 *
 * @example
 * [+ AutoGen5 Template  -*- Mode: text -*-
 * h=%s-fsm.h   c=%s-fsm.c
 * (shellf
 * "test -f %1$s-fsm.h && mv -f %1$s-fsm.h .fsm.head
 *  test -f %1$s-fsm.c && mv -f %1$s-fsm.c .fsm.code" (base-name))
 * +]
 * @end example
 *
 * This code will move the two previously produced output files to files
 * named ".fsm.head" and ".fsm.code".  At the end of the 'c' output
 * processing, I delete them.
 *
 * @item also NB:
 * This function presumes that the output file ought to be editable so
 * that the code between the @code{START} and @code{END} marks can be edited
 * by the template user.  Consequently, when the @code{(extract ...)} function
 * is invoked, if the @code{writable} option has not been specified, then
 * it will be set at that point.  If this is not the desired behavior, the
 * @code{--not-writable} command line option will override this.
 * Also, you may use the guile function @code{(chmod "file" mode-value)}
 * to override whatever AutoGen is using for the result mode.
 * @end table
=*//*
 *  If we got it, emit it.
 *//**
 *  Could not find the file or could not find the markers.
 *  Either way, emit an empty enclosure.
 *//*
     *  Make sure that we:
     *
     *  o got the file name from the SCM value
     *  o return the old text if we are searching the same file
     *  o have a regular file with some data
     *  o can allocate the space we need...
     *
     *  If we don't know about the current file, we leave the data
     *  from any previous file we may have loaded.
     *
     *  DO *NOT* include this file in dependency output.  The output may vary
     *  based on its contents, but since it is always optional input, it cannot
     *  be made to be required by make.
     *//**
 *  Load a file into memory.  Keep it in memory and try to reuse it
 *  if we get called again.  Likely, there will be several extractions
 *  from a single file.
 *
 * @param[in] new_fil  name of extraction file to load
 * @returns the contents of the file or NULL
 *//**
 * @file expExtract.c
 *
 *  This module implements a file extraction function.
 *
 * @addtogroup autogen
 * @{
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/expFormat.cprefxline pfx"line pfx"pnamep name"p name"ownrz"owner"licpzReslicense3110apzSfxchar[4096]l_filelic file"lic file"find_file(l_file, fname, apzSfx, NULL)find_file(l_file, fname, apzSfx, ((void *)0))aprf(CANNOT_FMT, errno, (ag_text_strtable+6588), l_file, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+6588), l_file, strerror((*__errno_location ())))7986588lic.pzFNtmap_info_t *lic.mi.txt_dataaprf(MK_LIC_NO_OPEN, l_file)aprf((ag_text_strtable+6384), l_file)"lic f name"6384pz[-1]prog_nameaprf(MK_LIC_TOO_BIG_FMT, MK_LIC_BIG_PROG, SCRIBBLE_SIZE)aprf((ag_text_strtable+6484), (ag_text_strtable+6539), 256)64846539aprf(MK_LIC_TOO_BIG_FMT, MK_LIC_BIG_PFX, SCRIBBLE_SIZE)aprf((ag_text_strtable+6484), (ag_text_strtable+6525), 256)6525aprf(MK_LIC_TOO_BIG_FMT, MK_LIC_BIG_OWN, SCRIBBLE_SIZE)aprf((ag_text_strtable+6484), (ag_text_strtable+6512), 256)6512pfx_sizepzSaveResout_sizeexit_countexit_copy(size_t)((pzOut - pzSaveRes) - 1)309530903045FIND_LIC_TEXT_LGPL+1(ag_text_strtable+3090)+1text_lenLSEG_NAMELSEG_INFOLSEG_DESCLSEG_FULLconstruct_licensesubsemptylic_textpfx_pzlic-prefix"lic-prefix"slst[0]slst[1]slst[2]slst[3]const char *const[4]char *[4]6626662066126636slst6559aprf(MK_LIC_NO_LIC, ag_scm2zchars(lic, "lic"))aprf((ag_text_strtable+6588), ag_scm2zchars(lic, "lic"))yearsfind_lic_textlic_sfxlic_pz"license"ftextflenfind_file(lic_pz, fname, lic_sfx, NULL)find_file(lic_pz, fname, lic_sfx, ((void *)0))aprf(CANNOT_FMT, errno, (ag_text_strtable+3100), fname, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+3100), fname, strerror((*__errno_location ())))3100stbf.st_mode(stbf.st_mode)aprf(CANNOT_FMT, errno, (ag_text_strtable+3050), fname, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+3050), fname, strerror((*__errno_location ())))EINVAL3050aprf(CANNOT_FMT, errno, (ag_text_strtable+1567), fname, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+1567), fname, strerror((*__errno_location ())))1567progpfxsegsegmenttxt_len(size_t)flen1875aprf(FIND_LIC_TEXT_INVAL, fname)aprf((ag_text_strtable+3065), fname)3065get_lic_name

"\n\n"2499trim_lic_namep + 1p[-1]assemble_full_descpdmdprefix_lenpfx[prefix_len - 2]txt[-1]abrtnum_bfmsg_ln(res)*msgsizeof(num_bf)%d"%d"error string"error string"char **__restrict__6271059219316089warn str"warn str""warn called without a message string"warn called without a message string16076date_strpzFirstpzPrefixpfxLendne-prefix"dne-prefix"68100'd'AUTOGEN_DNE_DATE"AUTOGEN_DNE_DATE"%s
"%s\n"2659pfx-1"pfx-1"tim_fmt  %B %e, %Y at %r by AutoGen 5.18.7"  %B %e, %Y at %r by AutoGen " AUTOGEN_VERSIONchar[36]tsizconst char[36]sizeof(tim_fmt)september"september""september")sizeof("september")sizeof("september") * 256sizeof(tim_fmt) + sizeof("september") * 2curTimetime_t *pTimeconst time_tconst time_t *(ssize_t)tsizpfp& DESC(DEFINITIONS)& (autogenOptions.pOptDesc[INDEX_OPT_DEFINITIONS])<<no definitions>>"<<no definitions>>"<<CGI-definitions>>"<<CGI-definitions>>"char[20]"-"stdin"stdin"27062518"Allocating Do-Not-Edit string"Allocating Do-Not-Edit stringchar[30]trim_trailing_whitetext[-2]-2doittext - 2dest[-2]dest - 2lic_segment_e_tmipzFN/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/expFormat.c *//*
         *  We allocated a temporary buffer that has all the
         *  formatting done, but need the prefixes on each line.
         *//*
         *  Create our output buffer and insert the first prefix
         *//*
         *  Figure out how much space we need (text size plus
         *  a prefix size for each newline)
         *//*
     *  Reformat the string with the given arguments
     *//*
     *  Get the addresses of the program name prefix and owner strings.
     *  Make sure they are reasonably sized (less than
     *  SCRIBBLE_SIZE).  Copy them to the scratch buffer.
     *//*
     *  Trim trailing white space.
     *//*
         *  Find the template file somewhere
         *//*=gfunc license
 *
 * what:  an arbitrary license
 * general_use:
 *
 * exparg: lic_name, file name of the license
 * exparg: prog_name, name of the licensed program or library
 * exparg: owner, Grantor of the License
 * exparg: prefix, String for starting each output line
 *
 * doc:
 *  Emit a string that contains the named license.
 *  This function is now deprecated.  Please @xref{SCM license-description}.
=*//*=gfunc bsd
 *
 * what:  BSD Public License
 * general_use:
 *
 * exparg: prog_name, name of the program under the BSD
 * exparg: owner, Grantor of the BSD License
 * exparg: prefix, String for starting each output line
 *
 * doc:
 *
 *  Emit a string that contains the Free BSD Public License.
 *  This function is now deprecated.  Please @xref{SCM license-description}.
 *
=*//*=gfunc lgpl
 *
 * what:  GNU Library General Public License
 * general_use:
 *
 * exparg: prog_name, name of the program under the LGPL
 * exparg: owner, Grantor of the LGPL
 * exparg: prefix, String for starting each output line
 *
 * doc:
 *
 *  Emit a string that contains the GNU Library General Public License.
 *  This function is now deprecated.  Please @xref{SCM license-description}.
=*//*=gfunc agpl
 *
 * what:  GNU Affero General Public License
 * general_use:
 *
 * exparg: prog-name, name of the program under the GPL
 * exparg: prefix, String for starting each output line
 *
 * doc:
 *
 *  Emit a string that contains the GNU Affero General Public License.
 *  This function is now deprecated.  Please @xref{SCM license-description}.
=*//*=gfunc gpl
 *
 * what:  GNU General Public License
 * general_use:
 *
 * exparg: prog-name, name of the program under the GPL
 * exparg: prefix, String for starting each output line
 *
 * doc:
 *
 *  Emit a string that contains the GNU General Public License.
 *  This function is now deprecated.  Please @xref{SCM license-description}.
=*//*=gfunc license_name
 *
 * what:  Emit the name of the license
 * general_use:
 *
 * exparg: license,   name of license type
 *
 * doc:
 *
 *  Emit a string that contains the full name of the license.
=*//*=gfunc license_info
 *
 * what:  Emit the licensing information and copyright years
 * general_use:
 *
 * exparg: license,   name of license type
 * exparg: prog-name, name of the program under the GPL
 * exparg: prefix,    String for starting each output line
 * exparg: owner,     owner of the program, optional
 * exparg: years,     copyright years, optional
 *
 * doc:
 *
 *  Emit a string that contains the licensing description, with some
 *  substitutions for program name, copyright holder, a list of years when the
 *  source was modified, and a per-line prefix.  This text typically includes a
 *  brief license description and is often printed out when a program starts
 *  running or as part of the @code{--version} output.
 *  For more details, @xref{SCM license-full, the license-full command}.
 *
=*//*=gfunc license_description
 *
 * what:  Emit a license description
 * general_use:
 *
 * exparg: license,   name of license type
 * exparg: prog-name, name of the program under the GPL
 * exparg: prefix,    String for starting each output line
 * exparg: owner,     owner of the program, optional
 *
 * doc:
 *
 *  Emit a string that contains a detailed license description, with
 *  substitutions for program name, copyright holder and a per-line prefix.
 *  This is the text typically used as part of a source file header.
 *  For more details, @xref{SCM license-full, the license-full command}.
 *
=*//*=gfunc license_full
 *
 * what:  Emit the licensing information and description
 * general_use:
 *
 * exparg: license,   name of license type
 * exparg: prog-name, name of the program under the GPL
 * exparg: prefix,    String for starting each output line
 * exparg: owner,     owner of the program, optional
 * exparg: years,     copyright years, optional
 *
 * doc:
 *
 *  Emit all the text that @code{license-info} and @code{license-description}
 *  would emit (@pxref{SCM license-info, @code{license-info}},
 *  and @pxref{SCM license-description, @code{license-description}}),
 *  with all the same substitutions.
 *
 *  All of these depend upon the existence of a license file named after the
 *  @code{license} argument with a @code{.lic} suffix.  That file should
 *  contain three blocks of text, each separated by two or more consecutive
 *  newline characters (at least one completely blank line).
 *
 *  The first section describes copyright attribution and the name of the usage
 *  licence.  For GNU software, this should be the text that is to be displayed
 *  with the program version.  Four text markers can be replaced: <PFX>,
 *  <program>, <years> and <owner>.
 *
 *  The second section is a short description of the terms of the license.
 *  This is typically the kind of text that gets displayed in the header of
 *  source files.  Only the <PFX>, <owner> and <program> markers are
 *  substituted.
 *
 *  The third section is strictly the name of the license.
 *  No marker substitutions are performed.
 *
 *  @example
 *  <PFX>Copyright (C) <years> <owner>, all rights reserved.
 *  <PFX>
 *  <PFX>This is free software. It is licensed for use,
 *  <PFX>modification and redistribution under the terms
 *  <PFX>of the GNU General Public License, version 3 or later
 *  <PFX>    <http://gnu.org/licenses/gpl.html>
 *
 *  <PFX><program> is free software: you can redistribute it
 *  <PFX>and/or modify it under the terms of the GNU General
 *  <PFX>Public License as published by the Free Software ...
 *
 *  the GNU General Public License, version 3 or later
 *  @end example
=*//**
 * Construct an SCM for the kind of text being requested.
 *
 * It may be "full" (the first two stanzas), "info" (the first -- copyright
 * info + license name), "description" (the second -- a one paragraph
 * description), or "name" -- the third stanza.
 *
 * @param seg    which segment of license is desired
 * @param lic    The name of the license
 * @param prog   the name of the program
 * @param pfx    a per-line prefix
 * @param owner  who owns the copyright
 * @param years  the copyright years
 *
 * @return the SCM-ized string
 *//*
     * auto-convert "bsd" into "mbsd" for compatibility.
     *//**
 * Find the kind of text being requested.  It may be "full" (the first
 * two stanzas), "info" (the first -- copyright info + license name),
 * "description" (the second -- a one paragraph description), or
 * "name" -- the third stanza.
 *
 * @param txt a pointer to the first of two newlines separating
 *            copyright information from the description.
 * @return pointer to the requested text.
 *//*
     * Find the third stanza.  If there.  If not, we supply some static
     * text:  "an unknown license"
     *//* skip the leading NL's. *//**
 * Extract the license name.  It is the third double-newline stanza
 * in the license file.
 *
 * @param txt a pointer to the first of two newlines separating
 *            copyright information from the description.
 * @return pointer to the license name trailer.
 *//*
     *  The last section ends with two consecutive new lines.
     *  All trailing newlines are trimmed (not all white space).
     *//* skip the leading white space.  It starts with NL. *//**
 * Trim off the license name.  It is the third double-newline stanza
 * in the license file.
 *
 * @param p  a pointer to the first of two newlines separating
 *            copyright information from the description.
 * @return pointer to second stanza, sans the license name trailer.
 *//*
     *  Look for a trailing license name and trim it and trailing white space
     *//*
     *  Maybe there were exactly enough NL characters we don't need to move
     *//* move destination *//* prefix destination *//*
     *  Preserve the first newline.  Set the move destination
     *  out past where we will be inserting the "<PFX>\n" marker.
     *//**
 * Assemble the copyright preamble and long license description.
 *
 * @param txt a pointer to the first of two newlines separating
 *            copyright information from the description.
 *//*
     *  IF there is a message,
     *  THEN print it.
     *//*
         *  IF the message starts with the number zero,
         *    OR the message is the empty string,
         *  THEN this is just a warning that is ignored
         *//*=gfunc error
 *
 * what:  display message and exit
 *
 * exparg: @ message @ message to display before exiting @@
 * doc:
 *
 *  The argument is a string that printed out as part of an error
 *  message.  The message is formed from the formatting string:
 *
 *  @example
 *  DEFINITIONS ERROR in %s line %d for %s:  %s\n
 *  @end example
 *
 *  The first three arguments to this format are provided by the
 *  routine and are:  The name of the template file, the line within
 *  the template where the error was found, and the current output
 *  file name.
 *
 *  After displaying the message, the current output file is removed
 *  and autogen exits with the EXIT_FAILURE error code.  IF, however,
 *  the argument begins with the number 0 (zero), or the string is the
 *  empty string, then processing continues with the next suffix.
=*//*=gfunc warn
 *
 * what:  display warning message and continue
 *
 * exparg: @ message @ message to display @@
 * doc:
 *
 *  The argument is a string that printed out to stderr.
 *  The message is formed from the formatting string:
 *
 *  @example
 *  @code{WARNING:}  %s\n
 *  @end example
 *
 *  The template processing resumes after printing the message.
=*//*
     *  Deallocate any temporary buffers.  pzFirst either points to
     *  the zNil string, or to an allocated buffer.
     *//*
     *  IF we also have a 'first' prefix string,
     *  THEN we set it to something other than ``zNil'' and deallocate later.
     *//* template user says "INCLUDE DNE date" *//* template user says "no DNE date" *//* false *//* no *//* use selection from template *//*
         * Check for a -d option (ignored) or a -D option (emit date)
         * by default, "dne" will not emit a date in the output.
         *//*=gfunc dne
 *
 * what:  '"Do Not Edit" warning'
 *
 * exparg: prefix,       string for starting each output line
 * exparg: first_prefix, for the first output line, opt
 * exparg: optpfx,       shifted prefix, opt
 *
 * doc:
 *  Generate a "DO NOT EDIT" or "EDIT WITH CARE" warning string.
 *  Which depends on whether or not the @code{--writable} command line
 *  option was set.
 *
 *  The first argument may be an option: @samp{-D} or @samp{-d}, causing the
 *  second and (potentially) third arguments to be interpreted as the first
 *  and second arguments.  The only useful option is @samp{-D}:
 *
 *  @table @samp
 *  @item -D
 *    will add date, timestamp and version information.
 *  @item -d
 *    is ignored, but still accepted for compatibility with older versions
 *    of the "dne" function where emitting the date was the default.
 *  @end table
 *
 *  If one of these options is specified, then the "prefix" and "first"
 *  arguments are obtained from the following arguments.  The presence (or
 *  absence) of this option can be overridden with the environment variable,
 *  @samp{AUTOGEN_DNE_DATE}.  The date is disabled if the value is empty or
 *  starts with one of the characters, @samp{0nNfF} -- zero or the first
 *  letter of "no" or "false".
 *
 *  The @code{prefix} argument is a per-line string prefix.  The optional
 *  second argument is a prefix for the first line only and, in read-only
 *  mode, activates editor hints.
 *
 *  @example
 *  -*- buffer-read-only: t -*- vi: set ro:
 *  @end example
 *
 *  @noindent
 *  The warning string also includes information about the template used
 *  to construct the file and the definitions used in its instantiation.
=*//**
 * Remove horizontal white space at the ends of lines.
 * "dne" and licensing text passes through this before
 * making an SCM out of the result.
 *
 * @param[in,out] text  the text to work on.
 *//**
 * @file expFormat.c
 *
 *  This module implements formatting expression functions.
 *
 * @addtogroup autogen
 * @{
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/expGperf.ckey2hashkey-to-hash"key-to-hash"gp_namegperf name"gperf name"7993do_cleanupgp_namgp nm"gp nm"h_listnl_scm6662hash list"hash list"51535093expGperf.cconst char[11]/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/expGperf.c *//*
     *  Format the gperf command and check the result.  If it fits in
     *  scribble space, use that.
     *  (If it does fit, then the test string fits already).
     *//*=gfunc gperf
 *
 * what:   perform a perfect hash function
 * general_use:
 *
 * exparg: name , name of hash list
 * exparg: str  , string to hash
 *
 * doc:  Perform the perfect hash on the input string.  This is only useful if
 *       you have previously created a gperf program with the @code{make-gperf}
 *       function @xref{SCM make-gperf}.  The @code{name} you supply here must
 *       match the name used to create the program and the string to hash must
 *       be one of the strings supplied in the @code{make-gperf} string list.
 *       The result will be a perfect hash index.
 *
 *       See the documentation for @command{gperf(1GNU)} for more details.
=*//*
         *  Run the command and ignore the results.
         *  In theory, the program should be ready.
         *//*
     *  Stash the concatenated list somewhere, hopefully without an alloc.
     *//*
     *  Construct the newline separated list of values
     *//*=gfunc make_gperf
 *
 * what:   build a perfect hash function program
 * general_use:
 *
 * exparg: name , name of hash list
 * exparg: strings , list of strings to hash ,, list
 *
 * doc:  Build a program to perform perfect hashes of a known list of input
 *       strings.  This function produces no output, but prepares a program
 *       named, @file{gperf_<name>} for use by the gperf function
 *       @xref{SCM gperf}.
 *
 *       This program will be obliterated as AutoGen exits.
 *       However, you may incorporate the generated hashing function
 *       into your C program with commands something like the following:
 *
 *       @example
 *       [+ (shellf "sed '/^int main(/,$d;/^#line/d' $@{gpdir@}/%s.c"
 *                  name ) +]
 *       @end example
 *
 *       where @code{name} matches the name provided to this @code{make-perf}
 *       function.  @code{gpdir} is the variable used to store the name of the
 *       temporary directory used to stash all the files.
=*//*
 *  This file is part of AutoGen.
 *  Copyright (C) 1992-2015 Bruce Korb - all rights reserved
 *
 * AutoGen is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AutoGen is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *//**
 * @file expGperf.c
 *
 *  Create a perfect hash function program and use it to compute
 *  index values for a list of provided names.  It also documents how
 *  to incorporate that hashing function into a generated C program.
 *
 * @addtogroup autogen
 * @{
 */hlist/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/expGuile.cpzdpzscap_donescm_i_string_chars(str)(int)ch((int)ch)tolower*__ctype_tolower_loc ()1048576(size_t)(pzd - res)AG_SCM_STRLEN(str)scm_c_string_length(str)(ch)w_start17694721446314418'_'sumSCM_CELL_OBJECT_0 (list)((((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((list)))): ((list))))))) [(0)]))(list)((list))SCM_GC_CELL_OBJECT (((list)), (0))(((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((list)))): ((list))))))) [(0)])SCM_CELL_OBJECT_1 (list)((((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((list)))): ((list))))))) [(1)]))SCM_GC_CELL_OBJECT (((list)), (1))(((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((list)))): ((list))))))) [(1)])number-in-string"number-in-string"min_val LONG_MAXmax_val-9223372036854775807-9223372036854775808LONG_MIN14918pzOldFile"scheme source"ln(((scm_t_bits) (0)) << 2) + scm_tc2_int(((scm_t_bits) (0)) << 2) + 2ans(8)2052(((((8)) << 8) + scm_tc8_flag))form(form)((SCM) ((((((10)) << 8) + scm_tc8_flag))))(((((10)) << 8) + scm_tc8_flag))(10)25602564(typ)((typ))SCM_GC_CELL_WORD (((typ)), (0))(((scm_t_bits) (0? (*(volatile SCM *)0=((((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=((((typ))))): (((typ)))))))) [((0))]))): (((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=((((typ))))): (((typ)))))))) [((0))]))))SCM_GC_CELL_OBJECT ((((typ))), ((0)))(((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=((((typ))))): (((typ)))))))) [((0))])(((typ)))scm_procedure_p(typ)(scm_procedure_p(typ))scm_pair_p(typ)(scm_pair_p(typ))scm_list_p(typ)(scm_list_p(typ))aprf(NOT_STR_FMT, type)aprf((ag_text_strtable+6690), type)6690/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/expGuile.c *//*=gfunc string_to_camelcase
 *
 * what:   make a string be CamelCase
 * general_use:
 *
 * exparg: str , input/output string
 *
 * doc:  Capitalize the first letter of each block of letters and numbers,
 *       and stripping out characters that are not alphanumerics.
 *       For example, "alpha-beta0gamma" becomes "AlphaBeta0gamma".
=*//*=gfunc string_downcase
 *
 * what:   lower case a new string
 * general_use:
 *
 * exparg: str , input string
 *
 * doc:  Create a new SCM string containing the same text as the original,
 *       only all the upper case letters are changed to lower case.
=*//*=gfunc string_downcase_x
 *
 * what:   make a string be lower case
 * general_use:
 *
 * exparg: str , input/output string
 *
 * doc:  Change to lower case all the characters in an SCM string.
=*//*=gfunc string_capitalize
 *
 * what:   capitalize a new string
 * general_use:
 *
 * exparg: str , input string
 *
 * doc:  Create a new SCM string containing the same text as the original,
 *       only all the first letter of each word is upper cased and all
 *       other letters are made lower case.
=*//*=gfunc string_capitalize_x
 *
 * what:   capitalize a string
 * general_use:
 *
 * exparg: str , input/output string
 *
 * doc:  capitalize all the words in an SCM string.
=*//*=gfunc string_upcase
 *
 * what:   upper case a new string
 * general_use:
 *
 * exparg: str , input string
 *
 * doc:  Create a new SCM string containing the same text as the original,
 *       only all the lower case letters are changed to upper case.
=*//*=gfunc string_upcase_x
 *
 * what:   make a string be upper case
 * general_use:
 *
 * exparg: str , input/output string
 *
 * doc:  Change to upper case all the characters in an SCM string.
=*//*=gfunc string_to_c_name_x
 *
 * what:   map non-name chars to underscore
 * general_use:
 *
 * exparg: str , input/output string
 *
 * doc:  Change all the graphic characters that are invalid in a C name token
 *       into underscores.  Whitespace characters are ignored.  Any other
 *       character type (i.e. non-graphic and non-white) will cause a failure.
=*//*=gfunc sum
 *
 * what:   sum of values in list
 * general_use:
 *
 * exparg: list , list of values.  Strings are converted to numbers ,, list
 *
 * doc:  Compute the sum of the list of expressions.
=*//*=gfunc min
 *
 * what:   minimum value in list
 * general_use:
 *
 * exparg: list , list of values.  Strings are converted to numbers ,, list
 *
 * doc:  Return the minimum value in the list
=*//*=gfunc max
 *
 * what:   maximum value in list
 * general_use:
 *
 * exparg: list , list of values.  Strings are converted to numbers ,, list
 *
 * doc:  Return the maximum value in the list
=*//* Read expressions from that port; ignore the values.  *//**
 * convert complex Guile type to an enum value.
 * @param typ the SCM for which we wish to know the type
 * @returns teGuileType -- our own enumeration, since Guile does not have one.
 *//**
 *  As of Guile 1.7.x, access to the NUL terminated string referenced by
 *  an SCM is no longer guaranteed.  Therefore, we must extract the string
 *  into one of our "scribble" buffers.
 *
 * @param  s     the string to convert
 * @param  type  a string describing the string
 * @return a NUL terminated string, or it aborts.
 *//**
 * @file expGuile.c
 *
 *  This module implements the expression functions that should
 *  be part of Guile.
 *
 * @addtogroup autogen
 * @{
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/expMake.cres_strboltabchmake script"make script"'@'(size_t)(out - res_str)script_sizeptxte*txttxt + 1ptxte+1handle_sed_expr105'i'3726372037113715handle_eolpzScnl_lenpzOut[-1]3072pzOut[-3]pzOut[-5]'&'124'|'skip_semi_colon4842-3-536783674append_statement_endtext_scmtxt_ptabsrc_pout_pppzippzo/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/expMake.c *//* quadruple *//*
                 *  $$ in the shell means process id.  Avoid having to do a
                 *  backward scan on the second '$' by handling the next '$'
                 *  now.  We get FOUR '$' chars.
                 *//* one only *//*
             * Quadruple a double dollar, leave alone make-interesting
             * dollars, and double it otherwise.
             *//*
             * As a special "hack", if a line starts with "@ifdef", "@ifndef",
             * "@else" or "@endif", then we assume post processing sed will
             * fix it up.  Those lines get left alone.
             *//*
         * "text" now points to one of three characters:
         * a newline, a dollar or a NUL byte.
         *//*
     *  Force the initial line to start with a real tab.
     *//*@< char to use for start-of-line tab *//*@< start of last output line *//*@< output scanning ptr *//*@< result string *//*=gfunc makefile_script
 *
 * what:  create makefile script
 * general_use:
 *
 * exparg: text, the text of the script
 *
 * doc:
 *  This function will take ordinary shell script text and reformat it
 *  so that it will work properly inside of a makefile shell script.
 *  Not every shell construct can be supported; the intent is to have
 *  most ordinary scripts work without much, if any, alteration.
 *
 *  The following transformations are performed on the source text:
 *
 *  @enumerate
 *  @item
 *  Trailing whitespace on each line is stripped.
 *
 *  @item
 *  Except for the last line, the string, " ; \\" is appended to the end of
 *  every line that does not end with certain special characters or keywords.
 *  Note that this will mutilate multi-line quoted strings, but @command{make}
 *  renders it impossible to use multi-line constructs anyway.
 *
 *  @item
 *  If the line ends with a backslash, it is left alone.
 *
 *  @item
 *  If the line ends with a semi-colon, conjunction operator, pipe (vertical
 *  bar) or one of the keywords "then", "else" or "in", then a space and a
 *  backslash is added, but no semi-colon.
 *
 *  @item
 *  The dollar sign character is doubled, unless it immediately precedes an
 *  opening parenthesis or the single character make macros '*', '<', '@@',
 *  '?' or '%'.  Other single character make macros that do not have enclosing
 *  parentheses will fail.  For shell usage of the "$@@", "$?" and "$*"
 *  macros, you must enclose them with curly braces, e.g., "$@{?@}".
 *  The ksh construct @code{$(<command>)} will not work.  Though some
 *  @command{make}s accept @code{$@{var@}} constructs, this function will
 *  assume it is for shell interpretation and double the dollar character.
 *  You must use @code{$(var)} for all @command{make} substitutions.
 *
 *  @item
 *  Double dollar signs are replaced by four before the next character
 *  is examined.
 *
 *  @item
 *  Every line is prefixed with a tab, unless the first line
 *  already starts with a tab.
 *
 *  @item
 *  The newline character on the last line, if present, is suppressed.
 *
 *  @item
 *  Blank lines are stripped.
 *
 *  @item
 *  Lines starting with "@@ifdef", "@@ifndef", "@@else" and "@@endif" are
 *  presumed to be autoconf "sed" expression tags.  These lines will be
 *  emitted as-is, with no tab prefix and no line splicing backslash.
 *  These lines can then be processed at configure time with
 *  @code{AC_CONFIG_FILES} sed expressions, similar to:
 *
 *  @example
 *  sed "/^@@ifdef foo/d;/^@@endif foo/d;/^@@ifndef foo/,/^@@endif foo/d"
 *  @end example
 *  @end enumerate
 *
 *  @noindent
 *  This function is intended to be used approximately as follows:
 *
 *  @example
 *  $(TARGET) : $(DEPENDENCIES)
 *  <+ (out-push-new) +>
 *  ....mostly arbitrary shell script text....
 *  <+ (makefile-script (out-pop #t)) +>
 *  @end example
=*//*
     *  "txt" is now our starting point.  Do not modify it any more.
     *//*
     *  Do nothing with empty input.
     *//*
     *  skip all blank lines and other initial white space
     *  in the source string.
     *//**
 * Compute a maximal size for the output script.  Leading and trailing white
 * space are trimmed.  Dollar characters will likely be doubled and newlines
 * may get as many as MAKE_SCRIPT_NL_LEN characters inserted.  Make sure
 * there's space.
 *
 * @param txt   pointer to text.  We skip initial white space.
 * @param tab   pointer to where we stash the tab character to use
 * @returns     the maximum number of bytes required to store result.
 *//* do not skip NUL *//**
 * Pass through untreated sedable lines.  Sometimes it is just very useful
 * to post-process Makefile files with sed(1) to clean it up.
 *
 * @param txt   pointer to text.  We skip initial white space.
 * @param tab   pointer to where we stash the tab character to use
 * @returns     true to say this was a sed line and was emitted,
 *              false to say it was not and needs to be copied out.
 *//*
     *  We have now started our next output line and there are still data.
     *  Indent with a tab, if called for.  If we do insert a tab, then skip
     *  leading tabs on the line.
     *//*
         *  Terminate the current command and escape the newline.
         */// "else"// "then" or "in"/*
         *  Whatever the reason for a final '|', '&' or ';',
         *  we will not add a semi-colon after it.
         *//*
         *  A single ampersand is a backgrounded command.  We must terminate
         *  those statements, but not statements conjoined with '&&'.
         *//*
         *  The newline is already escaped, so don't
         *  insert our extra command termination.
         *//*
     *  The final newline is dropped.
     *//*
     *  Skip over empty lines, but leave leading white space
     *  on the next non-empty line.
     *//*
     *  Backup past trailing white space (other than newline).
     *//**
 * Figure out how to handle the line continuation.
 * If the line we just finished ends with a backslash, we're done.
 * Just add the newline character.  If it ends with a semi-colon or a
 * doubled amphersand or doubled or-bar, then escape the newline with a
 * backslash.  If the line ends with one of the keywords "then", "in" or
 * "else", also only add the escaped newline.  Otherwise, add a
 * semi-colon, backslash and newline.
 *
 * @param  ppzi  pointer to pointer to input text
 * @param  ppzo  pointer to pointer to output text
 * @param  tabch line prefix (tab) character
 * @param  bol   pointer to start of currently-being-output line
 *
 * @returns false to say the newline is dropped becase we're done
 *          true  to say the line was appended with the newline.
 *//**
 * @file expMake.c
 *
 *  This module implements Makefile construction functions.
 *
 * @addtogroup autogen
 * @{
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/expOutput.copzoszgpzgszlpz3733lszhszscan_p"header guard string"*(lpz++)(*(lpz++))*lpz(unsigned char)*(lpz++)((unsigned char)*(lpz++))3330sz1sz26331expOutput.c9376456lineNumsvpos(int)NLSEEK_SETVOIDP(p->stk_fname)((void *)(uintptr_t)(p->stk_fname))p->stk_fnametbufpzNewFilenew_filesz + 1"new file name"aprf(CANNOT_FMT, errno, (ag_text_strtable+7071), pzNewFile, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+7071), pzNewFile, strerror((*__errno_location ())))wb+"w" FOPEN_BINARY_FLAG "+"7071const utimbufconst utimbuf *utimbuf *15644__func__write_modeconst char[4]NO_FMEMOPEN& DESC(NO_FMEMOPEN)& (autogenOptions.pOptDesc[INDEX_OPT_NO_FMEMOPEN])sizeof(out_stack_t)"out file stack"aprf(CANNOT_FMT, errno, (ag_text_strtable+7060), pzNewFile, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+7060), pzNewFile, strerror((*__errno_location ())))(ssize_t)04848706015624const char[20]tmplentmp_fnmtmpfdaprf(OUT_PUSH_NEW_FAILED, pz_temp_tpl)aprf((ag_text_strtable+6923), pz_temp_tpl)6923tmpdir6417tmp_szbfszcmdbf12536585append_modeab+"a" FOPEN_BINARY_FLAG "+"6888list_len16097resume name"resume name"tSuspendName *f-chars"f-chars"fprintf_woops160pSuspended[ ix ].pzSuspendNamesusp_nm15673aprf(OUT_RESUME_CANNOT, pzName)aprf((ag_text_strtable+6958), pzName)69587003suspAllocCt * sizeof(tSuspendName)"susp file list"VOIDP(pSuspended)((void *)(uintptr_t)(pSuspended))"add to susp f"pSuspended15837const char[19]line_offnum_or_strfile/line format"file/line format"29961242015664const char[15] #t" #t"ret_contents(ret_contents)cur_fpstack->stk_fnameaprf(CANNOT_FMT, errno, (ag_text_strtable+12366), cur_fpstack->stk_fname, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+12366), cur_fpstack->stk_fname, strerror((*__errno_location ())))12366"file name"15567const char[16]-9~FPF_STATIC_NM15597sizeof(*p)nmsz + 1"file name string"aprf(CANNOT_FMT, errno, (ag_text_strtable+6800), pz, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+6800), pz, strerror((*__errno_location ())))'w'6800W_OK409507777aprf(CANNOT_FMT, errno, (ag_text_strtable+6784), pz, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+6784), pz, strerror((*__errno_location ())))678415580const char[17]f_mode146-1473584384448403240883949NO_WRITE_MASKdo_output_file_line6807void *[2]line_deltasnv_constpointer *current_linelnnotSuspendNamepOutDescpzSuspendNameoutputDepthsuspAllocCtsuspendCt((unsigned)(~(S_IWUSR|S_IWGRP|S_IWOTH) & S_IAMB))S_IAMB(S_ISUID|S_ISGID|S_ISVTX|S_IRWXU|S_IRWXG|S_IRWXO)defined(HAVE_FSTAT) || defined(HAVE_FCHMOD)HAVE_FSTATHAVE_FCHMODdefined(ENABLE_FMEMOPEN)/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/expOutput.c *//*
         *  This copy converts non-alphanumerics to underscores,
         *  but never inserts more than one at a time.  Thus, we may
         *  not use all of the space in "gpz".
         */// gpz must be freed/*
         * Sanity:
         *//*
         *  Full, maximal length of output
         *//*
         *  Leader string and its length.  Usually passed, but defaults
         *  to "HEADER"
         *//*
     *  Construct the gard name using the leader (passed in or "HEADER")
     *  and the trailer (always "_GUARD") and the output file name in between.
     */// guard name string// output file name string// =*///  * get handled.//  * a particular template, you will need to be careful how these SCM symbols//  * Obviously, if you are going to produce more than one header file from//  *//  * @end example//  * #include "[+ (. header-file) +]"//  * @example//  * you can put this into that generated file://  * generating a C file that uses the previously generated header file,//  * in an SCM symbol, @code{header-file}.  Therefore, if you are also//  * The name of the header file (the current output file) is also stored//  * #endif /* [+ (. header-guard) +] *///  * file should read something like://  * @code{header-guard}.  Consequently, the concluding @code{#endif} for the//  * The final @code{#define} name is stored in an SCM symbol named//  * @end enumerate//  * Finally, the entire string is mapped to upper case.//  * @item//  * The end of the name is always, "@code{_GUARD}".//  * characters mapped to underscores.//  * That is followed by the name of the header file with illegal//  * The first element is the string argument and a separating underscore.//  * @enumerate//  * The @code{#define} name is composed as follows://  * @noindent//  * #include "[+ (. header-file)  +]"//  * ...//  * [+ (make-header-guard "group_name") +]//  * as follows://  * used to protect it.  It is expected that this will be used//  * @code{header-guard} to the name of the @code{#define} being//  * to the name of the file being protected and it will set//  * It will also set the Scheme variable @code{header-file}//  * sequence for protecting a header from multiple evaluation.//  * This function will create a @code{#ifndef}/@code{#define}//  * doc://  * exparg: name , header group name//  * what:   make self-inclusion guard// /*=gfunc   make_header_guard// This is done so that comment delimiters can be included in the doc./* for compilers that do not like C++ comments... *//*=gfunc out_line
 *
 * what: output file line number
 * doc:  Returns the current line number of the output file.
 *       It rewinds and reads the file to count newlines.
=*//*=gfunc out_name
 *
 * what: current output file name
 * doc:  Returns the name of the current output file.  If the current file
 *       is a temporary, unnamed file, then it will scan up the chain until
 *       a real output file name is found.
 *       @xref{output controls}.
=*//*=gfunc out_depth
 *
 * what: output file stack depth
 * doc:  Returns the depth of the output file stack.
 *       @xref{output controls}.
=*//* memory leak *//*
     *  Set the mod time on the old file.
     *//*
     *  Make sure we get a new file pointer!!
     *  and try to ensure nothing is in the way.
     *//*
     *  IF no change, THEN ignore this
     *//*=gfunc out_switch
 *
 * what:   close and create new output
 * exparg: file-name, name of the file to create
 *
 * doc:
 *  Switch output files - close current file and make the current
 *  file pointer refer to the new file.  This is equivalent to
 *  @code{out-pop} followed by @code{out-push-new}, except that
 *  you may not pop the base level output file, but you may
 *  @code{switch} it.  @xref{output controls}.
=*//*
     *  Either --no-fmemopen was specified or we cannot use ag_fmemopen().
     *//*
         *  This block is used IFF ENABLE_FMEMOPEN is defined and if
         *  --no-fmemopen is *not* selected on the command line.
         *//*
     *  "ENABLE_FMEMOPEN" is defined if we have either fopencookie(3GNU) or
     *  funopen(3BSD) is available and autogen was not configured with fmemopen
     *  disabled.  We cannot use the POSIX fmemopen.
     *//*=gfunc out_push_new
 *
 * what:   purge and create output file
 * exparg: file-name, name of the file to create, optional
 *
 * doc:
 *  Leave the current output file open, but purge and create
 *  a new file that will remain open until a @code{pop} @code{delete}
 *  or @code{switch} closes it.  The file name is optional and, if omitted,
 *  the output will be sent to a temporary file that will be deleted when
 *  it is closed.
 *  @xref{output controls}.
=*/// restore dir char// trim dir char// "ag-XXXXXX"/*=gfunc make_tmp_dir
 *
 * what:   create a temporary directory
 *
 * doc:
 *  Create a directory that will be cleaned up upon exit.
=*//*=gfunc out_push_add
 *
 * what:   append output to file
 * exparg: file-name, name of the file to append text to
 *
 * doc:
 *  Identical to @code{push-new}, except the contents are @strong{not}
 *  purged, but appended to.  @xref{output controls}.
=*//*
     *  Still here?  We have a bad "port" specification.
     *//*
     *  If "port" is a number, it is an index into the output stack with "0"
     *  (zero) representing the current output and "1" the last suspended
     *  output.  If the number is out of range, we'll fall through to the
     *  abend.
     *//*
     *  If "port" is a string, it must match one of the suspended outputs.
     *  Otherwise, we'll fall through to the abend.
     *//*=gfunc ag_fprintf
 *
 * what:  format to autogen stream
 *
 * exparg: ag-diversion, AutoGen diversion name or number
 * exparg: format,       formatting string
 * exparg: format-arg,   list of arguments to formatting string, opt, list
 *
 * doc:  Format a string using arguments from the alist.
 *       Write to a specified AutoGen diversion.
 *       That may be either a specified suspended output stream
 *       (@pxref{SCM out-suspend}) or an index into the output stack
 *       (@pxref{SCM out-push-new}).  @code{(ag-fprintf 0 ...)} is
 *       equivalent to @code{(emit (sprintf ...))}, and
 *       @code{(ag-fprintf 1 ...)} sends output to the most recently
 *       suspended output stream.
=*//*=gfunc out_emit_suspended
 *
 * what:   emit the text of suspended output
 * exparg: susp_nm, A name tag of suspended output
 * doc:
 *  This function is equivalent to
 *  @code{(begin (out-resume <name>) (out-pop #t))}
=*//* Guile alloc *//*=gfunc out_resume
 *
 * what:   resume suspended output file
 * exparg: susp_nm, A name tag for reactivating
 * doc:
 *  If there has been a suspended output, then make that output descriptor
 *  current again.  That output must have been suspended with the same tag
 *  name given to this routine as its argument.
=*//*=gfunc out_suspend
 *
 * what:   suspend current output file
 * exparg: suspName, A name tag for reactivating
 *
 * doc:
 *  If there has been a @code{push} on the output, then set aside the output
 *  descriptor for later reactiviation with @code{(out-resume "xxx")}.  The
 *  tag name need not reflect the name of the output file.  In fact, the
 *  output file may be an anonymous temporary file.  You may also change the
 *  tag every time you suspend output to a file, because the tag names are
 *  forgotten as soon as the file has been "resumed".
=*//*=gfunc output_file_next_line
 *
 * what:   print the file name and next line number
 *
 * exparg: line_off, offset to line number,   optional
 * exparg: alt_fmt,  alternate format string, optional
 *
 * doc:
 *  Returns a string with the current output file name and line number.
 *  The default format is: # <line+1> "<output-file-name>" The argument may be
 *  either a number indicating an offset from the current output line number
 *  or an alternate formatting string.  If both are provided, then the first
 *  must be a numeric offset.
 *
 *  Be careful that you are directing output to the final output file.
 *  Otherwise, you will get the file name and line number of the temporary
 *  file.  That won't be what you want.
=*/// const-ness not important/*=gfunc out_pop
 *
 * what:   close current output file
 * exparg: disp, return contents of the file, optional
 * doc:
 *  If there has been a @code{push} on the output, then close that
 *  file and go back to the previously open file.  It is an error
 *  if there has not been a @code{push}.  @xref{output controls}.
 *
 *  If there is no argument, no further action is taken.  Otherwise,
 *  the argument should be @code{#t} and the contents of the file
 *  are returned by the function.
=*//*=gfunc out_move
 *
 * what:   change name of output file
 * exparg: new-name, new name for the current output file
 *
 * doc:
 *
 *  Rename current output file.  @xref{output controls}.
 *  Please note: changing the name will not save a temporary file from
 *  being deleted.  It @i{may}, however, be used on the root output file.
 *
 *  NOTE: if you are creating a dependency file, @i{both} the original
 *  file name @i{and} the new file name will be listed as derived files.
=*//*
     *  Delete the current output file
     *//*=gfunc out_delete
 *
 * what: delete current output file
 * doc:
 *  Remove the current output file.  Cease processing the template for
 *  the current suffix.  It is an error if there are @code{push}-ed
 *  output files.  Use the @code{(error "0")} scheme function instead.
 *  @xref{output controls}.
=*//*
     * Avoid printing temporary file names in the dependency file
     *//*
     * If we cannot write to the file, try to change permissions.
     *//*
     *  IF we are creating the file and we are allowed to unlink the output,
     *  then start by unlinking the thing.
     *//**
 * Some common code for creating a new file
 *//*
     *  Mask off the write permission bits, but ensure that
     *  the user read bit is set.
     *//*
     *  Set our usage mask to all all the access
     *  bits that do not provide for write access
     *//*
     *  If the output is supposed to be writable, then also see if
     *  it is a temporary condition (set vs. a command line option).
     *//**
 * chmod a-w on a file descriptor.
 *//**
 * guts of the output file/line function
 *//**
 * return the current line number
 *//*
 *  Access Mask Bits (3 special plus RWX for User Group & Others (9))
 *//**
 * @file expOutput.c
 *
 *  This module implements the output file manipulation function
 *
 * @addtogroup autogen
 * @{
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/expPrint.cscanDone"fmt"end_adreaddr"eaddr"str_size390637923857(size_t)(scan - res)run_printf(pzFmt, list_len, alist)void *[8]arglistargpsizeof(void *)SCM_CELL_OBJECT_0 (alist)((((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((alist)))): ((alist))))))) [(0)]))(alist)((alist))SCM_GC_CELL_OBJECT (((alist)), (0))(((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((alist)))): ((alist))))))) [(0)])SCM_CELL_OBJECT_1 (alist)((((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((alist)))): ((alist))))))) [(1)]))SCM_GC_CELL_OBJECT (((alist)), (1))(((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((alist)))): ((alist))))))) [(1)])(car == SCM_BOOL_F) ? SCM_FALSE_STR : SCM_TRUE_STR(car == ((SCM) ((((((0)) << 8) + scm_tc8_flag))))) ? (ag_text_strtable+12359) : (ag_text_strtable+12387)123591238712362printf str"printf str"12381bfbf_szsafePrintfsaSave1saSave2SIGBUSSIGSEGVprintJumpEnvdisplayppzBufargV81658210p_szaprf(ASPRINTFV_FAIL_FMT, p_sz)aprf((ag_text_strtable+483), p_sz)10485750xFFFFFU4293918720~0xFFFFFU483printFaultprintJumpSignal! defined(DEBUG_ENABLED)/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/expPrint.c *//*=gfunc   format_arg_count
 *
 * what:   count the args to a format
 * general_use:
 *
 * exparg: format, formatting string
 *
 * doc:    "Sometimes, it is useful to simply be able to figure out how many\n"
 *         "arguments are required by a format string.  For example, if you\n"
 *         "are extracting a format string for the purpose of generating a\n"
 *         "macro to invoke a printf-like function, you can run the\n"
 *         "formatting string through this function to determine how many\n"
 *         "arguments to provide for in the macro. e.g. for this extraction\n"
 *         "text:\n"
 *         "@example\n\n"
 *         " /" "*=fumble bumble\n"
 *         "  * fmt: 'stumble %s: %d\\n'\n"
 *         " =*" "/\n"
 *         "@end example\n\n"
 *         "@noindent\n"
 *         "You may wish to generate a macro:\n"
 *         "@example\n\n"
 *         " #define BUMBLE(a1,a2) printf_like(something,(a1),(a2))\n"
 *         "@end example\n\n"
 *         "@noindent\n"
 *         "You can do this by knowing that the format needs two arguments.\n"
=*/// e.g. "&#107;"/*=gfunc hide_email
 *
 * what:  convert eaddr to javascript
 * general_use:
 *
 * exparg: display, display text
 * exparg: eaddr,   email address
 *
 * doc:    Hides an email address as a java scriptlett.
 *         The 'mailto:' tag and the email address are coded bytes
 *         rather than plain text.  They are also broken up.
=*//*=gfunc fprintf
 *
 * what:  format to a file
 * general_use:
 *
 * exparg: port, Guile-scheme output port
 * exparg: format, formatting string
 * exparg: format-arg, list of arguments to formatting string, opt, list
 *
 * doc:  Format a string using arguments from the alist.
 *       Write to a specified port.  The result will NOT appear in your
 *       output.  Use this to print information messages to a template user.
=*//*=gfunc printf
 *
 * what:  format to stdout
 * general_use:
 *
 * exparg: format, formatting string
 * exparg: format-arg, list of arguments to formatting string, opt, list
 *
 * doc:  Format a string using arguments from the alist.
 *       Write to the standard out port.  The result will NOT appear in your
 *       output.  Use this to print information messages to a template user.
 *       Use ``(sprintf ...)'' to add text to your document.
=*//*=gfunc sprintf
 *
 * what:  format a string
 * general_use:
 *
 * exparg: format, formatting string
 * exparg: format-arg, list of arguments to formatting string, opt, list
 *
 * doc:  Format a string using arguments from the alist.
=*//*
     *  Do the formatting and allocate a new SCM to hold the result.
     *  Free up any allocations made by ``gh_scm2newstr''
     *//* 1MB max *//* ! defined(DEBUG_ENABLED) *//*
         *  The "sprintfv" command below faulted, so we exit
         *//*
         *  IF the fprintf command in the then clause has not failed yet,
         *  THEN perform that fprintf
         *//*
     *  IF the sprintfv call below is going to address fault,
     *  THEN ...
     *//*
     *  In normal operation (or during AutoGen testing), seg faults during the
     *  printf operation are caused by bad input data.  During AutoGen
     *  development, we do not supply bad printf arguments, so we want to
     *  capture any segfaults when they happen with the correct stack trace.
     *  Therefore, during AutoGen development, we do not protect against seg
     *  faults.
     *//**
 * @file expPrint.c
 *
 *  The following code is necessary because the user can give us
 *  a printf format requiring a string pointer yet fail to provide
 *  a valid pointer, thus it will fault.  This code protects
 *  against the fault so an error message can be emitted instead of
 *  a core dump :-)
 *
 * @addtogroup autogen
 * @{
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/expState.c1146ag value"ag value"fmt_scmf/l fmt"f/l fmt"def->de_filedef->de_linemaxlendo_tpl_file_lineln_nocurrent_tpl->td_fileln_no + (unsigned)line_deltafull(full)find_file(tpl_fname, z, sfx, NULL)find_file(tpl_fname, z, sfx, ((void *)0))4838sfxC(char *, tpl_fname)((char *)((void *)(uintptr_t)(tpl_fname)))(char *)curr_sfxopt + arg"opt + arg"has_idxv_namede->de_val.dvu_textvnmvname"vname"3432non text value"non text value"no value at all"no value at all"3390alt_v_namescm_procedure_p(op)(scm_procedure_p(op))test15548test val"test val"ag user macro"ag user macro"ag object"ag object"C(char *, (base_ctx->scx_fname))((char *)((void *)(uintptr_t)((base_ctx->scx_fname))))(base_ctx->scx_fname)ent_lenval1ver"ver"val2str2int_ver 4*(++pz)VER_UNIT_SHIFTnext_number1 << VER_UNIT_SHIFT(1 << VER_UNIT_SHIFT)(1 << VER_UNIT_SHIFT) - 1((1 << VER_UNIT_SHIFT) - 1)'p''r'(VER_UNIT_SHIFT - 2)leave_str2int_verv1v215885C(char *, OPT_ARG(BASE_NAME))((char *)((void *)(uintptr_t)(((autogenOptions.pOptDesc[INDEX_OPT_BASE_NAME]).optArg.argString))))OPT_ARG(BASE_NAME)((autogenOptions.pOptDesc[INDEX_OPT_BASE_NAME]).optArg.argString)BASE_NAMEfind_entry_valuepzFieldfind name"find name"148793010def->de_val.dvu_textfield(result == SCM_BOOL_T) ? FIND_ENT_SUCC : FIND_ENT_FAIL(result == ((SCM) ((((((4)) << 8) + scm_tc8_flag))))) ? (ag_text_strtable+3018) : (ag_text_strtable+3010)3018count_entriesdefsentry_lengthver_type_tSCM_FROM(v)scm_from_uint64(v)16ULL((SCM_MAJOR_VERSION * 100) + SCM_MINOR_VERSION) >= 108HAVE_SCM_FROM_UINT32/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/expState.c *//*
     *  IF we did not find the entry we are looking for
     *  THEN return UNDEFINED
     *//*=gfunc def_file_line
 *
 * what:   get a definition file+line number
 *
 * exparg: ag-name, name of AutoGen value
 * exparg: msg-fmt, formatting for line message, optional
 *
 * doc:
 *  Returns the file and line number of a AutoGen defined value, using
 *  either the default format, "from %s line %d", or else the format you
 *  supply.  For example, if you want to insert a "C" language file-line
 *  directive, you would supply the format "# %2$d \"%1$s\"", but that
 *  is also already supplied with the scheme variable
 *  @xref{SCM c-file-line-fmt}.  You may use it thus:
 *
 *  @example
 *  (def-file-line "ag-def-name" c-file-line-fmt)
 *  @end example
 *
 *  It is also safe to use the formatting string, "%2$d".  AutoGen uses
 *  an argument vector version of printf: @xref{snprintfv}.
=*//*=gfunc max_file_time
 *
 * what: get the maximum input file modification time
 *
 * doc:  returns the time stamp of the most recently modified sourc file as the
 *       number of seconds since the epoch.  If any input is dynamic (a shell command),
 *       then it will be the current time.
=*//*=gfunc tpl_file_next_line
 *
 * what:   get the template file plus next line number
 *
 * exparg: msg-fmt, formatting for line message, optional
 *
 * doc:
 *  This is almost the same as @xref{SCM tpl-file-line}, except that
 *  the line referenced is the next line, per C compiler conventions, and
 *  consequently defaults to the format:  # <line-no+1> "<file-name>"
=*//*=gfunc tpl_file_line
 *
 * what:   get the template file+line number
 *
 * exparg: msg-fmt, formatting for line message, optional
 *
 * doc:
 *  Returns the file and line number of the current template macro using
 *  either the default format, "from %s line %d", or else the format you
 *  supply.  For example, if you want to insert a "C" language file-line
 *  directive, you would supply the format "# %2$d \"%1$s\"", but that
 *  is also already supplied with the scheme variable
 *  @xref{SCM c-file-line-fmt}.  You may use it thus:
 *  @example
 *  (tpl-file-line c-file-line-fmt)
 *  @end example
 *
 *  It is also safe to use the formatting string, "%2$d".  AutoGen uses
 *  an argument vector version of printf: @xref{snprintfv},
 *  and it does not need to know the types of each argument in order to
 *  skip forward to the second argument.
=*//**
 * guts of the template file/line functions
 *//*=gfunc tpl_file
 *
 * what:   get the template file name
 *
 * exparg: full_path, include full path to file, optonal
 *
 * doc:  Returns the name of the current template file.
 *       If @code{#t} is passed in as an argument, then the template
 *       file is hunted for in the template search path.  Otherwise,
 *       just the unadorned name.
=*//*=gfunc suffix
 *
 * what:   get the current suffix
 *
 * doc:
 *  Returns the current active suffix (@pxref{pseudo macro}).
=*//*=gfunc set_option
 *
 * what:  Set a command line option
 *
 * exparg: opt, AutoGen option name + its argument
 *
 * doc:   The text argument must be an option name followed by any needed
 *        option argument.  Returns SCM_UNDEFINED.
=*//*
     *  IF we did not find the entry we are looking for
     *  THEN return zero
     *  ELSE we have the low index.
     *//*=gfunc low_lim
 *
 * what:   get lowest value index
 *
 * exparg: ag-name, name of AutoGen value
 *
 * doc:  Returns the lowest index associated with an array of definitions.
=*//*=gfunc len
 *
 * what:   get count of values
 *
 * exparg: ag-name, name of AutoGen value
 *
 * doc:  If the named object is a group definition, then "len" is
 *       the same as "count".  Otherwise, if it is one or more text
 *       definitions, then it is the sum of their string lengths.
 *       If it is a single text definition, then it is equivalent to
 *       @code{(string-length (get "ag-name"))}.
=*//*
     *  IF we did not find the entry we are looking for
     *  THEN return zero
     *  ELSE search the twin list for the high entry
     *//*=gfunc high_lim
 *
 * what:   get highest value index
 *
 * exparg: ag-name, name of AutoGen value
 *
 * doc:
 *
 *  Returns the highest index associated with an array of definitions.
 *  This is generally, but not necessarily, one less than the
 *  @code{count} value.  (The indexes may be specified, rendering a
 *  non-zero based or sparse array of values.)
 *
 *  This is very useful for specifying the size of a zero-based array
 *  of values where not all values are present.  For example:
 *
 *  @example
 *  tMyStruct myVals[ [+ (+ 1 (high-lim "my-val-list")) +] ];
 *  @end example
=*//*=gfunc get_down_name
 *
 * what:   get lower cased named value, mapped to C name syntax
 *
 * exparg: ag-name, name of AutoGen value
 *
 * doc:
 *
 *  Get the first string value associated with the name.  It will either
 *  return the associated string value (if the name resolves), the alternate
 *  value (if one is provided), or else the empty string.  The result is
 *  passed through "string->c-name!" and "string->down-case!".
=*//*=gfunc get_up_name
 *
 * what:   get upper cased named value, mapped to C name syntax
 *
 * exparg: ag-name, name of AutoGen value
 *
 * doc:
 *
 *  Get the first string value associated with the name.  It will either
 *  return the associated string value (if the name resolves), the alternate
 *  value (if one is provided), or else the empty string.  The result is
 *  passed through "string->c-name!" and "string->up-case!".
=*//*=gfunc get_c_name
 *
 * what:   get named value, mapped to C name syntax
 *
 * exparg: ag-name, name of AutoGen value
 *
 * doc:
 *
 *  Get the first string value associated with the name.  It will either
 *  return the associated string value (if the name resolves), the alternate
 *  value (if one is provided), or else the empty string.  The result is
 *  passed through "string->c-name!".
=*//*=gfunc get
 *
 * what:   get named value
 *
 * exparg: ag-name, name of AutoGen value
 * exparg: alt-val, value if not present, optional
 *
 * doc:
 *  Get the first string value associated with the name.
 *  It will either return the associated string value (if
 *  the name resolves), the alternate value (if one is provided),
 *  or else the empty string.
=*//*=gfunc match_value_p
 *
 * what:   test for matching value
 *
 * exparg: op,       boolean result operator
 * exparg: ag-name,  name of AutoGen value
 * exparg: test-str, string to test against
 *
 * doc:  This function answers the question, "Is there an AutoGen value named
 *       @code{ag-name} with a value that matches the pattern @code{test-str}
 *       using the match function @code{op}?"  Return SCM_BOOL_T iff at least
 *       one occurrence of the specified name has such a value.  The operator
 *       can be any function that takes two string arguments and yields a
 *       boolean.  It is expected that you will use one of the string matching
 *       functions provided by AutoGen.
 *       @*
 *       The value name must follow the same rules as the
 *       @code{ag-name} argument for @code{exist?} (@pxref{SCM exist?}).
=*//*=gfunc ag_function_p
 *
 * what:   test for function
 *
 * exparg: ag-name, name of AutoGen macro
 *
 * doc:  return SCM_BOOL_T if a specified name is a user-defined AutoGen
 *       macro, otherwise return SCM_BOOL_F.
=*//*=gfunc exist_p
 *
 * what:   test for value name
 *
 * exparg: ag-name, name of AutoGen value
 *
 * doc:  return SCM_BOOL_T iff a specified name has an AutoGen value.
 *       The name may include indexes and/or member names.
 *       All but the last member name must be an aggregate definition.
 *       For example:
 *       @example
 *       (exist? "foo[3].bar.baz")
 *       @end example
 *       will yield true if all of the following is true:
 *       @*
 *       There is a member value of either group or string type
 *       named @code{baz} for some group value @code{bar} that
 *       is a member of the @code{foo} group with index @code{3}.
 *       There may be multiple entries of @code{bar} within
 *       @code{foo}, only one needs to contain a value for @code{baz}.
=*//*=gfunc def_file
 *
 * what:   definitions file name
 *
 * doc:  Get the name of the definitions file.
 *       Returns the name of the source file containing the AutoGen
 *       definitions.
=*//*=gfunc count
 *
 * what:   definition count
 *
 * exparg: ag-name, name of AutoGen value
 *
 * doc:  Count the number of entries for a definition.
 *      The input argument must be a string containing the name
 *      of the AutoGen values to be counted.  If there is no
 *      value associated with the name, the result is an SCM
 *      immediate integer value of zero.
=*//**
 * Convert version number strings into a binary representation and compare.
 *//*=gfunc version_compare
 *
 * what:   compare two version numbers
 * general_use:
 *
 * exparg: op, comparison operator
 * exparg: v1, first version
 * exparg: v2, compared-to version
 *
 * doc:  Converts v1 and v2 strings into 64 bit values and returns the
 *       result of running 'op' on those values.  It assumes that the version
 *       is a 1 to 4 part dot-separated series of numbers.  Suffixes like,
 *       "5pre4" or "5-pre4" will be interpreted as two numbers.  The first
 *       number ("5" in this case) will be decremented and the number after
 *       the "pre" will be added to 0xC000.  (Unless your platform is unable
 *       to support 64 bit integer arithmetic.  Then it will be added to 0xC0.)
 *       Consequently, these yield true:
 *       @example
 *       (version-compare > "5.8.5"       "5.8.5-pre4")
 *       (version-compare > "5.8.5-pre10" "5.8.5-pre4")
 *       @end example
=*//*=gfunc base_name
 *
 * what:   base output name
 *
 * doc:  Returns a string containing the base name of the output file(s).
 *       Generally, this is also the base name of the definitions file.
=*//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *  EXPRESSION ROUTINES
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//*
     *  Search the members for what we want.
     *//*
     *  a subfield for a text macro?  return FALSE
     *//* Cannot match string -- not a text value *//*
     *  No subfield?  Check the values
     *//*
     *  No such entry?  return FALSE
     *//**
 * Find a definition with a specific value
 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *  EXPRESSION EVALUATION SUPPORT ROUTINES
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//**
 * @file expState.c
 *
 *  This module implements expression functions that
 *  query and get state information from AutoGen data.
 *
 * @addtogroup autogen
 * @{
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/expString.ctime_periodtime_specMatch(size_t)lenStrlenzscm_i_string_chars(Str)1 << 8ch_mapsizeof(ch_map)sizeof(ch_map) - 1"str"(int)sizeof(ch_map)(int)sizeof(ch_map) - 1fchtchfetstemap_done"cstr"1133krstr"krstr"4325AG Object"AG Object"pDE->de_val.dvu_text*pos(*pos)((*pos))&SCM_GC_CELL_OBJECT (((*pos)), (1))&(((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((*pos)))): ((*pos))))))) [(1)])(unsigned char)'`'(unsigned char)'"'pzFreedtaSizedtaSize + 2"raw string"ReplFromTofrom_xformto_xformloopDonereturnString"pfx""txt"r_strscan - r_strsv_l_lensep_lenstr_lenpzSepcpy_lenpz1pzNxt(match)SCM_CELL_OBJECT_0 (match)((((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((match)))): ((match))))))) [(0)]))((match))SCM_GC_CELL_OBJECT (((match)), (0))(((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((match)))): ((match))))))) [(0)])SCM_CELL_OBJECT_0 (repl)((((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((repl)))): ((repl))))))) [(0)]))(repl)((repl))SCM_GC_CELL_OBJECT (((repl)), (0))(((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((repl)))): ((repl))))))) [(0)])SCM_CELL_OBJECT_1 (match)((((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((match)))): ((match))))))) [(1)]))SCM_GC_CELL_OBJECT (((match)), (1))(((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((match)))): ((match))))))) [(1)])SCM_CELL_OBJECT_1 (repl)((((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((repl)))): ((repl))))))) [(1)]))SCM_GC_CELL_OBJECT (((repl)), (1))(((SCM *)((scm_t_cell *) (((scm_t_bits) (0? (*(volatile SCM *)0=(((repl)))): ((repl))))))) [(1)])matchCarscm_list_p(matchCar)(scm_list_p(matchCar))replCardo_substitutionpzMatchmatch text"match text"rep_strrepl text"repl text"mark_lenrepl_lensub_countrepCtneedle_lenshell_stringifypzNewpzDtaloopDone1"shell string"stringify_for_sh/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/expString.c *//*=gfunc time_string_to_number
 *
 * what:   duration string to seconds
 * general_use:
 * exparg: time_spec, string to parse
 *
 * doc:    Convert the argument string to a time period in seconds.
 *         The string may use multiple parts consisting of days, hours
 *         minutes and seconds.  These are indicated with a suffix of
 *         @code{d}, @code{h}, @code{m} and @code{s} respectively.
 *         Hours, minutes and seconds may also be represented with
 *         @code{HH:MM:SS} or, without hours, as @code{MM:SS}.
=*//*=gfunc string_substitute
 *
 * what:  multiple global replacements
 * general_use:
 *
 *  exparg:  source, string to transform
 *  exparg:  match,  substring or substring list to be replaced
 *  exparg:  repl,   replacement strings or substrings
 *
 * doc: @code{match} and  @code{repl} may be either a single string or
 *      a list of strings.  Either way, they must have the same structure
 *      and number of elements.  For example, to replace all amphersands,
 *      less than and greater than characters, do something like this:
 *
 * @example
 *      (string-substitute source
 *          (list "&"     "<"    ">")
 *          (list "&amp;" "&lt;" "&gt;"))
 * @end example
=*//*=gfunc string_tr
 *
 * what:  convert characters with new result
 * general_use:
 *
 *  exparg:  source, string to transform
 *  exparg:  match,  characters to be converted
 *  exparg:  translation, conversion list
 *
 * doc: This is identical to @code{string-tr!}, except that it does not
 *      over-write the previous value.
=*//* bits-per-byte *//*=gfunc string_tr_x
 *
 * what:  convert characters
 * general_use:
 *
 *  exparg:  source, string to transform
 *  exparg:  match,  characters to be converted
 *  exparg:  translation, conversion list
 *
 * doc: This is the same as the @code{tr(1)} program, except the
 *      string to transform is the first argument.  The second and
 *      third arguments are used to construct mapping arrays for the
 *      transformation of the first argument.
 *
 *      It is too bad this little program has so many different
 *      and incompatible implementations!
=*//*=gfunc c_string
 *
 * what:  emit string for ANSI C
 * general_use:
 *
 * exparg: string, string to reformat
 *
 * doc:
 *  Reform a string so that, when printed, the C compiler will be able to
 *  compile the data and construct a string that contains exactly what the
 *  current string contains.  Many non-printing characters are replaced with
 *  escape sequences.  Newlines are replaced with a backslash, an @code{n}, a
 *  closing quote, a newline, seven spaces and another re-opening quote.  The
 *  compiler will implicitly concatenate them.  The reader will see line
 *  breaks.
 *
 *  A K&R compiler will choke.  Use @code{kr-string} for that compiler.
 *
=*//*=gfunc kr_string
 *
 * what:  emit string for K&R C
 * general_use:
 *
 * exparg: string, string to reformat
 *
 *  doc:
 *  Reform a string so that, when printed, a K&R C compiler will be able
 *  to compile the data and construct a string that contains exactly
 *  what the current string contains.  Many non-printing characters are
 *  replaced with escape sequences.  New-lines are replaced with a
 *  backslash-n-backslash and newline sequence,
=*//*=gfunc stack
 *
 * what:  make list of AutoGen values
 *
 * exparg: ag-name, AutoGen value name
 *
 * doc:  Create a scheme list of all the strings that are associated
 *       with a name.  They must all be text values or we choke.
=*//*=gfunc sub_shell_str
 *
 * what:  back quoted (sub-)shell string
 * general_use:
 *
 * exparg: string, string to transform
 *
 * doc:
 *   This function is substantially identical to @code{shell-str}, except
 *   that the quoting character is @code{`} and the "leave the escape alone"
 *   character is @code{"}.
=*//*=gfunc shell_str
 *
 * what:  double quote shell string
 * general_use:
 *
 * exparg: string, string to transform
 *
 * doc:
 *
 *  Convert the text of the string into a double quoted string that a normal
 *  shell will process into the original string, almost.  It will add the
 *  escape character @code{\\} before two special characters to
 *  accomplish this: the backslash @code{\\} and double quote @code{"}.
 *
 *  @strong{Notice}: some shells will not correctly handle unusual
 *  non-printing characters.  This routine works for most reasonably
 *  conventional ASCII strings.
 *
 *  @strong{WARNING}:
 *@*
 *  This function omits the extra backslash in front of a backslash, however,
 *  if it is followed by either a backquote or a dollar sign.  It must do this
 *  because otherwise it would be impossible to protect the dollar sign or
 *  backquote from shell evaluation.  Consequently, it is not possible to
 *  render the strings "\\$" or "\\`".  The lesser of two evils.
 *
 *  All others characters are copied directly into the output.
 *
 *  The @code{sub-shell-str} variation of this routine behaves identically,
 *  except that the extra backslash is omitted in front of @code{"} instead
 *  of @code{`}.  You have to think about it.  I'm open to suggestions.
 *
 *  Meanwhile, the best way to document is with a detailed output example.
 *  If the backslashes make it through the text processing correctly,
 *  below you will see what happens with three example strings.  The first
 *  example string contains a list of quoted @code{foo}s, the second is
 *  the same with a single backslash before the quote characters and the
 *  last is with two backslash escapes.  Below each is the result of the
 *  @code{raw-shell-str}, @code{shell-str} and @code{sub-shell-str} functions.
 *
 *  @example
 *  foo[0]           ''foo'' 'foo' "foo" `foo` $foo
 *  raw-shell-str -> \'\''foo'\'\'' '\''foo'\'' "foo" `foo` $foo'
 *  shell-str     -> "''foo'' 'foo' \"foo\" `foo` $foo"
 *  sub-shell-str -> `''foo'' 'foo' "foo" \`foo\` $foo`
 *
 *  foo[1]           \'bar\' \"bar\" \`bar\` \$bar
 *  raw-shell-str -> '\'\''bar\'\'' \"bar\" \`bar\` \$bar'
 *  shell-str     -> "\\'bar\\' \\\"bar\\\" \`bar\` \$bar"
 *  sub-shell-str -> `\\'bar\\' \"bar\" \\\`bar\\\` \$bar`
 *
 *  foo[2]           \\'BAZ\\' \\"BAZ\\" \\`BAZ\\` \\$BAZ
 *  raw-shell-str -> '\\'\''BAZ\\'\'' \\"BAZ\\" \\`BAZ\\` \\$BAZ'
 *  shell-str     -> "\\\\'BAZ\\\\' \\\\\"BAZ\\\\\" \\\`BAZ\\\` \\\$BAZ"
 *  sub-shell-str -> `\\\\'BAZ\\\\' \\\"BAZ\\\" \\\\\`BAZ\\\\\` \\\$BAZ`
 *  @end example
 *
 *  There should be four, three, five and three backslashes for the four
 *  examples on the last line, respectively.  The next to last line should
 *  have four, five, three and three backslashes.  If this was not accurately
 *  reproduced, take a look at the agen5/test/shell.test test.  Notice the
 *  backslashes in front of the dollar signs.  It goes from zero to one to
 *  three for the "cooked" string examples.
=*//*
             *  We've inserted a single quote, which ends the quoting session.
             *  Now, insert escaped quotes for every quote char we find, then
             *  restart the quoting.
             *//*
     *  Start quoting.  If the string is empty, we wind up with two quotes.
     *//*
         *  IF pure single quotes, then we're done.
         *//*
     *  Handle leading single quotes before starting the first quote.
     *//* '\'' -> 3 additional chars *//* NUL + 2 quotes *//*=gfunc raw_shell_str
 *
 * what:  single quote shell string
 * general_use:
 *
 * exparg: string, string to transform
 *
 * doc:
 *  Convert the text of the string into a singly quoted string
 *  that a normal shell will process into the original string.
 *  (It will not do macro expansion later, either.)
 *  Contained single quotes become tripled, with the middle quote
 *  escaped with a backslash.  Normal shells will reconstitute the
 *  original string.
 *
 *  @strong{Notice}:  some shells will not correctly handle unusual
 *  non-printing characters.  This routine works for most reasonably
 *  conventional ASCII strings.
=*/// prefix length plus 1 for new line/*
             * Trim trailing white space on previous line first.
             *//*
             * Trim trailing white space on the final line.
             */// NUL or NL byte adjustment/* result string *//*=gfunc prefix
 *
 * what:  prefix lines with a string
 * general_use:
 *
 * exparg: prefix, string to insert at start of each line
 * exparg: text, multi-line block of text
 *
 * doc:
 *  Prefix every line in the second string with the first string.
 *  This includes empty lines, though trailing white space will
 *  be removed if the line consists only of the "prefix".
 *  Also, if the last character is a newline, then *two* prefixes will
 *  be inserted into the result text.
 *
 *  For example, if the first string is "# " and the second contains:
 *  @example
 *  "two\nlines\n"
 *  @end example
 *  @noindent
 *  The result string will contain:
 *  @example
 *  # two
 *  # lines
 *  #
 *  @end example
 *
 *  The last line will be incomplete:  no newline and no space after the
 *  hash character, either.
=*//*
         *  IF we reach zero, then do not insert a separation and bail out
         *//*
         *  This unravels nested lists.
         *//*
     *  Now, copy each one into the output
     *//*
         *  This routine is listed as getting a list as the second
         *  argument.  That means that if someone builds a list and
         *  hands it to us, it magically becomes a nested list.
         *  This unravels that.
         *//*
     *  Count up the lengths of all the strings to be joined.
     *//*=gfunc join
 *
 * what:   join string list with separator
 * general_use:
 * exparg: separator, string to insert between entries
 * exparg: list, list of strings to join,, list
 *
 * doc:  With the first argument as the separator string,
 *       joins together an a-list of strings into one long string.
 *       The list may contain nested lists, partly because you
 *       cannot always control that.
=*//*
     *  Search all the lists and sub-lists passed in
     *//*
     *  If the second argument is a string somehow, then treat
     *  this as a straight out string comparison
     *//*=gfunc in_p
 *
 * what:   test for string in list
 * general_use:
 * exparg: test-string, string to look for
 * exparg: string-list, list of strings to check,, list
 *
 * doc:  Return SCM_BOOL_T if the first argument string is found
 *      in one of the entries in the second (list-of-strings) argument.
=*//*=gfunc mk_gettextable
 *
 * what:   print a string in a gettext-able format
 * exparg: string, a multi-paragraph string
 *
 * doc: Returns SCM_UNDEFINED.  The input text string is printed
 *      to the current output as one puts() call per paragraph.
=*//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *  EXPRESSION EVALUATION ROUTINES
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//*
             *  Whatever it is it is not part of what we would expect.  Bail.
             */// coverity[use_after_free] -- invalid alias analysis/*
         *  "CAR" is the current value, "CDR" is rest of list
         *//*
     *  Loop for as long as our list has more entries
     *//*
 *  Recursive routine.  It calls itself for list values and calls
 *  "do_substitution" for string values.  Each substitution will
 *  be done in the order found in the tree walk of list values.
 *  The "match" and "repl" trees *must* be identical in structure.
 *//* No substitutions -- no work. *//**
 *  Replace marker text.
 *
 *  Replace all occurrances of the marker text with the substitution text.
 *  The result is stored in an automatically freed temporary buffer.
 *
 *  @param src_str  The source string
 *  @param str_len  The length of the string
 *  @param match    the SCM-ized marker string
 *  @param repl     the SCM-ized replacement string
 *  @param ppz_res  pointer to the result pointer
 *  @param res_len  pointer to result length
 *//* "   -->   \"   *//*
                 *  This routine does both `xx` and "xx" strings, we have
                 *  to worry about this stuff differently.  I.e., in ""
                 *  strings, add a single \ in front of ", and in ``
                 *  preserve a add \ in front of `.
                 *//* \   -->  \\    *//*
                 *  IF the ensuing quote character does *NOT* match the
                 *  quote character for the string, then we will preserve
                 *  the single copy of the backslash.  If it does match,
                 *  then we will double the backslash and a third backslash
                 *  will be inserted when we emit the quote character.
                 *//*
             *  If someone went to the trouble to escape a backquote or a
             *  dollar sign, then we should not neutralize it.  Note that
             *  we handle a following backslash as a normal character.
             *
             *  i.e.  \\ --> \\\\ *BUT* \\$ --> \\\$
             *//**
 * @file expString.c
 *
 *  This module implements expression functions that
 *  manipulate string values.
 *
 * @addtogroup autogen
 * @{
 */src_strppz_reshaystackneedleqtin_pz/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/agShell.cwas_started1246914112fp_pair_t *"Text Block"982load_datatext_szused_ctchar[1024]zLineretry_ctTIMEOUT(int)sizeof(zLine)serv_pair.fp_readline_pchar__write_only__14135LOAD_RETRY_LIMIT14213llen1405615461VOIDP(text)((void *)(uintptr_t)(text))"resize out"realloc_text0xFFF18446744073709547520(size_t)~0xFFFVOIDP(*p_txt)((void *)(uintptr_t)(*p_txt))*p_sz"expand text"*p_txtserver_fp_openfd_pairchIdfd_pair_t *rb"r" FOPEN_BINARY_FLAGwb"w" FOPEN_BINARY_FLAGserver_openpid_t *chain_openout_pairch_pid15759p_txtneed_lenfp_pairppArgsin_fdarg_vchild_pidSTDIN_FILENOSTDOUT_FILENOF_DUPFDSTDERR_FILENO_IONBF15783aprf(CANNOT_FMT, errno, "execvp", shell, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), "execvp", shell, strerror((*__errno_location ())))server_setup14075new_saSIGPIPESIGALRMsend_server_init_cmdspzcSHELL_INIT_STR_LEN + 11 + strlen(autogenOptions.pzProgPath)1253 + 11 + strlen(autogenOptions.pzProgPath)"server init"126412779load_data()14092start_server_cmd_trace159061417715852send_cmd_ok127085061serv_pair.fp_writeset_orig_dir1251015738handle_signaltimeout_limit144891273714033SIGTERMclose_server_shell in %u state
"close_server_shell in %u state\n"char[32]"format"shell script12395joinercommand"command"signozChdirDirchdir directory"chdir directory"dirlast_cmdlog_ctwas_close_errserv_idserv_paircur_dirHAVE_USLEEP/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/agShell.c *//* ! SHELL_ENABLED *//*
     *  Now try to read back all the data.  If we fail due to either
     *  a sigpipe or sigalrm (timeout), we will return the nil string.
     *//*
     *  Make sure the process will pay attention to us,
     *  send the supplied command, and then
     *  have it output a special marker that we can find.
     *//*
     *  IF it is still not running,
     *  THEN return the nil string.
     *//*
     *  IF the shell server process is not running yet,
     *  THEN try to start it.
     *//**
 *  Run a semi-permanent server shell.  The program will be the
 *  one named by the environment variable $SHELL, or default to "sh".
 *  If one of the commands we send to it takes too long or it dies,
 *  we will shoot it and restart one later.
 *
 *  @param cmd the input command string
 *  @returns an allocated string, even if it is empty.
 *//*
     *  Trim off all trailing white space and shorten the buffer
     *  to the size actually used.
     *//*
         *  Stop now if server timed out or if we are at EOF
         *//*
         *  Check for magic character sequence indicating 'DONE'
         *//* no data - retry *//*
             *  Guard against a server timeout
             *//*
         *  Set a timeout so we do not wait forever.  Sometimes we don't wait
         *  at all and we should.  Retry in those cases (but not on EOF).
         *//**
 *  Read data from a file pointer (a pipe to a process in this context)
 *  until we either get EOF or we get a marker line back.
 *  The read data are stored in a malloc-ed string that is truncated
 *  to size at the end.  Input is assumed to be an ASCII string.
 *//**
 *  Identical to "server_open()", except that the "fd"'s are "fdopen(3)"-ed
 *  into file pointers instead.
 *//*
     *  Create a bi-directional pipe.  Writes on 0 arrive on 1
     *  and vice versa, so the parent and child processes will
     *  read and write to opposite FD's.
     *//**
 *  Given a pointer to an argument vector, start a process and
 *  place its stdin and stdout file descriptors into an fd pair
 *  structure.  The "fd_write" connects to the inferior process
 *  stdin, and the "fd_read" connects to its stdout.  The calling
 *  process should write to "fd_write" and read from "fd_read".
 *  The return value is the process id of the created process.
 *//*
     *  Make the output file unbuffered only.
     *  We do not want to wait for shell output buffering.
     *//*
     *  set stderr to our trace file (if not stderr).
     *//*
     *  Set stdin/out to the fd passed in and the write end of our new pipe.
     *//*
     *  Close the pipe end handed back to the parent process,
     *  plus stdin and stdout.
     *//* child - continue processing *//* parent - return opposite FD's *//* parent - error in call *//*
     *  Make sure our standard streams are all flushed out before forking.
     *  (avoid duplicate output). Call fork() and see which process we become
     *//*
     *  Create a pipe it will be the child process' stdout,
     *  and the parent will read from it.
     *//*
     *  If the arg list does not have a program,
     *  assume the zShellProg from the environment, or, failing
     *  that, then sh.  Set argv[0] to whatever we decided on.
     *//*
     *  If we did not get an arg list, use the default
     *//**
 *  Given an FD for an inferior process to use as stdin,
 *  start that process and return a NEW FD that that process
 *  will use for its stdout.  Requires the argument vector
 *  for the new process and, optionally, a pointer to a place
 *  to store the child's process id.
 *
 * @param stdinFd the file descriptor for the process' stdin
 * @param ppArgs  The program and argument vector
 * @param pChild  where to stash the child process PID
 *
 * @returns the read end of a pipe the child process uses for stdout
 *//**
 * Perform various initializations required when starting
 * a new server shell process.
 */// log10(1 << 32) + 1/**
 * Send down the initialization string with our PID in it, as well
 * as the full path name of the autogen executable.
 *//**
 * Tracing level is TRACE_EVERYTHING, so send the server shell
 * various commands to start "set -x" tracing and display the
 * trap actions.
 *//**
 * Send a command string down to the server shell
 *//**
 * first time starting a server shell, we get our current directory.
 * That value is kept, but may be changed via a (chdir "...") scheme call.
 *//**
 * handle SIGALRM and SIGPIPE signals while waiting for server shell
 * responses.
 *//*
         *  This is _completely_ wrong, but sometimes there are data left
         *  hanging about that gets sucked up by the _next_ server shell
         *  process.  That should never, ever be in any way possible, but
         *  it is the only explanation for a second server shell picking up
         *  the initialization string twice.  It must be a broken timing
         *  issue in the Linux stdio code.  I have no other explanation.
         *//*
     *  This guard should not be necessary.  However, sometimes someone
     *  holds an allocation pthread lock when a seg fault occurrs.  fclose
     *  needs that lock, so we hang waiting for it.  Oops.  So, when we
     *  are aborting, we just let the OS close these file descriptors.
     *//* 1/10 of a second *//*=gfunc shellf
 *
 * what:  format a string, run shell
 * general_use:
 *
 * exparg: format, formatting string
 * exparg: format-arg, list of arguments to formatting string, opt, list
 *
 * doc:  Format a string using arguments from the alist,
 *       then send the result to the shell for interpretation.
=*//*=gfunc shell
 *
 * what:  invoke a shell script
 * general_use:
 *
 * exparg: command, shell command - the result is from stdout, , list
 * This may be a list of strings and they will all be concatenated.
 *
 * doc:
 *  Generate a string by writing the value to a server shell and reading the
 *  output back in.  The template programmer is responsible for ensuring that
 *  it completes within 10 seconds.  If it does not, the server will be
 *  killed, the output tossed and a new server started.
 *
 *  Please note: This is the same server process used by the '#shell'
 *  definitions directive and backquoted @code{`} definitions.  There may be
 *  left over state from previous shell expressions and the @code{`}
 *  processing in the declarations.  However, a @code{cd} to the original
 *  directory is always issued before the new command is issued.
 *
 *  Also note:  When initializing, autogen will set the environment
 *  variable "AGexe" to the full path of the autogen executable.
=*//*
     *  We're still here, so we have a valid argument.
     *//*=gfunc chdir
 *
 * what:   Change current directory
 *
 * exparg: dir, new directory name
 *
 * doc:  Sets the current directory for AutoGen.  Shell commands will run
 *       from this directory as well.  This is a wrapper around the Guile
 *       native function.  It returns its directory name argument and
 *       fails the program on failure.
=*//**
 * @file agShell.c
 *
 *  Manage a server shell process
 *
 * @addtogroup autogen
 * @{
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/ag-text.cag-text.c The '%d' address family cannot be handled %s__ %s=1 ABEND-ing in %s state
 processing template %s
            on line %d
       for function %s (%d)
 ag-fprintf: 'port' is invalid AUTOGEN_MAKE_DEP autogen5 AutoGen caught signal %d (%s) before initialization completed
 AutoGen aborting on signal %d (%s) in state %s
 Scheme definition expression does not yield string:
 Scheme Computed Definitions (alist->autogen-def %s) could not allocate for or formatting failed on:
%s asprintfv returned 0x%08X
 %s Error: Invalid input char '%c' in %s on line %d
 Cannot %s from outside a loop Could not resolve macro name: '%s' ??? indecipherable error message ??? Ill formed name '%s' in %s line %d
 Invalid regular expression:  error %d (%s):
%s --base-name name is too long ** BOGUS ** break %lu fserr %d: cannot %s %s:  %s
 duplicate make target unknown dependency type:  %s Content-type: text/plain

AutoGen form processing error:
 CGI parsing error:  %s /tmp/cgi-stderr-XXXXXX CLOSING SHELL SERVER - command failure:
	%s
 %s Error:  %s in %s on line %d
 DEFINITIONS %s in %s line %d for %s:
	%s
 Bad regular expression continue \n"
       " from %s line %d block INVALID text unknown  \
 
.PHONY : clean-%1$s

clean-%1$s :
	rm -f %3$s $(%2$s_TList)
	@-touch -t 199912312359 %1$s
 
%2$s : $(%1$s_SList)

$(%1$s_TList) : %2$s
	@:
  \
	%s DEPENDENCIES_OUTPUT 

%s_SList = %s_TList = /dev/null baseless - =1 $@ $$/../share/autogen 
# #assert yielded "%s":
	`%s` '#%s' directive encountered out of context
	in %s on line %d
 #error directive -- in %s on line %d
	%s
 open read def WARNING: fserr %d (%s) performing '%s' on %s
 Definition error:  in %s line %d, #endif not found
 Definition error:  in %s line %d, #%s no matching start/if directive
 Missing #endshell after '#shell' in %s on line %d
 Computed Definitions 
#endshell done_check done
 done_check re-done
 %s.%s 

 %s ERROR:  Too many definition files
 %soutput was abandoned
 %sBogus return from setjmp
 content-type: text/html

 * NONE * Starting stdout template
 stdout invalid chars in suffix format:  %s Empty suffix format Duplicate value index for %s:  %d #elif directive found out of context invalid emission port: %lu */ ERROR Error in template %s, line %d
	 attempted to use block macro in eval expression PROGRAM ERROR:  ambiguous expr code exit_cleanup %s done
===AutoGen ends - %u

 false exit_cleanup re-done
 no waiting (if (> (string-length shell-cleanup) 0) (shellf "( (%s) & >/dev/null 2>&1 )" shell-cleanup) ) waited an unknown license %6$s%1$sDO NOT EDIT THIS FILE   (%2$s)
%1$s
%1$sIt has been AutoGen-ed%3$s
%1$sFrom the definitions    %4$s
%1$sand the template file   %5$s %s -*- buffer-read-only: t -*- vi: set ro:
%s
 %6$s%1$sEDIT THIS FILE WITH CAUTION  (%2$s)
%1$s
%1$sIt has been AutoGen-ed%3$s
%1$sFrom the definitions    %4$s
%1$sand the template file   %5$s WARNING:  in %s on line %d unknown directive:
	#%s
 DO NOT CHANGE THIS COMMENT name not followed by '=' no space separating entries END   START # %2$d "%1$s" failed
 SUCCESS
 . %s/%s find-file agpl read full file invalid license file: %s lgpl mbsd stat file lic macros cannot nest macro has no end WARNING: empty macro in %s line %d
   --  DEBUG %s -- FOR index %d %d (%s) is an unknown macro function, or has no handler ? Say, what ?  (%c) ELSE clause FOR x IN ... has no list _GUARD   -  FOR-%s %s[%d] it#%d: Nxt %d, first=%s, last=%s
 'get' invoked with no name in %s line %u
 'get %s' retrieved in %s line %u
 Failing Guile command:  = = = = =

%s

=================================
 Could not decipher Guile version: %s
 Compiled Guile version does not match: %s vs %s
 GUILE_WARN_DEPRECATED GUILE_WARN_DEPRECATED=no els the Invalid template file SHELL= lse ndif fdef  fndef  HEADER Unterminated HereString HereString missing the mark &#%d; (debug-enable 'backtrace) HereString mark 64 or more chars ');
document.write('" >%s</a>');
//-->
</script> <script language="JavaScript" type="text/javascript">
<!--
var one = 'm&#97;';
var two = 'i&#108;t';
document.write('<a href="' + one + two );
document.write('&#111;: (use-modules (%s)) (read-enable 'positions)
(add-hook! before-error-hook error-source-line)
(use-modules (ice-9 stack-catch)) Unknown macro or invalid context in %s line %d:
	%s%s FOR macro requires iterator name The INCLUDE macro requires a file name \n\
 LC_ALL=C ESAC not found expressionless CASE DEFINE requires a name parse ended unexpectedly Invalid definition name `?' needs two expressions No space between expressions No text for unfound value in invalid FOR loop variable ENDFOR not found ENDIF not found LD_LIBRARY_PATH= LD_LIBRARY_PATH Empty macro text Invalid selection clause ENDWHILE not found expressionless WHILE %s
%s
%s @@ CGI Definitions @@ GET No CGI data were received CGI text map data file Could not open template '%s' not regular file agl tpl  ; \
 in-mem file mkstemp failed on `%s' to port %s with %d type address invalid CGI request method: ''%s'' Cannot expand directory name:  '%s' Template parse ended unexpectedly end of Guile/scheme expression not found 

* * * * LOG ENTRY %d * * * *
 (add-cleanup "rm -rf ${gpdir}") malloc of %zd bytes failed
 gperf --version > /dev/null 2>&1 || die 'no gperf program'
test -z ${gpdir} && {
  gpdir=`mktemp -d ./.gperf.XXXXXX` 2>/dev/null
  test -z "${gpdir}" && gpdir=.gperf.$$
  test -d ${gpdir} || mkdir ${gpdir} || die "cannot mkdir ${gpdir}"
}
cd ${gpdir} || die cannot cd into ${gpdir}
gpdir=`pwd`
gperf_%2$s=${gpdir}/%2$s

{
  cat << \_EOF_
%%{
#include <stdio.h>
%%}
struct %2$s_index { char const * name; int const idx; };
%%%%
_EOF_

  idx=1
  while read f
  do echo "${f}, ${idx}"
     idx=`expr ${idx} + 1`
  done << \_EOLIST_
%3$s
_EOLIST_

  cat << \_EOF_
%%%%
int main(int argc, char ** argv) {
    char * pz = argv[1];
    struct %2$s_index const * pI = %2$s_find( pz, strlen( pz ));
    if (pI == NULL)
        return 1;
    printf( "0x%%02X\n", pI->idx );
    return 0;
}
_EOF_
} > %2$s.gperf

exec 2> %2$s.log
gperf --language=ANSI-C -H %2$s_hash -N %2$s_find \
      -C -E -I -t %2$s.gperf > %2$s-temp.c || \
   die "gperf failed on ${gpdir}/%2$s.gperf
      `cat %2$s.log`"
egrep -v '^[^#].*_inline' %2$s-temp.c > %2$s.c
export CFLAGS=-g
%1$s %2$s 1>&2
test $? -eq 0 -a -x ${gperf_%2$s} || \
  die "could not '%1$s %2$s' gperf program
      `cat %2$s.log`"
exec 2>&8 (define header-file "%s") (define header-guard "%s") Could not open license file '%s' mk_tmp_dir ; echo ${tmp_dir}/ag-XXXXXX #ifndef %1$s
#define %1$s 1 %s may not exceed %d chars
 owner length prefix length program name length license name is not a string There is no %s license. <owner> <PFX> <program> <years> no macro arg name 
 Invalid template file: %s ERROR: %s is not a string
 expressionless IF no no template was specified NULL file name null open for output unlink * temp file * On macro argument # %d:
%s
 Cannot format file name:  "%s", %s, %s No output file specified to add to failed to create temp file from %s ERROR: no output file was suspended as '%s'
 ERROR:  Cannot pop output with no output pushed %s '%s'
 open 'wb+' freopen Autogen Definitions cgi;
 AF_UNIX path exceeds %d stdin dup2 %s-in %s-out fork mkfifo poll write Invalid port number:  '%s' Starting %s template
 pseudo-macro BROKEN FSM STATE The INVOKE macro requires a name The INVOKE macro name not space separated %s%s[%u] (%s) from %s/%d at %p
                                  start marker contained in end marker start/end macro mark too long end marker contained in start marker bad template marker in %s on line %d:
	%s invalid edit mode marker need autogen5 marker need end marker need end of line need start marker need template marker broken pseudo-macro FSM -*- *template file* @@ No-Definitions @@ open non-regular file stat No definition data were read REQUEST_METHOD ** EXACT ** ** INEXACT ** ** LIST ** ** Pair ** ** Procedure 0x%08lX ** ** UNKNOWN ** ** Vector ** RETURN out of context realloc of %zd bytes at 0x%p failed
 attempt to remove unrecorded def entry
 test -n "${gperf_%1$s}" || \
    die 'no environment variable "gperf_%1$s"'
test -x "${gperf_%1$s}" || \
    die "no gperf program named  ${gperf_%1$s}"
${gperf_%1$s} %2$s %s ERROR:  %s processing printf format:
	%s
 Bad args to sprintf ice-9 debug system vm trace Scheme evaluation error.  AutoGen ABEND-ing in template
	%s on line %d
 (use-modules (ice-9 common-list))
(define identifier?
(lambda (x) (or (string? x) (symbol? x))))
(define normalize-identifier
(lambda (x)
(if (string? x) (string->symbol x) x)))
(define coerce->string
(lambda (x)
(let ((char->string (lambda (x) (make-string 1 x)))
(coercable? (lambda (x)
(or (string? x) (boolean? x) (char? x)
(symbol? x) (list? x) (number? x)))))
(if (not (coercable? x))
(error "Wrong type to coerce->string" x))
(cond
((string? x)  (string-append
(char->string #\") x (char->string #\")))
((boolean? x) (if x "#t" "#f"))
((char? x)    (char->string x))
((number? x)  (number->string x))
((symbol? x)  (symbol->string x))
((list? x)    (if (every coercable? x)
(apply string-append (map coerce->string x))))
))))
(define alist->autogen-def
(lambda (lst . recursive)
(if (null? recursive) (set! recursive #f)
(set! recursive #t))
(let ((res (if recursive "{\n" ""))
(list-nnul? (lambda (x) (and (list? x) (not (null? x))))))
(do ((i lst (cdr i)))
((null? i) (if recursive
(string-append res "}")
res))
(let* ((kvpair (car i))
(value (cdr kvpair))
(value-is-alist (if (and (list-nnul? value)
(list-nnul? (car value))
(list-nnul? (caar value))
(identifier? (caaar value)))
#t #f)))
(set! res (string-append res
(coerce->string (normalize-identifier (car kvpair)))
" = "
(if value-is-alist
(alist->autogen-def (car value) 1)
(coerce->string (cdr kvpair)))
";\n"
)))))))
(define shell-cleanup "")
(define add-cleanup (lambda (t)
(set! shell-cleanup (string-append shell-cleanup "\n" t "\n"))))
(define tmp-dir "")
(define header-file     "")
(define header-guard    "")
(define autogen-version "5.18.7")
(define c-file-line-fmt "#line %2$d \"%1$s\"\n")
(define-macro (defined-as predicate symbol)
`(and (defined? ',symbol) (,predicate ,symbol)))
(catch #t
(lambda () (read-enable 'curly-infix))
(lambda args #f))
(define html-escape-encode (lambda (str)
(string-substitute str
'("&"      "<"     ">")
'("&amp;"  "&lt;"  "&gt;"))))
(define stt-table   (make-hash-table 31))
(define stt-curr    stt-table)
(define stt-idx-tbl stt-table)
(define stt-idx     0)
(define insert-suspended (lambda (susp-name) (begin
(out-resume susp-name) (out-pop #t))))
(define string-table-new (lambda (st-name) (begin
(set! stt-curr (make-hash-table 31))
(hash-create-handle! stt-table st-name stt-curr)
(out-push-new)
(out-suspend st-name)
(set! stt-idx-tbl (make-hash-table 31))
(hash-create-handle! stt-curr "string-indexes" stt-idx-tbl)
(hash-create-handle! stt-curr "current-index"  0)
""
)))
(define string-table-add (lambda (st-name str-val) (begin
(set! stt-curr    (hash-ref stt-table   st-name))
(set! stt-idx-tbl (hash-ref stt-curr    "string-indexes"))
(set! stt-idx     (hash-ref stt-idx-tbl str-val))
(if (not (number? stt-idx))
(begin
(set! stt-idx (hash-ref stt-curr "current-index"))
(ag-fprintf st-name "/* %5d */ %s \"\\0\"\n"
stt-idx (c-string str-val))
(hash-create-handle! stt-idx-tbl str-val stt-idx)
(hash-set! stt-curr "current-index"
(+ stt-idx (string-length str-val) 1))
))
stt-idx
)))
(define string-table-add-ref (lambda (st-name str-val)
(string-append st-name "+"
(number->string (string-table-add st-name str-val)))))
(define emit-string-table (lambda (st-name) (begin
(set! stt-curr (hash-ref stt-table   st-name))
(set! stt-idx  (hash-ref stt-curr "current-index"))
(ag-fprintf 0 "\nstatic char const %s[%d] =\n" st-name stt-idx)
(out-resume st-name)
(emit (shell (string-append
"sed 's/^ /      /
$s/\" \"\\\\0\"/\";/
s/\" \"\\\\0/\\\\0/
' <<\\_EOF_\n"
(out-pop #t)
"_EOF_")))
(emit "\n")
)))
(define string-table-size (lambda (st-name)
(hash-ref (hash-ref stt-table st-name) "current-index")))
(define gperf-code (lambda (gp-name) (shellf
"sed -e '1,/^#line/d' \
-e '/#include/d' \
-e '/#line/d' \
-e '/^[ \t]*$/d' \
-e 's/^const struct /static const struct /' \
-e '/^int main(/,$d' ${gpdir}/%s.c"
gp-name
)))
(define stack-join (lambda (j-str ag-name)
(join j-str (stack ag-name))))
(version) scm_string_length returned wrong value: %d != %d
 
Guile/Scheme evaluation error in %s line %d:  %s
 #f ... re-read output (*)() #t %s%s shell_cmd result is NULL ERROR:  Cannot pop output with no output pushed
 SERVER RESTART:  serv_id is NULLPROCESS
 cannot allocate path name (set! tmp-dir "%1$s")
(add-cleanup "test \"${VERBOSE:-false}\" = true || rm -rf %1$s") Warning: (set-writable) function in %s on line %d:
	overridden by invocation option
 cd %s
%s

echo
echo %s - %d
 Closing server:  %s signal (%d) received
 exec 8>&2 2>/dev/null

if test -n "${ZSH_VERSION+set}" && (emulate sh) 1>&2
then
  emulate sh
  NULLCMD=:

else case `set -o` in *posix*) set -o posix ;; esac
fi

trap_exit() {
    case "$1" in
    0 | 10 | 15 )
        exec 1>&- 2>&-
        test -d "${tmp_dir}" && rm -rf "${tmp_dir}"
        ;;

    * )
        exec 1>&8
        echo "trapped on signal ${1}"
        test -d "${tmp_dir}" && \
            echo "temp directory has been retained:  ${tmp_dir}"
    esac
}

die() {
  echo "Killing AutoGen ${AG_pid}"
  echo "FAILURE REASON:  $*"
  kill -15 ${AG_pid}
  sleep 1
  kill -1  ${AG_pid}
  sleep 1
  kill -2  ${AG_pid}
  sleep 1
  kill -9  ${AG_pid}
  exit 1
} >&8

mk_tmp_dir() {
  test -d "${tmp_dir}" && return 0
  tmp_dir=`
    t=\`mktemp -d ${TMPDIR}/.ag-XXXXXX\`
    test -d "${t}" || {
      t=${TMPDIR}/.ag-$$
      rm -rf ${t}
      mkdir ${t} || die cannot mkdir ${t}
    }
    chmod 700 ${t} || die cannot chmod 700 ${t}
    echo ${t}
    ` 2>/dev/null
}

for f in 0 1 2 5 6 7 10 13 14 15
do trap "trap_exit ${f}" $f ; done
test -n "${CDPATH}" && {
  CDPATH=''
  unset CDPATH
}
( unalias cd ) && unalias cd
( set +v     ) && set +v
test -z "${TMPDIR}" && TMPDIR=/tmp
tmp_dir=''
export AG_pid TMPDIR
AG_pid="%u"
AGexe='%s'

exec 2>&8 
Last command issued:
 feof on data load
 
Server Restart
 (result discarded)
 PS4=>${FUNCNAME:-ag}>  fs err %d (%s) reading from server shell
 set -x
trap
echo server setup done
 ShElL-OuTpUt-HaS-bEeN-cOmPlEtEd # Makefile dependency file created by:		-*- Mode: Makefile -*-
# %s
# with the following command line arguments:
 #   %s fopen for write '( strdup of %d byte string failed
 cannot map unprintable chars to C name chars ag_scm_string_to_c_name_x Server shell timed out 5 times syscall 	from %s line %d
 .d-XXXXXX template add source dep:  %s
 add target dep:  %s
 Template macro %s invoked with %d args
 Warning in template %s, line %d
	%s
 Adding '%s' to environment
 CASE string `%s' did not match
 CASE string `%s' %s matched `%s'
 CASE no match: `%s' %s vs. `%s'
  '%s' eval for arg %d:
	`%s'
 marker '%s' loaded
 Definition Load:
  in "%s" --  FOR %s repeated %d times
 eval from file %s line %d:
%s
 FOR %s loop in %s on line %d begins:
 FOR loop skipped - no definition for `%s'
 IF expression `%s' on line %d yielded true
 IF `%s' macro selected no clause
 Template %s included
 	based on %s
 Expr Invoke remapped to '%s' (%2X) in %s at line %d
 WHILE macro repeated %d times
 WHILE `%s' loop in %s on line %d begins:
 	exiting FOR %s from %d to %d by %d:
	more than %d iterations
 too many FOR iterations in %s line %d
 Defining macro %s from %s
 %-10s (%2X) in %s at line %d
 Compiling '%s' with bits 0x%lX
 
= = = RESULT %d bytes:
%s%s
= = = = = = = = = = = = = = =
 
Guile Library Version %s
 searching for `%s' %s %s to %s
 %s '%s' mode %s
 NOTE:  skipping file '%s'
 %s -- temp file %s
 %s from %s to '%s'
 %s %s%s
 %s %s from '%s'
 remove source dep:  %s
 remove target dep:  %s
 
Server First Start
 Server shell is pid %u
 Server shell %s starts
 

===AutoGen starts - %u:  %s %s %s as '%s'
 Trap state:
%s
 	code %lX -- %s
 0x%016llX <<== '%s'
 Server traps set
 true uname(2) invalid make dependency option:  %s echo 'definition names looked up'
sed 's/[-^]/-/g'|sort -u -f
echo 'end of looked up definitions' %s
 WARNING: %s
 Warning format yes '%s'
 %s:  in %s on line %d
	token in error:  %s
	[[...<error-text>]] %s

Likely causes:  a mismatched quote, a value that needs quoting,
		or a missing semi-colon
 %s:  ''%s''
 unterminated quote in definition "ag-text.c\0"
/*    10 */ "The '%d' address family cannot be handled\0"
/*    52 */ "%s__\0"
/*    57 */ "%s=1\0"
/*    62 */ "ABEND-ing in %s state\n\0"
/*    85 */ "processing template %s\n"
            "            on line %d\n"
            "       for function %s (%d)\n\0"
/*   160 */ "ag-fprintf: 'port' is invalid\0"
/*   190 */ "AUTOGEN_MAKE_DEP\0"
/*   207 */ "autogen5\0"
/*   216 */ "AutoGen caught signal %d (%s) before initialization completed\n\0"
/*   279 */ "AutoGen aborting on signal %d (%s) in state %s\n\0"
/*   327 */ "Scheme definition expression does not yield string:\n\0"
/*   380 */ "Scheme Computed Definitions\0"
/*   408 */ "(alist->autogen-def %s)\0"
/*   432 */ "could not allocate for or formatting failed on:\n"
            "%s\0"
/*   483 */ "asprintfv returned 0x%08X\n\0"
/*   510 */ "%s Error: Invalid input char '%c' in %s on line %d\n\0"
/*   562 */ "Cannot %s from outside a loop\0"
/*   592 */ "Could not resolve macro name: '%s'\0"
/*   627 */ "??? indecipherable error message ???\0"
/*   664 */ "Ill formed name '%s' in %s line %d\n\0"
/*   700 */ "Invalid regular expression:  error %d (%s):\n"
            "%s\0"
/*   747 */ "--base-name name is too long\0"
/*   776 */ "** BOGUS **\0"
/*   788 */ "break\0"
/*   794 */ "%lu\0"
/*   798 */ "fserr %d: cannot %s %s:  %s\n\0"
/*   827 */ "duplicate make target\0"
/*   849 */ "unknown dependency type:  %s\0"
/*   878 */ "Content-type: text/plain\n\n"
            "AutoGen form processing error:\n\0"
/*   936 */ "CGI parsing error:  %s\0"
/*   959 */ "/tmp/cgi-stderr-XXXXXX\0"
/*   982 */ "CLOSING SHELL SERVER - command failure:\n"
            "\t%s\n\0"
/*  1027 */ "%s Error:  %s in %s on line %d\n\0"
/*  1059 */ "DEFINITIONS %s in %s line %d for %s:\n"
            "\t%s\n\0"
/*  1101 */ "Bad regular expression\0"
/*  1124 */ "continue\0"
/*  1133 */ "\\n\"\n"
            "       \"\0"
/*  1146 */ "from %s line %d\0"
/*  1162 */ "block\0"
/*  1168 */ "INVALID\0"
/*  1176 */ "text\0"
/*  1181 */ "unknown\0"
/*  1189 */ " \\\n\0"
/*  1193 */ "\n"
            ".PHONY : clean-%1$s\n\n"
            "clean-%1$s :\n"
            "\trm -f %3$s $(%2$s_TList)\n"
            "\t@-touch -t 199912312359 %1$s\n\0"
/*  1285 */ "\n"
            "%2$s : $(%1$s_SList)\n\n"
            "$(%1$s_TList) : %2$s\n"
            "\t@:\n\0"
/*  1334 */ " \\\n"
            "\t%s\0"
/*  1341 */ "DEPENDENCIES_OUTPUT\0"
/*  1361 */ "\n\n"
            "%s_SList =\0"
/*  1374 */ "%s_TList =\0"
/*  1385 */ "/dev/null\0"
/*  1395 */ "baseless\0"
/*  1404 */ "-\0"
/*  1406 */ "=1\0"
/*  1409 */ "$@\0"
/*  1412 */ "$$/../share/autogen\0"
/*  1432 */ "\n"
            "#\0"
/*  1435 */ "#assert yielded \"%s\":\n"
            "\t`%s`\0"
/*  1463 */ "'#%s' directive encountered out of context\n"
            "\tin %s on line %d\n\0"
/*  1525 */ "#error directive -- in %s on line %d\n"
            "\t%s\n\0"
/*  1567 */ "open\0"
/*  1572 */ "read\0"
/*  1577 */ "def\0"
/*  1581 */ "WARNING: fserr %d (%s) performing '%s' on %s\n\0"
/*  1627 */ "Definition error:  in %s line %d, #endif not found\n\0"
/*  1679 */ "Definition error:  in %s line %d, #%s no matching start/if directive\n\0"
/*  1749 */ "Missing #endshell after '#shell' in %s on line %d\n\0"
/*  1800 */ "Computed Definitions\0"
/*  1821 */ "\n"
            "#endshell\0"
/*  1832 */ "done_check done\n\0"
/*  1849 */ "done_check re-done\n\0"
/*  1869 */ "%s.%s\0"
/*  1875 */ "\n\n\0"
/*  1878 */ "%s ERROR:  Too many definition files\n\0"
/*  1916 */ "%soutput was abandoned\n\0"
/*  1940 */ "%sBogus return from setjmp\n\0"
/*  1968 */ "content-type: text/html\n\n\0"
/*  1994 */ "* NONE *\0"
/*  2003 */ "Starting stdout template\n\0"
/*  2029 */ "stdout\0"
/*  2036 */ "invalid chars in suffix format:  %s\0"
/*  2072 */ "Empty suffix format\0"
/*  2092 */ "Duplicate value index for %s:  %d\0"
/*  2126 */ "#elif directive found out of context\0"
/*  2163 */ "invalid emission port: %lu\0"
/*  2190 */ "*/\0"
/*  2193 */ "ERROR\0"
/*  2199 */ "Error in template %s, line %d\n"
            "\t\0"
/*  2231 */ "attempted to use block macro in eval expression\0"
/*  2279 */ "PROGRAM ERROR:  ambiguous expr code\0"
/*  2315 */ "exit_cleanup %s done\n"
            "===AutoGen ends - %u\n\n\0"
/*  2359 */ "false\0"
/*  2365 */ "exit_cleanup re-done\n\0"
/*  2387 */ "no waiting\0"
/*  2398 */ "(if (> (string-length shell-cleanup) 0) (shellf \"( (%s) & >/dev/null 2>&1 )\" shell-cleanup) )\0"
/*  2492 */ "waited\0"
/*  2499 */ "an unknown license\0"
/*  2518 */ "%6$s%1$sDO NOT EDIT THIS FILE   (%2$s)\n"
            "%1$s\n"
            "%1$sIt has been AutoGen-ed%3$s\n"
            "%1$sFrom the definitions    %4$s\n"
            "%1$sand the template file   %5$s\0"
/*  2659 */ "%s -*- buffer-read-only: t -*- vi: set ro:\n"
            "%s\n\0"
/*  2706 */ "%6$s%1$sEDIT THIS FILE WITH CAUTION  (%2$s)\n"
            "%1$s\n"
            "%1$sIt has been AutoGen-ed%3$s\n"
            "%1$sFrom the definitions    %4$s\n"
            "%1$sand the template file   %5$s\0"
/*  2852 */ "WARNING:  in %s on line %d unknown directive:\n"
            "\t#%s\n\0"
/*  2904 */ "DO NOT CHANGE THIS COMMENT\0"
/*  2931 */ "name not followed by '='\0"
/*  2956 */ "no space separating entries\0"
/*  2984 */ "END  \0"
/*  2990 */ "START\0"
/*  2996 */ "# %2$d \"%1$s\"\0"
/*  3010 */ "failed\n\0"
/*  3018 */ "SUCCESS\n\0"
/*  3027 */ ".\0"
/*  3029 */ "%s/%s\0"
/*  3035 */ "find-file\0"
/*  3045 */ "agpl\0"
/*  3050 */ "read full file\0"
/*  3065 */ "invalid license file: %s\0"
/*  3090 */ "lgpl\0"
/*  3095 */ "mbsd\0"
/*  3100 */ "stat file\0"
/*  3110 */ "lic\0"
/*  3114 */ "macros cannot nest\0"
/*  3133 */ "macro has no end\0"
/*  3150 */ "WARNING: empty macro in %s line %d\n\0"
/*  3186 */ "  --  DEBUG %s -- FOR index %d\0"
/*  3217 */ "%d (%s) is an unknown macro function, or has no handler\0"
/*  3273 */ "? Say, what ?\0"
/*  3287 */ " (%c)\0"
/*  3293 */ "ELSE clause\0"
/*  3305 */ "FOR x IN ... has no list\0"
/*  3330 */ "_GUARD\0"
/*  3337 */ "  -  FOR-%s %s[%d] it#%d: Nxt %d, first=%s, last=%s\n\0"
/*  3390 */ "'get' invoked with no name in %s line %u\n\0"
/*  3432 */ "'get %s' retrieved in %s line %u\n\0"
/*  3466 */ "Failing Guile command:  = = = = =\n\n"
            "%s\n\n"
            "=================================\n\0"
/*  3540 */ "Could not decipher Guile version: %s\n\0"
/*  3578 */ "Compiled Guile version does not match: %s vs %s\n\0"
/*  3627 */ "GUILE_WARN_DEPRECATED\0"
/*  3649 */ "GUILE_WARN_DEPRECATED=no\0"
/*  3674 */ "els\0"
/*  3678 */ "the\0"
/*  3682 */ "Invalid template file\0"
/*  3704 */ "SHELL=\0"
/*  3711 */ "lse\0"
/*  3715 */ "ndif\0"
/*  3720 */ "fdef \0"
/*  3726 */ "fndef \0"
/*  3733 */ "HEADER\0"
/*  3740 */ "Unterminated HereString\0"
/*  3764 */ "HereString missing the mark\0"
/*  3792 */ "&#%d;\0"
/*  3798 */ "(debug-enable 'backtrace)\0"
/*  3824 */ "HereString mark 64 or more chars\0"
/*  3857 */ "');\n"
            "document.write('\" >%s</a>');\n"
            "//-->\n"
            "</script>\0"
/*  3906 */ "<script language=\"JavaScript\" type=\"text/javascript\">\n"
            "<!--\n"
            "var one = 'm&#97;';\n"
            "var two = 'i&#108;t';\n"
            "document.write('<a href=\"' + one + two );\n"
            "document.write('&#111;:\0"
/*  4073 */ "(use-modules (%s)) (read-enable 'positions)\n"
            "(add-hook! before-error-hook error-source-line)\n"
            "(use-modules (ice-9 stack-catch))\0"
/*  4199 */ "Unknown macro or invalid context in %s line %d:\n"
            "\t%s%s\0"
/*  4253 */ "FOR macro requires iterator name\0"
/*  4286 */ "The INCLUDE macro requires a file name\0"
/*  4325 */ "\\n\\\n\0"
/*  4330 */ "LC_ALL=C\0"
/*  4339 */ "ESAC not found\0"
/*  4354 */ "expressionless CASE\0"
/*  4374 */ "DEFINE requires a name\0"
/*  4397 */ "parse ended unexpectedly\0"
/*  4422 */ "Invalid definition name\0"
/*  4446 */ "`?' needs two expressions\0"
/*  4472 */ "No space between expressions\0"
/*  4501 */ "No text for unfound value\0"
/*  4527 */ "in\0"
/*  4530 */ "invalid FOR loop variable\0"
/*  4556 */ "ENDFOR not found\0"
/*  4573 */ "ENDIF not found\0"
/*  4589 */ "LD_LIBRARY_PATH=\0"
/*  4606 */ "LD_LIBRARY_PATH\0"
/*  4622 */ "Empty macro text\0"
/*  4639 */ "Invalid selection clause\0"
/*  4664 */ "ENDWHILE not found\0"
/*  4683 */ "expressionless WHILE\0"
/*  4704 */ "%s\n"
            "%s\n"
            "%s\0"
/*  4713 */ "@@ CGI Definitions @@\0"
/*  4735 */ "GET\0"
/*  4739 */ "No CGI data were received\0"
/*  4765 */ "CGI text\0"
/*  4774 */ "map data file\0"
/*  4788 */ "Could not open template '%s'\0"
/*  4817 */ "not regular file\0"
/*  4834 */ "agl\0"
/*  4838 */ "tpl\0"
/*  4842 */ " ; \\\n\0"
/*  4848 */ "in-mem file\0"
/*  4860 */ "mkstemp failed on `%s'\0"
/*  4883 */ "to port %s with %d type address\0"
/*  4915 */ "invalid CGI request method: ''%s''\0"
/*  4950 */ "Cannot expand directory name:  '%s'\0"
/*  4986 */ "Template parse ended unexpectedly\0"
/*  5020 */ "end of Guile/scheme expression not found\0"
/*  5061 */ "\n\n"
            "* * * * LOG ENTRY %d * * * *\n\0"
/*  5093 */ "(add-cleanup \"rm -rf ${gpdir}\")\0"
/*  5125 */ "malloc of %zd bytes failed\n\0"
/*  5153 */ "gperf --version > /dev/null 2>&1 || die 'no gperf program'\n"
            "test -z ${gpdir} && {\n"
            "  gpdir=`mktemp -d ./.gperf.XXXXXX` 2>/dev/null\n"
            "  test -z \"${gpdir}\" && gpdir=.gperf.$$\n"
            "  test -d ${gpdir} || mkdir ${gpdir} || die \"cannot mkdir ${gpdir}\"\n"
            "}\n"
            "cd ${gpdir} || die cannot cd into ${gpdir}\n"
            "gpdir=`pwd`\n"
            "gperf_%2$s=${gpdir}/%2$s\n\n"
            "{\n"
            "  cat << \\_EOF_\n"
            "%%{\n"
            "#include <stdio.h>\n"
            "%%}\n"
            "struct %2$s_index { char const * name; int const idx; };\n"
            "%%%%\n"
            "_EOF_\n\n"
            "  idx=1\n"
            "  while read f\n"
            "  do echo \"${f}, ${idx}\"\n"
            "     idx=`expr ${idx} + 1`\n"
            "  done << \\_EOLIST_\n"
            "%3$s\n"
            "_EOLIST_\n\n"
            "  cat << \\_EOF_\n"
            "%%%%\n"
            "int main(int argc, char ** argv) {\n"
            "    char * pz = argv[1];\n"
            "    struct %2$s_index const * pI = %2$s_find( pz, strlen( pz ));\n"
            "    if (pI == NULL)\n"
            "        return 1;\n"
            "    printf( \"0x%%02X\\n\", pI->idx );\n"
            "    return 0;\n"
            "}\n"
            "_EOF_\n"
            "} > %2$s.gperf\n\n"
            "exec 2> %2$s.log\n"
            "gperf --language=ANSI-C -H %2$s_hash -N %2$s_find \\\n"
            "      -C -E -I -t %2$s.gperf > %2$s-temp.c || \\\n"
            "   die \"gperf failed on ${gpdir}/%2$s.gperf\n"
            "      `cat %2$s.log`\"\n"
            "egrep -v '^[^#].*_inline' %2$s-temp.c > %2$s.c\n"
            "export CFLAGS=-g\n"
            "%1$s %2$s 1>&2\n"
            "test $? -eq 0 -a -x ${gperf_%2$s} || \\\n"
            "  die \"could not '%1$s %2$s' gperf program\n"
            "      `cat %2$s.log`\"\n"
            "exec 2>&8\0"
/*  6331 */ "(define header-file \"%s\") (define header-guard \"%s\")\0"
/*  6384 */ "Could not open license file '%s'\0"
/*  6417 */ "mk_tmp_dir ; echo ${tmp_dir}/ag-XXXXXX\0"
/*  6456 */ "#ifndef %1$s\n"
            "#define %1$s 1\0"
/*  6484 */ "%s may not exceed %d chars\n\0"
/*  6512 */ "owner length\0"
/*  6525 */ "prefix length\0"
/*  6539 */ "program name length\0"
/*  6559 */ "license name is not a string\0"
/*  6588 */ "There is no %s license.\0"
/*  6612 */ "<owner>\0"
/*  6620 */ "<PFX>\0"
/*  6626 */ "<program>\0"
/*  6636 */ "<years>\0"
/*  6644 */ "no macro arg name\0"
/*  6662 */ "\n\0"
/*  6664 */ "Invalid template file: %s\0"
/*  6690 */ "ERROR: %s is not a string\n\0"
/*  6717 */ "expressionless IF\0"
/*  6735 */ "no\0"
/*  6738 */ "no template was specified\0"
/*  6764 */ "NULL file name\0"
/*  6779 */ "null\0"
/*  6784 */ "open for output\0"
/*  6800 */ "unlink\0"
/*  6807 */ "* temp file *\0"
/*  6821 */ "On macro argument # %d:\n"
            "%s\n\0"
/*  6849 */ "Cannot format file name:  \"%s\", %s, %s\0"
/*  6888 */ "No output file specified to add to\0"
/*  6923 */ "failed to create temp file from %s\0"
/*  6958 */ "ERROR: no output file was suspended as '%s'\n\0"
/*  7003 */ "ERROR:  Cannot pop output with no output pushed\0"
/*  7051 */ "%s '%s'\n\0"
/*  7060 */ "open 'wb+'\0"
/*  7071 */ "freopen\0"
/*  7079 */ "Autogen Definitions cgi;\n\0"
/*  7105 */ "AF_UNIX path exceeds %d\0"
/*  7129 */ "stdin\0"
/*  7135 */ "dup2\0"
/*  7140 */ "%s-in\0"
/*  7146 */ "%s-out\0"
/*  7153 */ "fork\0"
/*  7158 */ "mkfifo\0"
/*  7165 */ "poll\0"
/*  7170 */ "write\0"
/*  7176 */ "Invalid port number:  '%s'\0"
/*  7203 */ "Starting %s template\n\0"
/*  7225 */ "pseudo-macro\0"
/*  7238 */ "BROKEN FSM STATE\0"
/*  7255 */ "The INVOKE macro requires a name\0"
/*  7288 */ "The INVOKE macro name not space separated\0"
/*  7330 */ "%s%s[%u] (%s) from %s/%d at %p\n\0"
/*  7362 */ "                                \0"
/*  7395 */ "start marker contained in end marker\0"
/*  7432 */ "start/end macro mark too long\0"
/*  7462 */ "end marker contained in start marker\0"
/*  7499 */ "bad template marker in %s on line %d:\n"
            "\t%s\0"
/*  7541 */ "invalid edit mode marker\0"
/*  7566 */ "need autogen5 marker\0"
/*  7587 */ "need end marker\0"
/*  7603 */ "need end of line\0"
/*  7620 */ "need start marker\0"
/*  7638 */ "need template marker\0"
/*  7659 */ "broken pseudo-macro FSM\0"
/*  7683 */ "-*-\0"
/*  7687 */ "*template file*\0"
/*  7703 */ "@@ No-Definitions @@\0"
/*  7724 */ "open non-regular file\0"
/*  7746 */ "stat\0"
/*  7751 */ "No definition data were read\0"
/*  7780 */ "REQUEST_METHOD\0"
/*  7795 */ "** EXACT **\0"
/*  7807 */ "** INEXACT **\0"
/*  7821 */ "** LIST **\0"
/*  7832 */ "** Pair **\0"
/*  7843 */ "** Procedure 0x%08lX **\0"
/*  7867 */ "** UNKNOWN **\0"
/*  7881 */ "** Vector **\0"
/*  7894 */ "RETURN out of context\0"
/*  7916 */ "realloc of %zd bytes at 0x%p failed\n\0"
/*  7953 */ "attempt to remove unrecorded def entry\n\0"
/*  7993 */ "test -n \"${gperf_%1$s}\" || \\\n"
            "    die 'no environment variable \"gperf_%1$s\"'\n"
            "test -x \"${gperf_%1$s}\" || \\\n"
            "    die \"no gperf program named  ${gperf_%1$s}\"\n"
            "${gperf_%1$s} %2$s\0"
/*  8165 */ "%s ERROR:  %s processing printf format:\n"
            "\t%s\n\0"
/*  8210 */ "Bad args to sprintf\0"
/*  8230 */ "ice-9 debug\0"
/*  8242 */ "system vm trace\0"
/*  8258 */ "Scheme evaluation error.  AutoGen ABEND-ing in template\n"
            "\t%s on line %d\n\0"
/*  8330 */ "(use-modules (ice-9 common-list))\n"
            "(define identifier?\n"
            "(lambda (x) (or (string? x) (symbol? x))))\n"
            "(define normalize-identifier\n"
            "(lambda (x)\n"
            "(if (string? x) (string->symbol x) x)))\n"
            "(define coerce->string\n"
            "(lambda (x)\n"
            "(let ((char->string (lambda (x) (make-string 1 x)))\n"
            "(coercable? (lambda (x)\n"
            "(or (string? x) (boolean? x) (char? x)\n"
            "(symbol? x) (list? x) (number? x)))))\n"
            "(if (not (coercable? x))\n"
            "(error \"Wrong type to coerce->string\" x))\n"
            "(cond\n"
            "((string? x)  (string-append\n"
            "(char->string #\\\") x (char->string #\\\")))\n"
            "((boolean? x) (if x \"#t\" \"#f\"))\n"
            "((char? x)    (char->string x))\n"
            "((number? x)  (number->string x))\n"
            "((symbol? x)  (symbol->string x))\n"
            "((list? x)    (if (every coercable? x)\n"
            "(apply string-append (map coerce->string x))))\n"
            "))))\n"
            "(define alist->autogen-def\n"
            "(lambda (lst . recursive)\n"
            "(if (null? recursive) (set! recursive #f)\n"
            "(set! recursive #t))\n"
            "(let ((res (if recursive \"{\\n\" \"\"))\n"
            "(list-nnul? (lambda (x) (and (list? x) (not (null? x))))))\n"
            "(do ((i lst (cdr i)))\n"
            "((null? i) (if recursive\n"
            "(string-append res \"}\")\n"
            "res))\n"
            "(let* ((kvpair (car i))\n"
            "(value (cdr kvpair))\n"
            "(value-is-alist (if (and (list-nnul? value)\n"
            "(list-nnul? (car value))\n"
            "(list-nnul? (caar value))\n"
            "(identifier? (caaar value)))\n"
            "#t #f)))\n"
            "(set! res (string-append res\n"
            "(coerce->string (normalize-identifier (car kvpair)))\n"
            "\" = \"\n"
            "(if value-is-alist\n"
            "(alist->autogen-def (car value) 1)\n"
            "(coerce->string (cdr kvpair)))\n"
            "\";\\n\"\n"
            ")))))))\n"
            "(define shell-cleanup \"\")\n"
            "(define add-cleanup (lambda (t)\n"
            "(set! shell-cleanup (string-append shell-cleanup \"\\n\" t \"\\n\"))))\n"
            "(define tmp-dir \"\")\n"
            "(define header-file     \"\")\n"
            "(define header-guard    \"\")\n"
            "(define autogen-version \"5.18.7\")\n"
            "(define c-file-line-fmt \"#line %2$d \\\"%1$s\\\"\\n\")\n"
            "(define-macro (defined-as predicate symbol)\n"
            "`(and (defined? ',symbol) (,predicate ,symbol)))\n"
            "(catch #t\n"
            "(lambda () (read-enable 'curly-infix))\n"
            "(lambda args #f))\n"
            "(define html-escape-encode (lambda (str)\n"
            "(string-substitute str\n"
            "'(\"&\"      \"<\"     \">\")\n"
            "'(\"&amp;\"  \"&lt;\"  \"&gt;\"))))\n"
            "(define stt-table   (make-hash-table 31))\n"
            "(define stt-curr    stt-table)\n"
            "(define stt-idx-tbl stt-table)\n"
            "(define stt-idx     0)\n"
            "(define insert-suspended (lambda (susp-name) (begin\n"
            "(out-resume susp-name) (out-pop #t))))\n"
            "(define string-table-new (lambda (st-name) (begin\n"
            "(set! stt-curr (make-hash-table 31))\n"
            "(hash-create-handle! stt-table st-name stt-curr)\n"
            "(out-push-new)\n"
            "(out-suspend st-name)\n"
            "(set! stt-idx-tbl (make-hash-table 31))\n"
            "(hash-create-handle! stt-curr \"string-indexes\" stt-idx-tbl)\n"
            "(hash-create-handle! stt-curr \"current-index\"  0)\n"
            "\"\"\n"
            ")))\n"
            "(define string-table-add (lambda (st-name str-val) (begin\n"
            "(set! stt-curr    (hash-ref stt-table   st-name))\n"
            "(set! stt-idx-tbl (hash-ref stt-curr    \"string-indexes\"))\n"
            "(set! stt-idx     (hash-ref stt-idx-tbl str-val))\n"
            "(if (not (number? stt-idx))\n"
            "(begin\n"
            "(set! stt-idx (hash-ref stt-curr \"current-index\"))\n"
            "(ag-fprintf st-name \"/* %5d */ %s \\\"\\\\0\\\"\\n\"\n"
            "stt-idx (c-string str-val))\n"
            "(hash-create-handle! stt-idx-tbl str-val stt-idx)\n"
            "(hash-set! stt-curr \"current-index\"\n"
            "(+ stt-idx (string-length str-val) 1))\n"
            "))\n"
            "stt-idx\n"
            ")))\n"
            "(define string-table-add-ref (lambda (st-name str-val)\n"
            "(string-append st-name \"+\"\n"
            "(number->string (string-table-add st-name str-val)))))\n"
            "(define emit-string-table (lambda (st-name) (begin\n"
            "(set! stt-curr (hash-ref stt-table   st-name))\n"
            "(set! stt-idx  (hash-ref stt-curr \"current-index\"))\n"
            "(ag-fprintf 0 \"\\nstatic char const %s[%d] =\\n\" st-name stt-idx)\n"
            "(out-resume st-name)\n"
            "(emit (shell (string-append\n"
            "\"sed 's/^ /      /\n"
            "$s/\\\" \\\"\\\\\\\\0\\\"/\\\";/\n"
            "s/\\\" \\\"\\\\\\\\0/\\\\\\\\0/\n"
            "' <<\\\\_EOF_\\n\"\n"
            "(out-pop #t)\n"
            "\"_EOF_\")))\n"
            "(emit \"\\n\")\n"
            ")))\n"
            "(define string-table-size (lambda (st-name)\n"
            "(hash-ref (hash-ref stt-table st-name) \"current-index\")))\n"
            "(define gperf-code (lambda (gp-name) (shellf\n"
            "\"sed -e '1,/^#line/d' \\\n"
            "-e '/#include/d' \\\n"
            "-e '/#line/d' \\\n"
            "-e '/^[ \\t]*$/d' \\\n"
            "-e 's/^const struct /static const struct /' \\\n"
            "-e '/^int main(/,$d' ${gpdir}/%s.c\"\n"
            "gp-name\n"
            ")))\n"
            "(define stack-join (lambda (j-str ag-name)\n"
            "(join j-str (stack ag-name))))\n"
            "(version)\0"
/* 12258 */ "scm_string_length returned wrong value: %d != %d\n\0"
/* 12308 */ "\n"
            "Guile/Scheme evaluation error in %s line %d:  %s\n\0"
/* 12359 */ "#f\0"
/* 12362 */ "...\0"
/* 12366 */ "re-read output\0"
/* 12381 */ "(*)()\0"
/* 12387 */ "#t\0"
/* 12390 */ "%s%s\0"
/* 12395 */ "shell_cmd result is NULL\0"
/* 12420 */ "ERROR:  Cannot pop output with no output pushed\n\0"
/* 12469 */ "SERVER RESTART:  serv_id is NULLPROCESS\n\0"
/* 12510 */ "cannot allocate path name\0"
/* 12536 */ "(set! tmp-dir \"%1$s\")\n"
            "(add-cleanup \"test \\\"${VERBOSE:-false}\\\" = true || rm -rf %1$s\")\0"
/* 12623 */ "Warning: (set-writable) function in %s on line %d:\n"
            "\toverridden by invocation option\n\0"
/* 12708 */ "cd %s\n"
            "%s\n\n"
            "echo\n"
            "echo %s - %d\n\0"
/* 12737 */ "Closing server:  %s signal (%d) received\n\0"
/* 12779 */ "exec 8>&2 2>/dev/null\n\n"
            "if test -n \"${ZSH_VERSION+set}\" && (emulate sh) 1>&2\n"
            "then\n"
            "  emulate sh\n"
            "  NULLCMD=:\n\n"
            "else case `set -o` in *posix*) set -o posix ;; esac\n"
            "fi\n\n"
            "trap_exit() {\n"
            "    case \"$1\" in\n"
            "    0 | 10 | 15 )\n"
            "        exec 1>&- 2>&-\n"
            "        test -d \"${tmp_dir}\" && rm -rf \"${tmp_dir}\"\n"
            "        ;;\n\n"
            "    * )\n"
            "        exec 1>&8\n"
            "        echo \"trapped on signal ${1}\"\n"
            "        test -d \"${tmp_dir}\" && \\\n"
            "            echo \"temp directory has been retained:  ${tmp_dir}\"\n"
            "    esac\n"
            "}\n\n"
            "die() {\n"
            "  echo \"Killing AutoGen ${AG_pid}\"\n"
            "  echo \"FAILURE REASON:  $*\"\n"
            "  kill -15 ${AG_pid}\n"
            "  sleep 1\n"
            "  kill -1  ${AG_pid}\n"
            "  sleep 1\n"
            "  kill -2  ${AG_pid}\n"
            "  sleep 1\n"
            "  kill -9  ${AG_pid}\n"
            "  exit 1\n"
            "} >&8\n\n"
            "mk_tmp_dir() {\n"
            "  test -d \"${tmp_dir}\" && return 0\n"
            "  tmp_dir=`\n"
            "    t=\\`mktemp -d ${TMPDIR}/.ag-XXXXXX\\`\n"
            "    test -d \"${t}\" || {\n"
            "      t=${TMPDIR}/.ag-$$\n"
            "      rm -rf ${t}\n"
            "      mkdir ${t} || die cannot mkdir ${t}\n"
            "    }\n"
            "    chmod 700 ${t} || die cannot chmod 700 ${t}\n"
            "    echo ${t}\n"
            "    ` 2>/dev/null\n"
            "}\n\n"
            "for f in 0 1 2 5 6 7 10 13 14 15\n"
            "do trap \"trap_exit ${f}\" $f ; done\n"
            "test -n \"${CDPATH}\" && {\n"
            "  CDPATH=''\n"
            "  unset CDPATH\n"
            "}\n"
            "( unalias cd ) && unalias cd\n"
            "( set +v     ) && set +v\n"
            "test -z \"${TMPDIR}\" && TMPDIR=/tmp\n"
            "tmp_dir=''\n"
            "export AG_pid TMPDIR\n"
            "AG_pid=\"%u\"\n"
            "AGexe='%s'\n\n"
            "exec 2>&8\0"
/* 14033 */ "\n"
            "Last command issued:\n\0"
/* 14056 */ "feof on data load\n\0"
/* 14075 */ "\n"
            "Server Restart\n\0"
/* 14092 */ "(result discarded)\n\0"
/* 14112 */ "PS4=>${FUNCNAME:-ag}> \0"
/* 14135 */ "fs err %d (%s) reading from server shell\n\0"
/* 14177 */ "set -x\n"
            "trap\n"
            "echo server setup done\n\0"
/* 14213 */ "ShElL-OuTpUt-HaS-bEeN-cOmPlEtEd\0"
/* 14245 */ "# Makefile dependency file created by:\t\t-*- Mode: Makefile -*-\n"
            "# %s\n"
            "# with the following command line arguments:\n\0"
/* 14359 */ "#   %s\0"
/* 14366 */ "fopen for write\0"
/* 14382 */ "'(\0"
/* 14385 */ "strdup of %d byte string failed\n\0"
/* 14418 */ "cannot map unprintable chars to C name chars\0"
/* 14463 */ "ag_scm_string_to_c_name_x\0"
/* 14489 */ "Server shell timed out 5 times\0"
/* 14520 */ "syscall\0"
/* 14528 */ "\tfrom %s line %d\n\0"
/* 14546 */ ".d-XXXXXX\0"
/* 14556 */ "template\0"
/* 14565 */ "add source dep:  %s\n\0"
/* 14586 */ "add target dep:  %s\n\0"
/* 14607 */ "Template macro %s invoked with %d args\n\0"
/* 14647 */ "Warning in template %s, line %d\n"
            "\t%s\n\0"
/* 14684 */ "Adding '%s' to environment\n\0"
/* 14712 */ "CASE string `%s' did not match\n\0"
/* 14744 */ "CASE string `%s' %s matched `%s'\n\0"
/* 14778 */ "CASE no match: `%s' %s vs. `%s'\n\0"
/* 14811 */ " '%s'\0"
/* 14817 */ "eval for arg %d:\n"
            "\t`%s'\n\0"
/* 14841 */ "marker '%s' loaded\n\0"
/* 14861 */ "Definition Load:\n\0"
/* 14879 */ " in \"%s\" -- \0"
/* 14892 */ "FOR %s repeated %d times\n\0"
/* 14918 */ "eval from file %s line %d:\n"
            "%s\n\0"
/* 14949 */ "FOR %s loop in %s on line %d begins:\n\0"
/* 14987 */ "FOR loop skipped - no definition for `%s'\n\0"
/* 15030 */ "IF expression `%s' on line %d yielded true\n\0"
/* 15074 */ "IF `%s' macro selected no clause\n\0"
/* 15108 */ "Template %s included\n\0"
/* 15130 */ "\tbased on %s\n\0"
/* 15144 */ "Expr\0"
/* 15149 */ "Invoke\0"
/* 15156 */ "remapped to '%s' (%2X) in %s at line %d\n\0"
/* 15197 */ "WHILE macro repeated %d times\n\0"
/* 15228 */ "WHILE `%s' loop in %s on line %d begins:\n\0"
/* 15270 */ "\texiting FOR %s from %d to %d by %d:\n"
            "\tmore than %d iterations\n\0"
/* 15333 */ "too many FOR iterations in %s line %d\n\0"
/* 15372 */ "Defining macro %s from %s\n\0"
/* 15399 */ "%-10s (%2X) in %s at line %d\n\0"
/* 15429 */ "Compiling '%s' with bits 0x%lX\n\0"
/* 15461 */ "\n"
            "= = = RESULT %d bytes:\n"
            "%s%s\n"
            "= = = = = = = = = = = = = = =\n\0"
/* 15521 */ "\n"
            "Guile Library Version %s\n\0"
/* 15548 */ "searching for `%s'\0"
/* 15567 */ "%s %s to %s\n\0"
/* 15580 */ "%s '%s' mode %s\n\0"
/* 15597 */ "NOTE:  skipping file '%s'\n\0"
/* 15624 */ "%s -- temp file %s\n\0"
/* 15644 */ "%s from %s to '%s'\n\0"
/* 15664 */ "%s %s%s\n\0"
/* 15673 */ "%s %s from '%s'\n\0"
/* 15690 */ "remove source dep:  %s\n\0"
/* 15714 */ "remove target dep:  %s\n\0"
/* 15738 */ "\n"
            "Server First Start\n\0"
/* 15759 */ "Server shell is pid %u\n\0"
/* 15783 */ "Server shell %s starts\n\0"
/* 15807 */ "\n\n"
            "===AutoGen starts - %u:  %s\0"
/* 15837 */ "%s %s as '%s'\n\0"
/* 15852 */ "Trap state:\n"
            "%s\n\0"
/* 15868 */ "\tcode %lX -- %s\n\0"
/* 15885 */ "0x%016llX <<== '%s'\n\0"
/* 15906 */ "Server traps set\n\0"
/* 15924 */ "true\0"
/* 15929 */ "uname(2)\0"
/* 15938 */ "invalid make dependency option:  %s\0"
/* 15974 */ "echo 'definition names looked up'\n"
            "sed 's/[-^]/-/g'|sort -u -f\n"
            "echo 'end of looked up definitions'\0"
/* 16072 */ "%s\n\0"
/* 16076 */ "WARNING: %s\n\0"
/* 16089 */ "Warning\0"
/* 16097 */ "format\0"
/* 16104 */ "yes\0"
/* 16108 */ "'%s'\n\0"
/* 16114 */ "%s:  in %s on line %d\n"
            "\ttoken in error:  %s\n"
            "\t[[...<error-text>]] %s\n\n"
            "Likely causes:  a mismatched quote, a value that needs quoting,\n"
            "\t\tor a missing semi-colon\n\0"
/* 16273 */ "%s:  ''%s''\n\0"
/* 16286 */ "unterminated quote in definition\0"
/* 16319 */ ""/* end of ag-text.c *//* 16319 *//* 16286 *//* 16273 *//* 16114 *//* 16108 *//* 16104 *//* 16097 *//* 16089 *//* 16076 *//* 16072 *//* 15974 *//* 15938 *//* 15929 *//* 15924 *//* 15906 *//* 15885 *//* 15868 *//* 15852 *//* 15837 *//* 15807 *//* 15783 *//* 15759 *//* 15738 *//* 15714 *//* 15690 *//* 15673 *//* 15664 *//* 15644 *//* 15624 *//* 15597 *//* 15580 *//* 15567 *//* 15548 *//* 15521 *//* 15461 *//* 15429 *//* 15399 *//* 15372 *//* 15333 *//* 15270 *//* 15228 *//* 15197 *//* 15156 *//* 15149 *//* 15144 *//* 15130 *//* 15108 *//* 15074 *//* 15030 *//* 14987 *//* 14949 *//* 14918 *//* 14892 *//* 14879 *//* 14861 *//* 14841 *//* 14817 *//* 14811 *//* 14778 *//* 14744 *//* 14712 *//* 14684 *//* 14647 *//* 14607 *//* 14586 *//* 14565 *//* 14556 *//* 14546 *//* 14528 *//* 14520 *//* 14489 *//* 14463 *//* 14418 *//* 14385 *//* 14382 *//* 14366 *//* 14359 *//* 14245 *//* 14213 *//* 14177 *//* 14135 *//* 14112 *//* 14092 *//* 14075 *//* 14056 *//* 14033 *//* 12779 *//* 12737 *//* 12708 *//* 12623 *//* 12536 *//* 12510 *//* 12469 *//* 12420 *//* 12395 *//* 12390 *//* 12387 *//* 12381 *//* 12366 *//* 12362 *//* 12359 *//* 12308 *//* 12258 *//*  8330 *//*  8258 *//*  8242 *//*  8230 *//*  8210 *//*  8165 *//*  7993 *//*  7953 *//*  7916 *//*  7894 *//*  7881 *//*  7867 *//*  7843 *//*  7832 *//*  7821 *//*  7807 *//*  7795 *//*  7780 *//*  7751 *//*  7746 *//*  7724 *//*  7703 *//*  7687 *//*  7683 *//*  7659 *//*  7638 *//*  7620 *//*  7603 *//*  7587 *//*  7566 *//*  7541 *//*  7499 *//*  7462 *//*  7432 *//*  7395 *//*  7362 *//*  7330 *//*  7288 *//*  7255 *//*  7238 *//*  7225 *//*  7203 *//*  7176 *//*  7170 *//*  7165 *//*  7158 *//*  7153 *//*  7146 *//*  7140 *//*  7135 *//*  7129 *//*  7105 *//*  7079 *//*  7071 *//*  7060 *//*  7051 *//*  7003 *//*  6958 *//*  6923 *//*  6888 *//*  6849 *//*  6821 *//*  6807 *//*  6800 *//*  6784 *//*  6779 *//*  6764 *//*  6738 *//*  6735 *//*  6717 *//*  6690 *//*  6664 *//*  6662 *//*  6644 *//*  6636 *//*  6626 *//*  6620 *//*  6612 *//*  6588 *//*  6559 *//*  6539 *//*  6525 *//*  6512 *//*  6484 *//*  6456 *//*  6417 *//*  6384 *//*  6331 *//*  5153 *//*  5125 *//*  5093 *//*  5061 *//*  5020 *//*  4986 *//*  4950 *//*  4915 *//*  4883 *//*  4860 *//*  4848 *//*  4842 *//*  4838 *//*  4834 *//*  4817 *//*  4788 *//*  4774 *//*  4765 *//*  4739 *//*  4735 *//*  4713 *//*  4704 *//*  4683 *//*  4664 *//*  4639 *//*  4622 *//*  4606 *//*  4589 *//*  4573 *//*  4556 *//*  4530 *//*  4527 *//*  4501 *//*  4472 *//*  4446 *//*  4422 *//*  4397 *//*  4374 *//*  4354 *//*  4339 *//*  4330 *//*  4325 *//*  4286 *//*  4253 *//*  4199 *//*  4073 *//*  3906 *//*  3857 *//*  3824 *//*  3798 *//*  3792 *//*  3764 *//*  3740 *//*  3733 *//*  3726 *//*  3720 *//*  3715 *//*  3711 *//*  3704 *//*  3682 *//*  3678 *//*  3674 *//*  3649 *//*  3627 *//*  3578 *//*  3540 *//*  3466 *//*  3432 *//*  3390 *//*  3337 *//*  3330 *//*  3305 *//*  3293 *//*  3287 *//*  3273 *//*  3217 *//*  3186 *//*  3150 *//*  3133 *//*  3114 *//*  3110 *//*  3100 *//*  3095 *//*  3090 *//*  3065 *//*  3050 *//*  3045 *//*  3035 *//*  3029 *//*  3027 *//*  3010 *//*  2996 *//*  2990 *//*  2984 *//*  2956 *//*  2931 *//*  2904 *//*  2852 *//*  2706 *//*  2659 *//*  2518 *//*  2499 *//*  2492 *//*  2398 *//*  2387 *//*  2365 *//*  2359 *//*  2315 *//*  2279 *//*  2231 *//*  2199 *//*  2193 *//*  2190 *//*  2163 *//*  2126 *//*  2092 *//*  2072 *//*  2036 *//*  2029 *//*  2003 *//*  1994 *//*  1968 *//*  1940 *//*  1916 *//*  1878 *//*  1875 *//*  1869 *//*  1849 *//*  1832 *//*  1821 *//*  1800 *//*  1749 *//*  1679 *//*  1627 *//*  1581 *//*  1577 *//*  1572 *//*  1567 *//*  1525 *//*  1463 *//*  1435 *//*  1432 *//*  1412 *//*  1409 *//*  1406 *//*  1404 *//*  1395 *//*  1385 *//*  1374 *//*  1361 *//*  1341 *//*  1334 *//*  1285 *//*  1193 *//*  1189 *//*  1181 *//*  1176 *//*  1168 *//*  1162 *//*  1133 *//*  1124 *//*  1101 *//*  1059 *//*  1027 *//*   982 *//*   959 *//*   936 *//*   878 *//*   849 *//*   827 *//*   798 *//*   794 *//*   788 *//*   776 *//*   747 *//*   700 *//*   664 *//*   627 *//*   592 *//*   562 *//*   510 *//*   483 *//*   432 *//*   408 *//*   380 *//*   327 *//*   279 *//*   216 *//*   190 *//*   160 *//*    85 *//*    62 *//*    57 *//*    52 *//*    10 *//*  -*- buffer-read-only: t -*- vi: set ro:
 *
 * DO NOT EDIT THIS FILE   (ag-text.c)
 *
 * It has been AutoGen-ed
 * From the definitions    /u/bkorb/ag/ag/agen5/ag-text.def
 * and the template file   strings
 *
 *  Copyright (C) 2011-2015 Bruce Korb, all rights reserved.
 *  This is free software. It is licensed for use, modification and
 *  redistribution under the terms of the
 *  Modified (3 clause) Berkeley Software Distribution License
 *  <http://www.xfree86.org/3.3.6/COPYRIGHT2.html>
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. Neither the name ``Bruce Korb'' nor the name of any other
 *     contributor may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 *  strings IS PROVIDED BY Bruce Korb ``AS IS'' AND ANY EXPRESS
 *  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 *  ARE DISCLAIMED.  IN NO EVENT SHALL Bruce Korb OR ANY OTHER CONTRIBUTORS
 *  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 *  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 *  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/agCgi.cparseInput(len * 2) + defLen + 1(len * 2) + (sizeof("Autogen Definitions cgi;\n") - 1) + 1"CGI Definitions"Autogen Definitions cgi;
char[26]7079defLenstrlen(pzRes)+1"CGI input"878"stderr file"959aprf(MKSTEMP_FAIL_FMT, cgi_stderr)aprf((ag_text_strtable+4860), cgi_stderr)4860tNameMap *pNMtNameMap[21]struct <unnamed>[21](tNameIdx)0NAME_CTsizeof(scan_ctx_t)"CGI ctx"textLentextLen + 1"CGI POST"aprf(CANNOT_FMT, errno, (ag_text_strtable+1572), (ag_text_strtable+4765), strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+1572), (ag_text_strtable+4765), strerror((*__errno_location ())))aprf(LOAD_CGI_INVAL_REQ_FMT, pzCgiMethod)aprf((ag_text_strtable+4915), nameValueMap[ REQUEST_METHOD_IDX ].pzValue)POST"POST"473915724765473549154713tNameIdxSERVER_SOFTWARE_IDXSERVER_NAME_IDXGATEWAY_INTERFACE_IDXSERVER_PROTOCOL_IDXSERVER_PORT_IDXREQUEST_METHOD_IDXPATH_INFO_IDXPATH_TRANSLATED_IDXSCRIPT_NAME_IDXQUERY_STRING_IDXREMOTE_HOST_IDXREMOTE_ADDR_IDXAUTH_TYPE_IDXREMOTE_USER_IDXREMOTE_IDENT_IDXCONTENT_TYPE_IDXCONTENT_LENGTH_IDXHTTP_ACCEPT_IDXHTTP_USER_AGENT_IDXHTTP_REFERER_IDXtNameMappzValuetNameMap[]nameValueMapSERVER_SOFTWARESERVER_NAMEGATEWAY_INTERFACESERVER_PROTOCOLSERVER_PORTPATH_INFOPATH_TRANSLATEDSCRIPT_NAMEQUERY_STRINGREMOTE_HOSTREMOTE_ADDRAUTH_TYPEREMOTE_USERREMOTE_IDENTCONTENT_TYPECONTENT_LENGTHHTTP_ACCEPTHTTP_USER_AGENTHTTP_REFERER(sizeof("Autogen Definitions cgi;\n") - 1)pzCgiLengthnameValueMap[ CONTENT_LENGTH_IDX ].pzValuepzCgiQuerynameValueMap[ QUERY_STRING_IDX ].pzValuepzCgiMethodnameValueMap[ REQUEST_METHOD_IDX ].pzValue_ET__ET_(n)n ## _IDX,{ #n, NULL },ENV_TABLE_ET_(SERVER_SOFTWARE) _ET_(SERVER_NAME) _ET_(GATEWAY_INTERFACE) _ET_(SERVER_PROTOCOL) _ET_(SERVER_PORT) _ET_(REQUEST_METHOD) _ET_(PATH_INFO) _ET_(PATH_TRANSLATED) _ET_(SCRIPT_NAME) _ET_(QUERY_STRING) _ET_(REMOTE_HOST) _ET_(REMOTE_ADDR) _ET_(AUTH_TYPE) _ET_(REMOTE_USER) _ET_(REMOTE_IDENT) _ET_(CONTENT_TYPE) _ET_(CONTENT_LENGTH) _ET_(HTTP_ACCEPT) _ET_(HTTP_USER_AGENT) _ET_(HTTP_REFERER)WARNING_WATCH/*
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/agCgi.c *//*
     *  Pull the CGI-relevant environment variables.  Anything we don't find
     *  gets an empty string default.
     *//*
     *  Redirect stderr to a file.  If it gets used, we must trap it
     *  and emit the content-type: preamble before actually emitting it.
     *  First, tho, do a simple stderr->stdout redirection just in case
     *  we stumble before we're done with this.
     *//**
 * @file agCgi.c
 *
 *  This is a CGI wrapper for AutoGen.  It will take POST-method
 *  name-value pairs and emit AutoGen definitions to a spawned
 *  AutoGen process.
 *
 *  This file is part of AutoGen.
 *  AutoGen Copyright (C) 1992-2015 by Bruce Korb - all rights reserved
 *
 * AutoGen is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AutoGen is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/agDep.cTMPDIR"TMPDIR"tmpdir_len/tmp"/tmp"1374flist_t *flist *13611285"xx"(TEMP_SUFFIX_LEN - 2)1193print_listR_OK1334tidy_dep_fileconst mode_tfil_modelen + 1"dep file"pzepzn420O_CREATS_IRGRP416S_IROTHtfile_namedep_name_lendep_name_len + TEMP_SUFFIX_LEN + 1dep_name_len + 9 + 1"dfileb"dep_name_len + TEMP_SUFFIX_LENdep_name_len + 9"dfile"14546dep_name_len + 1"t-name"aprf(CANNOT_FMT, errno, (ag_text_strtable+14366), tfile_name, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+14366), tfile_name, strerror((*__errno_location ())))14366"w"aprf(CANNOT_FMT, errno, (ag_text_strtable+14366), dep_file, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+14366), dep_file, strerror((*__errno_location ())))14245acavflist143591189pnmbnmpnm_szbnm_szpnm_sz + bnm_sz + 2"t list"flist_t **flist **lp15714sizeof(*p) + l"tfile"14586pp15690"sfile"14565flist_ttarg_flistsrc_flist/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/agDep.c *//*
             * The target we are crating will now depend upon the target
             * created by the spawned autogen run.  That spawned run script
             * is responsible for ensuring that if there are multiple targets,
             * then they are all chained together so we only worry about one.
             *//* DO NOT REMOVE DEPENDENCY FILE *//*
         *  Remove the target file name IFF it is different from
         *  the dependency file name.  The dependency file will not be
         *  removed, but it will be sent waaay back in time.
         *//**
 *  Finish off the dependency file.  Write out the lists of files,
 *  a rule to fulfill make's needs and, optionally, clean up rules.
 *  then close the file and tidy up.
 */// TMPDIR directory file// autogen temp file// no longer accessible/*
     *  Omit temporary sources.  They are identified several ways:
     *  1. the file must be accessible
     *  2. the file must not match our temporary file template
     *  3. the file must not match TMPDIR from the environment
     *//**
 *  Print out and free a list of files.
 *//*
         * If the target is not the dependency file, then ensure that the
         * file exists and set its time to the same time.  Ignore all errors.
         *//*
     * Trim off the temporary suffix and rename the dependency file into
     * place.  We used a mkstemp name in case autogen failed.
     *//**
 *  Set modification time and rename into result file name.
 *//*
         * Now scan over the characters in "pz_targ_base".  Anything that
         * is not a legal name character gets replaced with an underscore.
         *//*
         * Create the file and write the leader.
         *//*
             * If there is no target name, then the target is our output file.
             *//*
     * Set dep_file to a temporary file name
     *//**
 * Create a dependency output file
 *///!< list scanning pointer/**
 *  Remove a target file from the dependency list
 *
 * @param pz pointer to file name
 *//*
     *  avoid duplicates and add to end of list
     *//*
     *  Target files override sources, just in case.
     *  (We sometimes extract from files we are about to replace.)
     *//*
     *  Skip anything stashed in the temp directory.
     *//**
 *  Add a target file to the dependency list.  Avoid files in temp directories.
 *
 * @param pz pointer to file name
 *///!< point to where to stash removed "next"/**
 *  remove a source file from the dependency list
 *
 * @param pz pointer to file name
 *//*
     * No check for duplicate in source list.  Add if not found.
     *//*
     * If a source is also a target, then we've created it.
     * Do not list in source dependencies.
     *//**
 *  Add a source file to the dependency list
 *
 * @param pz pointer to file name
 *//*
 * This file is part of AutoGen.
 * Copyright (C) 1992-2015 Bruce Korb - all rights reserved
 *
 * AutoGen is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AutoGen is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *//**
 * @file agDep.c
 *
 *  This module will load a template and return a template structure.
 *
 * @addtogroup autogen
 * @{
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/expr.iniag_initconst char[1119]char[1119]1119g_nmag-fprintf ag-function? agpl base-name bsd c-string chdir count def-file def-file-line dne emit error error-source-line exist? extract find-file first-for? for-by for-from for-index for-sep for-to format-arg-count found-for? fprintf get get-c-name get-down-name get-up-name gperf gpl hide-email high-lim in? insert-file join kr-string last-for? len lgpl license license-description license-full license-info license-name low-lim make-gperf make-header-guard make-tmp-dir makefile-script match-value? max max-file-time min mk-gettextable out-delete out-depth out-emit-suspended out-line out-move out-name out-pop out-push-add out-push-new out-resume out-suspend out-switch output-file-next-line prefix printf raw-shell-str set-option set-writable shell shell-str shellf sprintf stack string-capitalize string-capitalize! *=* *==* string-downcase string-downcase! *~ *~~ *= *== == ~ = *~* *~~* ~~ ~* ~~* =* ==* string-substitute string->c-name! string->camelcase string-tr string-tr! string-upcase string-upcase! sub-shell-str suffix sum time-string->number tpl-file tpl-file-line tpl-file-next-line version-compare warn"ag-fprintf\0"
/*    11 */ "ag-function?\0"
/*    24 */ "agpl\0"
/*    29 */ "base-name\0"
/*    39 */ "bsd\0"
/*    43 */ "c-string\0"
/*    52 */ "chdir\0"
/*    58 */ "count\0"
/*    64 */ "def-file\0"
/*    73 */ "def-file-line\0"
/*    87 */ "dne\0"
/*    91 */ "emit\0"
/*    96 */ "error\0"
/*   102 */ "error-source-line\0"
/*   120 */ "exist?\0"
/*   127 */ "extract\0"
/*   135 */ "find-file\0"
/*   145 */ "first-for?\0"
/*   156 */ "for-by\0"
/*   163 */ "for-from\0"
/*   172 */ "for-index\0"
/*   182 */ "for-sep\0"
/*   190 */ "for-to\0"
/*   197 */ "format-arg-count\0"
/*   214 */ "found-for?\0"
/*   225 */ "fprintf\0"
/*   233 */ "get\0"
/*   237 */ "get-c-name\0"
/*   248 */ "get-down-name\0"
/*   262 */ "get-up-name\0"
/*   274 */ "gperf\0"
/*   280 */ "gpl\0"
/*   284 */ "hide-email\0"
/*   295 */ "high-lim\0"
/*   304 */ "in?\0"
/*   308 */ "insert-file\0"
/*   320 */ "join\0"
/*   325 */ "kr-string\0"
/*   335 */ "last-for?\0"
/*   345 */ "len\0"
/*   349 */ "lgpl\0"
/*   354 */ "license\0"
/*   362 */ "license-description\0"
/*   382 */ "license-full\0"
/*   395 */ "license-info\0"
/*   408 */ "license-name\0"
/*   421 */ "low-lim\0"
/*   429 */ "make-gperf\0"
/*   440 */ "make-header-guard\0"
/*   458 */ "make-tmp-dir\0"
/*   471 */ "makefile-script\0"
/*   487 */ "match-value?\0"
/*   500 */ "max\0"
/*   504 */ "max-file-time\0"
/*   518 */ "min\0"
/*   522 */ "mk-gettextable\0"
/*   537 */ "out-delete\0"
/*   548 */ "out-depth\0"
/*   558 */ "out-emit-suspended\0"
/*   577 */ "out-line\0"
/*   586 */ "out-move\0"
/*   595 */ "out-name\0"
/*   604 */ "out-pop\0"
/*   612 */ "out-push-add\0"
/*   625 */ "out-push-new\0"
/*   638 */ "out-resume\0"
/*   649 */ "out-suspend\0"
/*   661 */ "out-switch\0"
/*   672 */ "output-file-next-line\0"
/*   694 */ "prefix\0"
/*   701 */ "printf\0"
/*   708 */ "raw-shell-str\0"
/*   722 */ "set-option\0"
/*   733 */ "set-writable\0"
/*   746 */ "shell\0"
/*   752 */ "shell-str\0"
/*   762 */ "shellf\0"
/*   769 */ "sprintf\0"
/*   777 */ "stack\0"
/*   783 */ "string-capitalize\0"
/*   801 */ "string-capitalize!\0"
/*   820 */ "*=*\0"
/*   824 */ "*==*\0"
/*   829 */ "string-downcase\0"
/*   845 */ "string-downcase!\0"
/*   862 */ "*~\0"
/*   865 */ "*~~\0"
/*   869 */ "*=\0"
/*   872 */ "*==\0"
/*   876 */ "==\0"
/*   879 */ "~\0"
/*   881 */ "=\0"
/*   883 */ "*~*\0"
/*   887 */ "*~~*\0"
/*   892 */ "~~\0"
/*   895 */ "~*\0"
/*   898 */ "~~*\0"
/*   902 */ "=*\0"
/*   905 */ "==*\0"
/*   909 */ "string-substitute\0"
/*   927 */ "string->c-name!\0"
/*   943 */ "string->camelcase\0"
/*   961 */ "string-tr\0"
/*   971 */ "string-tr!\0"
/*   982 */ "string-upcase\0"
/*   996 */ "string-upcase!\0"
/*  1011 */ "sub-shell-str\0"
/*  1025 */ "suffix\0"
/*  1032 */ "sum\0"
/*  1036 */ "time-string->number\0"
/*  1056 */ "tpl-file\0"
/*  1065 */ "tpl-file-line\0"
/*  1079 */ "tpl-file-next-line\0"
/*  1098 */ "version-compare\0"
/*  1114 */ "warn"g_nm + 0ag_fprintfg_nm + 11ag_function_pg_nm + 24agplg_nm + 29base_nameg_nm + 39bsdg_nm + 43c_stringg_nm + 52chdirg_nm + 58g_nm + 64def_fileg_nm + 73def_file_lineg_nm + 87dneg_nm + 91emitg_nm + 96g_nm + 102error_source_lineg_nm + 120exist_pg_nm + 127extractg_nm + 135135g_nm + 145first_for_pg_nm + 156g_nm + 163163g_nm + 172172g_nm + 182for_sep182g_nm + 190190g_nm + 197format_arg_count197g_nm + 214found_for_p214g_nm + 225225g_nm + 233get233g_nm + 237get_c_name237g_nm + 248get_down_name248g_nm + 262get_up_name262g_nm + 274gperf274g_nm + 280gplg_nm + 284hide_emailg_nm + 295high_lim295g_nm + 304in_p304g_nm + 308insert_file308g_nm + 320join320g_nm + 325kr_string325g_nm + 335last_for_p335g_nm + 345345g_nm + 349lgpl349g_nm + 354354g_nm + 362license_description362g_nm + 382license_full382g_nm + 395license_info395g_nm + 408license_nameg_nm + 421low_lim421g_nm + 429make_gperf429g_nm + 440make_header_guard440g_nm + 458make_tmp_dir458g_nm + 471makefile_script471g_nm + 487match_value_p487g_nm + 500500g_nm + 504max_file_time504g_nm + 518518g_nm + 522mk_gettextable522g_nm + 537out_delete537g_nm + 548out_depth548g_nm + 558out_emit_suspended558g_nm + 577out_line577g_nm + 586out_move586g_nm + 595out_name595g_nm + 604out_pop604g_nm + 612out_push_add612g_nm + 625out_push_new625g_nm + 638out_resume638g_nm + 649out_suspend649g_nm + 661out_switch661g_nm + 672output_file_next_line672g_nm + 694694g_nm + 701701g_nm + 708raw_shell_str708g_nm + 722set_option722g_nm + 733set_writable733g_nm + 746746g_nm + 752shell_str752g_nm + 762shellf762g_nm + 769769g_nm + 777777g_nm + 783string_capitalize783g_nm + 801string_capitalize_x801g_nm + 820string_contains_eqv_p820g_nm + 824string_contains_p824g_nm + 829string_downcase829g_nm + 845string_downcase_x845g_nm + 862string_end_eqv_match_p862g_nm + 865string_end_match_p865g_nm + 869string_ends_eqv_p869g_nm + 872string_ends_with_p872g_nm + 876string_equals_p876g_nm + 879string_eqv_match_p879g_nm + 881string_eqv_p881g_nm + 883string_has_eqv_match_p883g_nm + 887string_has_match_p887g_nm + 892string_match_p892g_nm + 895string_start_eqv_match_p895g_nm + 898string_start_match_p898g_nm + 902string_starts_eqv_p902g_nm + 905string_starts_with_p905g_nm + 909string_substitute909g_nm + 927string_to_c_name_x927g_nm + 943string_to_camelcase943g_nm + 961string_tr961g_nm + 971string_tr_x971g_nm + 982string_upcaseg_nm + 996string_upcase_x996g_nm +1011sub_shell_str1011g_nm +10251025g_nm +10321032g_nm +1036time_string_to_number1036g_nm +1056tpl_file1056g_nm +1065tpl_file_line1065g_nm +1079tpl_file_next_line1079g_nm +1098version_compare1098g_nm +1114warn1114scm_callback_tNEW_PROCNEW_PROC(_As,_Ar,_Ao,_Ax,_An)scm_c_define_gsubr((char *)(_As), _Ar, _Ao, _Ax, (scm_callback_t)VOIDP(ag_scm_ ## _An))/* end of expr.ini *//*  1114 *//*  1098 *//*  1079 *//*  1065 *//*  1056 *//*  1036 *//*  1032 *//*  1025 *//*  1011 *//*   996 *//*   971 *//*   961 *//*   943 *//*   927 *//*   909 *//*   905 *//*   902 *//*   898 *//*   895 *//*   892 *//*   887 *//*   883 *//*   881 *//*   879 *//*   876 *//*   872 *//*   869 *//*   865 *//*   845 *//*   829 *//*   824 *//*   820 *//*   801 *//*   783 *//*   777 *//*   769 *//*   762 *//*   752 *//*   746 *//*   733 *//*   722 *//*   708 *//*   701 *//*   694 *//*   672 *//*   661 *//*   649 *//*   638 *//*   625 *//*   612 *//*   604 *//*   595 *//*   586 *//*   577 *//*   558 *//*   548 *//*   537 *//*   522 *//*   518 *//*   504 *//*   500 *//*   487 *//*   471 *//*   458 *//*   440 *//*   429 *//*   421 *//*   395 *//*   382 *//*   362 *//*   354 *//*   349 *//*   345 *//*   335 *//*   325 *//*   320 *//*   308 *//*   304 *//*   295 *//*   274 *//*   262 *//*   248 *//*   237 *//*   233 *//*   225 *//*   214 *//*   197 *//*   182 *//*   172 *//*   163 *//*   145 *//*   135 *//*   127 *//*   120 *//*   102 *//*    96 *//*    91 *//*    87 *//*    73 *//*    64 *//*    58 *//*    43 *//*    39 *//*    29 *//*    24 *//*    11 *//**
 * autogen Initialization procedure.
 *//** \file expr.ini
 *
 * Guile Initializations - autogen Global Variables
 *
 * @addtogroup autogen
 * @{
 *//*  -*- buffer-read-only: t -*- vi: set ro:
 *
 *  DO NOT EDIT THIS FILE   (expr.ini)
 *
 *  It has been AutoGen-ed
 *  From the definitions    expr.def
 *  and the template file   snarf.tpl
 *
 *  Copyright (C) 1992-2015 Bruce Korb - all rights reserved
 *
 *  AutoGen is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  AutoGen is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program.  If not, see <http://www.gnu.org/licenses/>.
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/agInit.c"expr.ini"4330362736494606LD_LIB_PATH_PFX_LEN + psz16 + psz"lp"4589pszDESC(TEMPL_DIRS).optActualIndex = 1; DESC(TEMPL_DIRS).optActualValue = VALUE_OPT_TEMPL_DIRS; DESC(TEMPL_DIRS).fOptState &= OPTST_PERSISTENT_MASK; DESC(TEMPL_DIRS).fOptState |= OPTST_SET; DESC(TEMPL_DIRS).optArg.argString = ((ag_text_strtable+1409)); (*(DESC(TEMPL_DIRS).pOptProc))(&autogenOptions, autogenOptions.pOptDesc + 1);(autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).optActualIndex = 1; (autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).optActualValue = 'L'; (autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).fOptState &= 0xFFFFF00U; (autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).fOptState |= 0x0000001U; (autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).optArg.argString = ((ag_text_strtable+1409)); (*((autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).pOptProc))(&autogenOptions, autogenOptions.pOptDesc + 1);TEMPL_DIRS1409const tpOptProctOptProc *DESC(TEMPL_DIRS).optActualIndex = 1; DESC(TEMPL_DIRS).optActualValue = VALUE_OPT_TEMPL_DIRS; DESC(TEMPL_DIRS).fOptState &= OPTST_PERSISTENT_MASK; DESC(TEMPL_DIRS).fOptState |= OPTST_SET; DESC(TEMPL_DIRS).optArg.argString = ((ag_text_strtable+1412)); (*(DESC(TEMPL_DIRS).pOptProc))(&autogenOptions, autogenOptions.pOptDesc + 1);(autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).optActualIndex = 1; (autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).optActualValue = 'L'; (autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).fOptState &= 0xFFFFF00U; (autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).fOptState |= 0x0000001U; (autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).optArg.argString = ((ag_text_strtable+1412)); (*((autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).pOptProc))(&autogenOptions, autogenOptions.pOptDesc + 1);1412LIBDATADIR"/usr/lib/autogen"DESC(TEMPL_DIRS).optActualIndex = 1; DESC(TEMPL_DIRS).optActualValue = VALUE_OPT_TEMPL_DIRS; DESC(TEMPL_DIRS).fOptState &= OPTST_PERSISTENT_MASK; DESC(TEMPL_DIRS).fOptState |= OPTST_SET; DESC(TEMPL_DIRS).optArg.argString = ("/usr/lib/autogen"); (*(DESC(TEMPL_DIRS).pOptProc))(&autogenOptions, autogenOptions.pOptDesc + 1);(autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).optActualIndex = 1; (autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).optActualValue = 'L'; (autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).fOptState &= 0xFFFFF00U; (autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).fOptState |= 0x0000001U; (autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).optArg.argString = ("/usr/lib/autogen"); (*((autogenOptions.pOptDesc[INDEX_OPT_TEMPL_DIRS]).pOptProc))(&autogenOptions, autogenOptions.pOptDesc + 1);/usr/lib/autogenchar[264]264__autogen__"__autogen__"unmaprf(CANNOT_FMT, errno, (ag_text_strtable+15929), (ag_text_strtable+14520), strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+15929), (ag_text_strtable+14520), strerror((*__errno_location ())))utsname *1592914520add_sys_env 2env_name[i](env_name[i])14684opt_argopt_arg + 1"f name""t name"827'Q'quote_itenv_name'P'849dep_usage15938make_quote_str"q name"init_scm8330ini_resscm2display(ini_res)"ini res"majmicaprf(GUILE_VERSION_BAD, libguile_ver)aprf((ag_text_strtable+3540), libguile_ver)%u.%u.%u"%u.%u.%u"3540aprf(GUILE_VERSION_WRONG, libguile_ver, MK_STR(GUILE_VERSION))aprf((ag_text_strtable+3578), libguile_ver, "200013")GUILE_VERSION2000131000200(GUILE_VERSION / 1000)357840738242agInit.cld_lib_path379872const char[9]SCHEME_INIT_DEBUGGUILE_VERSION >= 200000defined(HAVE_SOLARIS_SYSINFO)SI_PLATFORMdefined(HAVE_UNAME_SYSCALL)/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/agInit.c *//*
     *  Set the last resort search directories first (lowest priority)
     *  The lowest of the low is the config time install data dir.
     *  Next is the *current* directory of this executable.
     *  Last (highest priority) of the low priority is the library data dir.
     *//*
     *  If GUILE_WARN_DEPRECATED has not been defined, then likely we are
     *  not in a development environment and likely we don't want to give
     *  our users any angst.
     *//*
     *  as of 2.0.2, Guile will fiddle with strings all on its own accord.
     *  Coerce the environment into being POSIX ASCII strings so it keeps
     *  its bloody stinking nose out of our data.
     *//**
 * Prepare the raft of environment variables.
 * This runs before Guile starts and grabs the value for LD_LIBRARY_PATH.
 * Guile likes to fiddle that.  When we run initialize(), we will force it
 * to match what we currently have.  Additionally, force our environment
 * to be "C" and export all the variables that describe our system.
 *//*
     *  If the user already has something in the environment, do not
     *  override it.
     *//**
 * Add a system name to the environment.  The input name is up-cased and
 * made to conform to environment variable names.  If not already in the
 * environment, it is added with the string value "1".
 *
 * @param env_name in/out: system name to export
 *//*
         *  'D' and 'G' make sense to GCC, not us.  Ignore 'em.  If we
         *  found a NUL byte, then act like we found -MM on the command line.
         *//*
     *  The option argument is optional.  Make sure we have one.
     *//**
 * Configure a dependency option.
 * Handles any of these letters:  MFQTPGD as the first part of the option
 * argument.
 *
 * @param opts the autogen options data structure
 * @param pOptDesc the option descriptor for this option.
 *//**
 * Error in dependency specification
 *
 * @param fmt the error message format
 *//**
 * make a name resilient to machinations made by 'make'.
 * Basically, dollar sign characters are doubled.
 *
 * @param str the input string
 * @returns a newly allocated string with the '$' characters doubled
 *//* NOT_REACHED *//*
     *  Initialize all the Scheme functions.
     *//**
 * Various initializations.
 *
 * @param arg_ct  the count of program arguments, plus 1.
 * @param arg_vec the program name plus its arguments
 *//**
 * @file agInit.c
 *
 *  Do all the initialization stuff.  For daemon mode, only
 *  children will return.
 *
 * @addtogroup autogen
 * @{
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/agUtils.cguess_againskip_quoteqc0x7FdpppzDEFINE& DESC(DEFINE)& (autogenOptions.pOptDesc[INDEX_OPT_DEFINE])tArgList *const char *[6]char *[6]pzEqoptCt18781404TRACE_OUT& DESC(TRACE_OUT)& (autogenOptions.pOptDesc[INDEX_OPT_TRACE_OUT])& DESC(TIMEOUT)& (autogenOptions.pOptDesc[INDEX_OPT_TIMEOUT])AG_DEFAULT_TIMEOUT(char const *)AG_DEFAULT_TIMEOUT6738& DESC(BASE_NAME)& (autogenOptions.pOptDesc[INDEX_OPT_BASE_NAME])MAKE_DEP& DESC(MAKE_DEP)& (autogenOptions.pOptDesc[INDEX_OPT_MAKE_DEP])EQUATEcheck_make_dep_envhave_opt_stringset_optmdep1341qstr'y''Y'16104673515924DESC(MAKE_DEP).optActualIndex = 26; DESC(MAKE_DEP).optActualValue = VALUE_OPT_MAKE_DEP; DESC(MAKE_DEP).fOptState &= OPTST_PERSISTENT_MASK; DESC(MAKE_DEP).fOptState |= OPTST_SET; DESC(MAKE_DEP).optArg.argString = (""); (*(DESC(MAKE_DEP).pOptProc))(&autogenOptions, autogenOptions.pOptDesc + 26);(autogenOptions.pOptDesc[INDEX_OPT_MAKE_DEP]).optActualIndex = 26; (autogenOptions.pOptDesc[INDEX_OPT_MAKE_DEP]).optActualValue = 'M'; (autogenOptions.pOptDesc[INDEX_OPT_MAKE_DEP]).fOptState &= 0xFFFFF00U; (autogenOptions.pOptDesc[INDEX_OPT_MAKE_DEP]).fOptState |= 0x0000001U; (autogenOptions.pOptDesc[INDEX_OPT_MAKE_DEP]).optArg.argString = (""); (*((autogenOptions.pOptDesc[INDEX_OPT_MAKE_DEP]).pOptProc))(&autogenOptions, autogenOptions.pOptDesc + 26);strlen(mdep) + 5"mdep"DESC(SAVE_OPTS).fOptState &= OPTST_PERSISTENT_MASK; DESC(SAVE_OPTS).fOptState |= OPTST_SET; DESC(SAVE_OPTS).optArg.argString = (char const*)(fp)(autogenOptions.pOptDesc[INDEX_OPT_SAVE_OPTS]).fOptState &= 0xFFFFF00U; (autogenOptions.pOptDesc[INDEX_OPT_SAVE_OPTS]).fOptState |= 0x0000001U; (autogenOptions.pOptDesc[INDEX_OPT_SAVE_OPTS]).optArg.argString = (char __const*)(fp)SAVE_OPTSopen_trace_filefname + 2"a"fopen"fopen"158071481115521put_defines_into_envsiz"env define"1406define_base_name13957129strlen(pz)+1"derived base"char[512]2 * SCRIBBLE_SIZE4321581/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/agUtils.c *//**
 * scan past an expression.  An expression is either a Scheme
 * expression starting and ending with balanced parentheses,
 * or a quoted string or a sequence of non-whitespace characters.
 * semicolons denote a comment that extends to the next newline.
 *
 * @param [in]  src  input text
 * @param [in]  len  the maximum length to scan over
 *
 * @returns a pointer to the character next after the expression end.
 *//**
 * Skip over scheme expression.  We need to find what follows it.
 * Guile will carefully parse it later.
 *
 * @param[in]  scan  where to start search
 * @param[in]  end   point beyond which not to go
 * @returns    character after closing parenthesis or "end",
 * which ever comes first.
 *//* Return addr of char after the terminating quote *//* while (*qstr != q) *//* switch (*qstr++)   *//* if (q == '\'')      *//* provide a scratch pad for escape processing *//*
                 *  Single quoted strings process the backquote specially
                 *  only in fron of these three characters:
                 *//* Return address of terminating NUL *//*  Save the quote character type *//**
 *  The following routine skips over quoted text.  The quote character is
 *  whatever character the argument is pointing at when this procedure is
 *  called.
 *
 *  @param[in] qstr   input quoted string/output unquoted
 *  @returns the address of the byte after the original closing quote.
 *//*  Destination pointer           *//**
 *  The following routine scans over quoted text, shifting it in the process
 *  and eliminating the starting quote, ending quote and any embedded
 *  backslashes.  They may be used to embed the quote character in the quoted
 *  text.  The quote character is whatever character the argument is pointing
 *  at when this procedure is called.
 *
 *  @param[in,out] in_q   input quoted string/output unquoted
 *  @returns the address of the byte after the original closing quote.
 *//**
 *  look for a define string.  It may be in our DEFINE option list
 *  (preferred result) or in the environment.  Look up both.
 *
 *  @param[in] de_name   name to look for
 *  @param[in] check_env whether or not to look in environment
 *
 *  @returns a pointer to the string, if found, or NULL.
 *//*
     *  IF we have some defines to put in our environment, ...
     *//*
     *  IF we do not have a base-name option, then we compute some value
     *//*
     *  IF the definitions file has been disabled,
     *  THEN a template *must* have been specified.
     *//*
         *  Make sure we have a source file, even if it is "-" (stdin)
         *//*
     *  Advance the argument counters and pointers past any
     *  command line options
     *//**
 * Check the environment for make dependency info.  We look for
 * AUTOGEN_MAKE_DEP, but if that is not found, we also look for
 * DEPENDENCIES_OUTPUT.  To do dependency tracking at all, we
 * must find one of these environment variables and it must
 *
 * * be non-empty
 * * not contain a variation on "no"
 * * not contain a variation on "false"
 *
 * Furthermore, to specify a file name, the contents must not contain
 * some variation on "yes" or "true".
 *//**
 *  Open trace output file.
 *
 *  If the name starts with a pipe character (vertical bar), then
 *  use popen on the command.  If it starts with ">>", then append
 *  to the file name that  follows that.
 *
 *  The trace output starts with the command and arguments used to
 *  start autogen.
 *
 * @param[in] av    autogen's argument vector
 * @param[in] odsc  option descriptor with file name string argument
 *//*
         *  Now put it in the environment
         *//*
         *  IF there is no associated value,  THEN set it to '1'.
         *  There are weird problems with empty defines.
         *  FIXME:  we loose track of this memory.  Don't know what to do,
         *  really, there is no good recovery mechanism for environment
         *  data.
         *//**
 * Put the -D option arguments into the environment.
 * This makes them accessible to Guile/Scheme code, too.
 *//*
     *  Otherwise, use the basename of the definitions file
     *//*
     *  IF input is from stdin, then use "stdin"
     *//*
     *  Point to the character after the last '/', or to the full
     *  definition file name, if there is no '/'.
     *//**
 * Figure out what base name to use.  --base-name was not specified.
 * Base it on the definitions file, if available.
 *//**
 * Allocating printf function.  It either works or kills the program.
 * @param[in] pzFmt the input format
 * @returns the allocated, formatted result string.
 *//**
 * Print a file system error fatal error message and die.
 *
 * @param[in] op         the operation that failed.
 * @param[in] fname      the file name the operation was on.
 * @noreturn
 *//**
 * @file agUtils.c
 *
 * Various utilities for AutoGen.
 *
 * @addtogroup autogen
 * @{
 */odsc/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/cgi-fsm.c"autogen.h"cgi_statetranssaved_pzSrcsaved_inlensaved_pzOutsaved_outlencurChexhaustionoutput space exhausted
"output space exhausted\n"char[24]const char[24](int)sizeof(exhaustion)sizeof(exhaustion)1572864CGI_TR_INVALIDconst t_cgi_transitionconst t_cgi_transition *cgi_transition *const t_cgi_transition[8]cgi_transition[8]const t_cgi_transition[3][8]cgi_transition[3][8]const t_cgi_transition(*)[8]cgi_transition(*)[8]CGI_TR_NAME_EQUAL='"='"CGI_TR_SEPARATE';
"';\n"CGI_TR_STASHCGI_TR_VALUE_ESCAPEcgi_invalid_transitionconst char[133]char[133]133CgiFsmErr_offconst size_t[3]unsigned long[3]const size_t[9]unsigned long[9]aprf(CGI_PARSE_ERR_FMT, pz )aprf((ag_text_strtable+936), pz )936t_cgi_transitioncgi_transitionte_cgi_transaszCgiEvents115129aszCgiStateszCgiStrings** OUT-OF-RANGE ** FSM Error:  in state %d (%s), event %d (%s) is invalid
 invalid init name value alpha name_char = + % other & end"** OUT-OF-RANGE **\0"
/*    19 */ "FSM Error:  in state %d (%s), event %d (%s) is invalid\n\0"
/*    75 */ "invalid\0"
/*    83 */ "init\0"
/*    88 */ "name\0"
/*    93 */ "value\0"
/*    99 */ "alpha\0"
/*   105 */ "name_char\0"
/*   115 */ "=\0"
/*   117 */ "+\0"
/*   119 */ "%\0"
/*   121 */ "other\0"
/*   127 */ "&\0"
/*   129 */ "end"cgi_trans_tableCGI_STATE_NAME(s)( (((unsigned)(s)) >= 3) ? zCgiStrings : zCgiStrings + aszCgiStates[s])CGI_EVT_NAME(t)( (((unsigned)(t)) >= 9) ? zCgiStrings : zCgiStrings + aszCgiEvents[t])CgiStInit_offCgiEvInvalid_offCGI_TRANSITION_CT/*
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of cgi-fsm.c *//* END   == BROKEN MACHINE == DO NOT CHANGE THIS COMMENT *//* START == BROKEN MACHINE == DO NOT CHANGE THIS COMMENT *//* END   == VALUE_ESCAPE == DO NOT CHANGE THIS COMMENT *//*
             *  We must backslash quote certain characters that are %-quoted
             *  in the input string:
             *//* START == VALUE_ESCAPE == DO NOT CHANGE THIS COMMENT *//* END   == STASH == DO NOT CHANGE THIS COMMENT *//* START == STASH == DO NOT CHANGE THIS COMMENT *//* END   == SEPARATE == DO NOT CHANGE THIS COMMENT *//* START == SEPARATE == DO NOT CHANGE THIS COMMENT *//* END   == NAME_EQUAL == DO NOT CHANGE THIS COMMENT *//* START == NAME_EQUAL == DO NOT CHANGE THIS COMMENT *//* END   == INVALID == DO NOT CHANGE THIS COMMENT *//* START == INVALID == DO NOT CHANGE THIS COMMENT *//* END   == FIND TRANSITION == DO NOT CHANGE THIS COMMENT *//* START == FIND TRANSITION == DO NOT CHANGE THIS COMMENT *//* END   == INVALID TRANS MSG == DO NOT CHANGE THIS COMMENT *//* START == INVALID TRANS MSG == DO NOT CHANGE THIS COMMENT *//**
 *  Print out an invalid transition message and return EXIT_FAILURE
 *//* * * * * * * * * THE CODE STARTS HERE * * * * * * * *//*   121 *//*   119 *//*   117 *//*   115 *//*   105 *//*    99 *//*    93 *//* EVT:  END *//* EVT:  & *//* EVT:  OTHER *//* EVT:  % *//* EVT:  + *//* EVT:  NAME_CHAR *//* EVT:  ALPHA *//* STATE 2:  CGI_ST_VALUE *//* STATE 1:  CGI_ST_NAME *//* STATE 0:  CGI_ST_INIT *//**
 *  State transition handling map.  Map the state enumeration and the event
 *  enumeration to the new state and the transition enumeration code (in that
 *  order).  It is indexed by first the current state and then the event code.
 *//**
 *  Enumeration of the valid transition types
 *  Some transition types may be common to several transitions.
 *//* END   === USER HEADERS === DO NOT CHANGE THIS COMMENT *//*  This file is part of AutoGen.
 *  Copyright (C) 1992-2014 Bruce Korb - all rights reserved
 *//* START === USER HEADERS === DO NOT CHANGE THIS COMMENT *//*
 *  Do not make changes to this file, except between the START/END
 *  comments, or it will be removed the next time it is generated.
 *//*   -*- buffer-read-only: t -*- vi: set ro:
 *
 *  DO NOT EDIT THIS FILE   (cgi-fsm.c)
 *
 *  It has been AutoGen-ed
 *  From the definitions    cgi.def
 *  and the template file   fsm
 *
 *  Automated Finite State Machine
 *
 *  Copyright (C) 1992-2015 Bruce Korb - all rights reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name ``Bruce Korb'' nor the name of any other
 *    contributor may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * AutoFSM IS PROVIDED BY Bruce Korb ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bruce Korb OR ANY OTHER CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/defDirect.cDESC(DEFINE).optActualIndex = 24; DESC(DEFINE).optActualValue = VALUE_OPT_UNDEFINE; DESC(DEFINE).fOptState &= OPTST_PERSISTENT_MASK; DESC(DEFINE).fOptState |= OPTST_SET | OPTST_EQUIVALENCE; DESC(DEFINE).optArg.argString = (dir); (*(DESC(UNDEFINE).pOptProc))(&autogenOptions, autogenOptions.pOptDesc + INDEX_OPT_DEFINE);(autogenOptions.pOptDesc[INDEX_OPT_DEFINE]).optActualIndex = 24; (autogenOptions.pOptDesc[INDEX_OPT_DEFINE]).optActualValue = 'U'; (autogenOptions.pOptDesc[INDEX_OPT_DEFINE]).fOptState &= 0xFFFFF00U; (autogenOptions.pOptDesc[INDEX_OPT_DEFINE]).fOptState |= 0x0000001U | 0x0000010U; (autogenOptions.pOptDesc[INDEX_OPT_DEFINE]).optArg.argString = (dir); (*((autogenOptions.pOptDesc[INDEX_OPT_UNDEFINE]).pOptProc))(&autogenOptions, autogenOptions.pOptDesc + INDEX_OPT_DEFINE);UNDEFINEendshell_len1821endshell_len-1aprf(DIRECT_SHELL_NOEND, cctx->scx_fname, cctx->scx_line)aprf((ag_text_strtable+1749), cctx->scx_fname, cctx->scx_line)1749sizeof(scan_ctx_t) + strlen(pzText) + 4"shell output"1800
#endshell"\n#endshell""\n#endshell")sizeof("\n#endshell")sizeof("\n#endshell") - 1*dircctx->scx_fname"#line"new_ctxinc_szfull_namefind_file(dir, full_name, apzSfx, cctx->scx_fname)search for"search for"sizeof(scan_ctx_t) + 4"inc def head"new_ctx->scx_fname"def file"rt"r" FOPEN_TEXT_FLAGaprf(CANNOT_FMT, errno, (ag_text_strtable+1567), full_name, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+1567), full_name, strerror((*__errno_location ())))VOIDP(pz)((void *)(uintptr_t)(pz))aprf(CANNOT_FMT, errno, (ag_text_strtable+1572), full_name, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+1572), full_name, strerror((*__errno_location ())))rdct1577defstrokaprf(DIRECT_ERROR_FMT, cctx->scx_fname, cctx->scx_line, arg)aprf((ag_text_strtable+1525), cctx->scx_fname, cctx->scx_line, arg)1525def_name*def_nameDESC(DEFINE).optActualIndex = 23; DESC(DEFINE).optActualValue = VALUE_OPT_DEFINE; DESC(DEFINE).fOptState &= OPTST_PERSISTENT_MASK; DESC(DEFINE).fOptState |= OPTST_SET; DESC(DEFINE).optArg.argString = (def_name); (*(DESC(DEFINE).pOptProc))(&autogenOptions, autogenOptions.pOptDesc + 23);(autogenOptions.pOptDesc[INDEX_OPT_DEFINE]).optActualIndex = 23; (autogenOptions.pOptDesc[INDEX_OPT_DEFINE]).optActualValue = 'D'; (autogenOptions.pOptDesc[INDEX_OPT_DEFINE]).fOptState &= 0xFFFFF00U; (autogenOptions.pOptDesc[INDEX_OPT_DEFINE]).fOptState |= 0x0000001U; (autogenOptions.pOptDesc[INDEX_OPT_DEFINE]).optArg.argString = (def_name); (*((autogenOptions.pOptDesc[INDEX_OPT_DEFINE]).pOptProc))(&autogenOptions, autogenOptions.pOptDesc + 23);pzRbad_dirv_ctxaprf(DIRECT_BAD_CTX_FMT, directive_name(id), cctx->scx_fname, cctx->scx_line)aprf((ag_text_strtable+1463), directive_name(id), cctx->scx_fname, cctx->scx_line)1463ignore_directive2852file_sizestat"stat"regular file check"regular file check"SOURCE_TIME& DESC(SOURCE_TIME)& (autogenOptions.pOptDesc[INDEX_OPT_SOURCE_TIME])check_assert_straprf(DIRECT_ASSERT_FMT, pz, arg)aprf((ag_text_strtable+1435), pz, arg)1342177301435skip_to_else_endleave_funcskip_to_endmacskip_to_endifskipping_ifdirv_end2126next_directiveaprf(DIRECT_NOENDIF_FMT, cctx->scx_fname, cctx->scx_line)aprf((ag_text_strtable+1627), cctx->scx_fname, cctx->scx_line)14321627count_linesnxteodirend_of_directiveskip_if_blockifdef_lvlNO_MATCH_ERR(_typ)AG_ABEND(aprf(DIRECT_NOMATCH_FMT, cctx->scx_fname, cctx->scx_line, _typ))/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/defDirect.c *//**
 *  Will remove any entries from the define list
 *  that match the undef name pattern.
 *//*
     *  Link the new scan data into the context stack
     *//*
     *  Get the space for the output data and for context overhead.
     *  This is an extra allocation and copy, but easier than rewriting
     *  'loadData()' for this special context.
     *//*
     *  Run the shell command.  The output text becomes the
     *  "file text" that is used for more definitions.
     *//*
     *  Save the scan pointer into the current context
     *//*
     *  Advance the scan pointer to the next line after '#endshell'
     *  IF there is no such line,
     *  THEN the scan will resume on a zero-length string.
     *//*
     *  IF there are no data after the '#shell' directive,
     *  THEN we won't write any data
     *  ELSE we have to find the end of the data.
     *//*
     *  The output time will always be the current time.
     *  The dynamic content is always current :)
     *//**
 *  Invokes @code{$SHELL} or @file{/bin/sh} on a script that should
 *  generate AutoGen definitions.  It does this using the same server
 *  process that handles the back-quoted @code{`} text.
 *  The block of text handed to the shell is terminated with
 *  the #endshell directive.
 *
 *  @strong{CAUTION}@:  let not your @code{$SHELL} be @code{csh}.
 *//**
 *  This directive will pass the option name and associated text to the
 *  AutoOpts optionLoadLine routine (@pxref{libopts-optionLoadLine}).  The
 *  option text may span multiple lines by continuing them with a backslash.
 *  The backslash/newline pair will be replaced with two space characters.
 *  This directive may be used to set a search path for locating template files
 *  For example, this:
 *
 *  @example
 *    #option templ-dirs $ENVVAR/dirname
 *  @end example
 *  @noindent
 *  will direct autogen to use the @code{ENVVAR} environment variable to find
 *  a directory named @code{dirname} that (may) contain templates.  Since these
 *  directories are searched in most recently supplied first order, search
 *  directories supplied in this way will be searched before any supplied on
 *  the command line.
 *//**
 *  This is a new AT&T research preprocessing directive.  Basically, it is
 *  a multi-line #define that may include other preprocessing directives.
 *  Text between this line and a #endmac directive are ignored.
 *//*
     *  Now extract the quoted file name string.
     *  We dup the string so it won't disappear on us.
     *//*
     *  The sequence must be:  #line <number> "file-name-string"
     *
     *  Start by scanning up to and extracting the line number.
     *//**
 *  Alters the current line number and/or file name.  You may wish to
 *  use this directive if you extract definition source from other files.
 *  @command{getdefs} uses this mechanism so AutoGen will report the correct
 *  file and approximate line number of any errors found in extracted
 *  definitions.
 *//*
     *  Read all the data.  Usually in a single read, but loop
     *  in case multiple passes are required.
     *//*
     *  Link it into the context stack
     *//*
     *  Make sure the specified file is a regular file and we can get
     *  the correct size for it.
     *//*
     *  Ignore C-style includes.  This allows "C" files to be processed
     *  for their "#define"s.
     *//**
 *  This directive will insert definitions from another file into
 *  the current collection.  If the file name is adorned with
 *  double quotes or angle brackets (as in a C program), then the
 *  include is ignored.
 *//**
 *  The definitions that follow, up to the matching @code{#endif} will be
 *  processed only if the named value has @strong{not} been defined.
 *//**
 *  The definitions that follow, up to the matching @code{#endif} will be
 *  processed only if there is a corresponding @code{-Dname} command line
 *  option or if a @code{#define} of that name has been previously encountered.
 *//**
 *  @code{#if} expressions are not analyzed.  @strong{Everything} from here
 *  to the matching @code{#endif} is skipped.
 *//**
 *  This directive will cause AutoGen to stop processing
 *  and exit with a status of EXIT_FAILURE.
 *//**
 *  This must follow an @code{#if}, @code{#ifdef} or @code{#ifndef}.
 *  In all cases, this will resume normal processing of text.
 *//**
 *  This must follow an @code{#if}, @code{#ifdef} or @code{#ifndef}.
 *  If it follows the @code{#if}, then it will be ignored.  Otherwise,
 *  it will change the processing state to the reverse of what it was.
 *//*
         * Copy chars for so long as it is not NUL and does not require quoting
         *//*
         *  Otherwise, insert the '=' and move any data up against it.
         *  We only accept one name-type, space separated token.
         *  We are not ANSI-C.  ;-)
         */// whatever it used to be, it is a NUL now./*
     *  We have found the end of the name.
     *  IF there is no more data on the line,
     *  THEN we do not have space for the '=' required by PUTENV.
     *       Therefore, move the name back over the "#define"
     *       directive itself, giving us the space needed.
     *//*
     *  IF this is a macro definition (rather than a value def),
     *  THEN we will ignore it.
     *//*
     *  Skip any #defines that do not look reasonable
     *//**
 *  Will add the name to the define list as if it were a DEFINE program
 *  argument.  Its value will be the first non-whitespace token following
 *  the name.  Quotes are @strong{not} processed.
 *
 *  After the definitions file has been processed, any remaining entries
 *  in the define list will be added to the environment.
 *//* not a valid script *//**
 *  This directive @i{is} processed, but only if the expression begins with
 *  either a back quote (@code{`}) or an open parenthesis (@code{(}).
 *  Text within the back quotes are handed off to the shell for processing
 *  and parenthesized text is handed off to Guile.  Multiple line expressions
 *  must be joined with backslashes.
 *
 *  If the @code{shell-script} or @code{scheme-expr} do not yield @code{true}
 *  valued results, autogen will be aborted.  If @code{<anything else>} or
 *  nothing at all is provided, then this directive is ignored.
 *
 *  The result is @code{false} (and fails) if the result is empty, the
 *  number zero, or a string that starts with the letters 'n' or 'f' ("no"
 *  or "false").
 *//**
 * Marks the end of the #macdef directive.  Error when out of context.
 *//**
 * Marks a transition in the #if directive.  Error when out of context.
 * #if blocks are always ignored.
 *//**
 * Marks the end of the #shell directive.  Error when out of context.
 *//**
 *  @code{#endshell}, @code{#elif} and @code{#endmac} directives, when found
 *  via a non-nested scan, are always in error.  They should only be found
 *  during the handling of @code{#shell}, @code{#if} and @code{#macdef}
 *  directives.  @code{#else} and @code{#endif} are in error if not matched
 *  with a previous @code{#ifdef} or @code{#ifndef} directive.
 *//**
 * Ignored directive.
 *//**
 * Ident, let and pragma directives are ignored.
 *//*!
 * an unrecognized directive has been encountered.  It need not be
 * #invalid, though that would get you here, too.
 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Special routines for each directive.  These routines are *ONLY*
 *  called from the table when the input is being processed.
 *  After this routine are either declarations or definitions of
 *  directive handling routines.  The documentation for these routines
 *  is extracted from this file.  See 'makedef.sh' for how it works.
 *  Each declared directive should have either a 'dummy:' section
 *  (if the directive is to be ignored) or a 'text:' section
 *  (if there is some form of implementation).  If the directive
 *  needs or may take arguments (e.g. '#define'), then there should
 *  also be an 'arg:' section describing the argument(s).
 *//* switch (find_directive(scan)) *//*
             *  We either don't know what it is or we do not care.
             *//*
             * We reached the end of the "ifdef"/"ifndef" (or transitioned to
             * process-the-text mode via "else").  Start processing the text.
             *//*
             *  We found an "else" directive for an "ifdef"/"ifndef"
             *  that we were skipping over.  Start processing the text.
             *  Let the @code{DIR_ENDIF} advance the scanning pointer.
             *//**
 *  Skip through the text to a matching "#endif" or "#else" or
 *  "#elif*def".  We do this when we are skipping code due to a failed
 *  "#if*def" test.
 *//*
             *  We found the endmac we are interested in
             *//**
 *  Skip through the text to a "#endmac".
 *//* ignore it *//*
             *  We do not care what we found
             *//*
             *  We found a nested conditional, so skip to endif nested, too.
             *//*
             *  We found the endif we are interested in
             *//**
 *  Skip through the text to a matching "#endif".  We do this when we
 *  have processed the allowable text (found an "#else" after
 *  accepting the preceding text) or when encountering a "#if*def"
 *  while skipping a block of text due to a failed test.
 *//*
     *  Ignore '#!' as a comment, enabling a definition file to behave
     *  as a script that gets interpreted by autogen.  :-)
     *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  processDirective
 *
 *  THIS IS THE ONLY EXTERNAL ENTRY POINT
 *
 *  A directive character has been found.
 *  Decide what to do and return a pointer to the character
 *  where scanning is to resume.
 *//*
         *  Replace the escape-newline pair with spaces and
         *  find the next end of line
         *//*
     *  Search for the end of the #-directive.
     *  Replace "\\\n" sequences with "  ".
     *//**
 * Set "true" when inside of a "#if" block making "#elif" directives
 * ignorable.  When "false", "#elif" triggers an error.
 *//**
 * "ifdef" processing level.  Blocks of text being skipped do not increment
 * the value.  Thus, transitioning from skip mode to process mode increments it,
 * and the reverse decrements it.
 *//**
 * @file defDirect.c
 *
 *  This module processes definition file directives.
 *
 * @addtogroup autogen
 * @{
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/defFind.cCN_START_NAMECN_NAME_ENDEDCN_INDEXCN_INDEX_CLOSECN_INDEX_ENDEDteConStateget_def_listdefListpcBracebreakChnoNestingname + 1*nameaprf(BAD_NAME_FMT, zDefinitionName, current_tpl->td_file, cur_macro->md_line)aprf((ag_text_strtable+664), zDefinitionName, current_tpl->td_file, cur_macro->md_line)sizeof(zDefinitionName)sizeof(zDefinitionName) - 1664not_foundfound_def_entrypcBrace + 1def_ent_list_t *returnResult15974hash_name_t *hash_name_s *hnhash_name_t **hash_name_s **16072char[0]USED_DEFINES& DESC(USED_DEFINES)& (autogenOptions.pOptDesc[INDEX_OPT_USED_DEFINES])add_stringz_lenbit_ctsizeof (*hash_table)hptrnewsizeof (*new) + z_len"hn"hash_stringfind_defnestingDepthbracebr_chbrace + 1pzOripzDststLennextSegment*pzS(state == CN_NAME_ENDED) || (state == CN_INDEX_CLOSE)char[54]defFind.c387IS_ALPHANUMERIC_CHAR(*pzS)is_ag_char_map_char((char)(*pzS), 0x001B0000)char[27]38894'^'bad_def_nameadd_to_def_listVOIDP(del->del_def_ent_ary)((void *)(uintptr_t)(del->del_def_ent_ary))del->del_alloc_ct * sizeof(void *)"add find"del->del_def_ent_aryfind_by_indexsvchhash_name_thash_name_sdef_ent_list_thn_strhn_nextdel_leveldel_def_ent_arydel_used_ctdel_alloc_ctzDefinitionNamehash_table_cthash_tableILLFORMEDNAME()AG_ABEND(aprf(BAD_NAME_FMT, zDefinitionName, current_tpl->td_file, cur_macro->md_line));/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/defFind.c *//*
     *  Loop through all the twins of the entry.  We only look once if we used
     *  a subscript.  Ignore any entry types that are not "Blocks" because
     *  text entries won't have any children.
     *//*
             *  Which one?  One is valid, the other not and it is not known
             *  at compile time.
             *
             *  It is a segmented value name.  Set the name pointer to the
             *  next segment and search starting from the newly available set
             *  of definitions.
             *//*
             *  Which one?  One is valid, the other not and it is not known
             *  at compile time.
             *//*
         *  IF we are at the end of the definition,
         *  THEN return what we found
         *//*
         *  We must find the closing brace, or there is an error
         *//*
         *  We have to find a specific entry in a list.
         *//*
     *  At this point, we have found the entry that matches the supplied name,
     *  up to the '[' or name_sep_ch or NUL character.  It *must* be one of
     *  those three characters.
     *//*
         *  Let's go try the definitions at the next higher level.
         *//*
         *  IF we are nested, then we cannot change the definition level.
         *  Just go and return what we have found so far.
         *//*
             *  IF the name matches
             *  THEN go add it, plus all its twins
             *//*
             *  Don't bother returning zero entry list.  Just return NULL.
             *//*
             *  Make sure we are not nested.  Once we start to nest,
             *  then we cannot "change definition levels"
             *//*
         *  IF we are at the end of the definitions (reached ROOT),
         *  THEN it is time to bail out.
         *//*
     *  IF we are at the start of a search, then canonicalize the name
     *  we are hunting for, copying it to a modifiable buffer, and
     *  initialize the "indexed" boolean to false (we have not found
     *  an index yet).
     *//**
 *  Find the definition entries for the name passed in.  It is okay to find
 *  block entries IFF they are found on the current level.  Once you start
 *  traversing up the tree, the macro must be a text macro.  Return an
 *  indicator saying if the element has been indexed (so the caller will
 *  not try to traverse the list of twins).
 *//**
 * locate a definition by name.
 *
 * @param[in]  name     the name to find.  May be segmented and/or indexed.
 * @param[out] indexed  whether or not the found name is indexed.
 *//* no matching name can be found *//* old name *//*
     *  If a new name, insert it in order.
     *//*
     *  canonicalize the name
     *//*
     *  Save only the last component of the name, sans any index, too.
     *//*
     *  If there is no hash table, create one.
     *//*
 *  This makes certain assumptions about the underlying architecture.
 *  Doesn't matter tho.  A high collision rate just makes it a teensy
 *  bit slower.
 *//*
     *  Loop through all the twins of the entry we found until
     *  we find the entry we want.  We ignore twins if we just
     *  used a subscript.
     *//*
     *  We cannot find a member of a non-block type macro definition.
     *//*
             *  Which one?  One is valid, the other not and it is not known
             *  at compile time.
             *
             *  It is a segmented value name.  Set the name pointer
             *  to the next segment and search starting from the newly
             *  available set of definitions.
             *//*
         *  What follows the closing brace?  IF we are at the end of the
         *  definition, THEN return what we found.  However, if there's
         *  another name, then we have to go look that one up, too.
         *//*
         *  IF we are nested, then we cannot change the definition level.
         *  So, we did not find anything.
         *//*
             *  IF the name matches
             *  THEN break out of the double loop
             *//**
 *  Find the definition entry for the name passed in.  It is okay to
 *  find block entries IFF they are found on the current level.  Once
 *  you start traversing up the tree, the macro must be a text macro.
 *  Return an indicator saying if the element has been indexed (so the
 *  caller will not try to traverse the list of twins).
 *
 * @param[in]  name      name to look for
 * @param[in]  def_ctx   definition context
 * @param[out] indexed   whether the name was indexed or not
 *//* force the separator chars to be '_' *//*
     *  Copy the name/number.  We already know the first character is valid.
     *  However, we must *NOT* downcase #define names...
     *//*
     *  The next state must be either looking for what comes after the
     *  end of a name, or for the close bracket after an index.
     *  Whatever, the next token must be a name or a number.
     *//*
         *  Nothing else is okay.
         *//*
         *  A solitary '$' is the highest index, whatever that happens to be
         *  We process that right here because down below we only accept
         *  name-type characters and this is not VMS.
         *//*
         *  Numbers and #define-d names are handled at the end of the switch.
         *  '$' and ']' are handled immediately below.
         *//*
         *  An index.  Valid syntaxes are:
         *
         *    '[' <#define-d name> ']'
         *    '[' <number> ']'
         *    '['  '$'  ']'
         *    '['       ']'
         *
         *  We will check for and handle the last case right here.
         *  The next cycle must find the index closer (']').
         *//* legal exit -- we have a name already *//* fall through to name/number consumption code *//* we found the start of our first name *//*
     *  The next segment may always start with an alpha character,
     *  but an index may also start with a number.  The full number
     *  validation will happen in find_by_index().
     *//*
     *  Before anything, skip a leading name_sep_ch as a special hack
     *  to force a current context lookup.
     *//* must find name_sep_ch or we end *//* must find ']' *//* must find name, number, '$' or ']' *//* must find '[' or name_sep_ch or we end *//* must find a name *//**
 *  remove white space and roughly verify the syntax.
 *  This procedure will consume everything from the source string that
 *  forms a valid AutoGen compound definition name.
 *  We leave legally when:
 *  1.  the state is "CN_NAME_ENDED", AND
 *  2.  We stumble into a character that is not either '[' or name_sep_ch
 *      (always skipping white space).
 *  We start in CN_START.
 *
 * @param[out] pzD      place to put canonicalized name
 * @param[in]  pzS      input non-canonicalized name
 * @param[in]  srcLen   length of input text
 *
 * @returns the length of un-consumed source text
 *//* 8, 24, 56, ... *//*
 *  find entry support routines:
 *
 *  add_to_def_list:  place a new definition entry on the end of the
 *              list of found definitions (reallocating list size as needed).
 *//*
     *  Search for the entry with the specified index.
     *//*
         *  Make sure we got a legal number
         *//*
         *  make sure we found a defined value
         *//*
         *  Skip over any trailing space and make sure we have a closer
         *//*
         *  Temporarily remove the character under *scan and
         *  find the corresponding defined value.
         *//*
         *  '[XX]' means get the index from our definitions
         *//*
     *  '[nn]' means the specified index number
     *//*
     *  '[$]' means the last entry of whatever the last one is.
     *  "de_etwin" points to it, or is NULL.
     *//*
     *  '[]' means the first entry of whatever index number
     *//**
 * Find a def entry by an index.  Valid indexes are:
 * * empty, meaning the first
 * * '$', meaning the last
 * * a decimal, octal or hex number
 * * an environment variable with a decimal, octal or hex number
 *
 * The "twins" of the passed in entry are searched for a matching
 * "de_index" value.
 *
 * @param[in] ent   the eldest twin/sibling of the list to search
 * @param[in] scan  the scanning pointer pointing to the first non-white
 *  character after the open bracket.
 *
 * @returns a pointer to the matching definition entry, if any.
 * Otherwise, NULL.
 *///!< how deep into it we are//!< pointer to list of entries//!< entries in actual use//!< entry allocation count/**
 * autogen definitions entry list.
 *//**
 * @file defFind.c
 *
 *  This module locates definitions.
 *
 * @addtogroup autogen
 * @{
 */del/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/defLoad.cpzDefFilepzDatadataSizesizeLeftin_modeINPUT_DONEsizeof(*base_ctx)"file buf"aprf(CANNOT_FMT, errno, (ag_text_strtable+1567), pzDefFile, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+1567), pzDefFile, strerror((*__errno_location ())))INPUT_STDINVOIDP(pzData)((void *)(uintptr_t)(pzData))aprf(CANNOT_FMT, errno, (ag_text_strtable+1572), pzDefFile, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+1572), pzDefFile, strerror((*__errno_location ())))VOIDP(base_ctx)((void *)(uintptr_t)(base_ctx))dataSize + 4 + sizeof(*base_ctx)"expand f buf"dataOff7751base_ctx->scx_fname"def file name"ready_def_input"scan context"7703148617780accept_fifo0x40004+sizeof(*base_ctx)(4+sizeof(*base_ctx))163400x4000 - (4+sizeof(*base_ctx))*ppzfileaprf(CANNOT_FMT, errno, (ag_text_strtable+7746), *ppzfile, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+7746), *ppzfile, strerror((*__errno_location ())))7746__S_IFIFO0010000aprf(CANNOT_FMT, errno, (ag_text_strtable+7724), *ppzfile, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+7724), *ppzfile, strerror((*__errno_location ())))7724INPUT_FILE*idx_str8445613-8531229376ppzfileinsert_entde_listaprf(DUP_VALUE_INDEX, de->de_name, de->de_index)aprf((ag_text_strtable+2092), de->de_name, de->de_index)sizeof(def)ag_offsetof(def_ent_t, de_name)sizeof(def) - ag_offsetof(def_ent_t, de_name)scntwn2092list_p7953pdende7362vtyp11811176116211687330free_def_entENTRY_ALLOC_SIZE((((4096 - sizeof(void *)) / sizeof(def_ent_t)) * sizeof(def_ent_t)) + sizeof(void *))"def headers"ENTRY_ALLOC_CT4040sizeof(*res)def_input_mode_tde_blocksfree_de_list((ENTRY_ALLOC_CT * sizeof(def_ent_t)) + sizeof(void *))(ENTRY_SPACE / sizeof(def_ent_t))ENTRY_SPACE(4096 - sizeof(void *))/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/defLoad.c *//*
     *  Close the input file, parse the data
     *  and alphabetically sort the definition tree contents.
     *//*
             *  The buffer may have moved.  Set the data pointer at an
             *  offset within the new buffer and make sure our base pointer
             *  has been corrected as well.
             *//*
             *  We have more data and we are out of space.
             *  Try to reallocate our input buffer.
             *//*
             *  IF it is a regular file, then we are done
             *//*
         *  See if there is any space left
         *//*
         *  Advance input pointer, decrease remaining count
         *//*
             *  IF it is because we are at EOF, then break out
             *  ELSE abend.
             *//*
         *  IF we are done,
         *//*
     *  Read until done...
     *//*
     *  Set the input file pointer, as needed
     *//*
     *  Our base context will have its currency pointer set to this
     *  input.  It is also a scanning pointer, but since this buffer
     *  is never deallocated, we do not have to remember the initial
     *  value.  (It may get reallocated here in this routine, tho...)
     *//*
     *  Allocate the space we need for our definitions.
     *//**
 *  Suck in the entire definitions file and parse it.
 *//*
     *  IF the source-time option has been enabled, then
     *  our output file mod time will start as one second after
     *  the mod time on this file.  If any of the template files
     *  are more recent, then it will be adjusted.
     *//*
     *  This, then, must be a regular file.  Make sure of that and
     *  find out how big it was and when it was last modified.
     *//*
     *  Check for stdin as the input file.  We use the current time
     *  as the modification time for stdin.  We also note it so we
     *  do not try to open it and we try to allocate more memory if
     *  the stdin input exceeds our initial allocation of 16K.
     *//**
 * figure out which file descriptor to use for reading definitions.
 *//**
 * Figure out where to insert an entry in a list of twins.
 *//* sometimes will change *//*
         *  Insert someplace after the first entry.  Scan the list until
         *  we either find a larger index or we get to the end.
         *//* Return the replacement structure address *//*
         *  IF this is the first twin, then the original list head is now
         *  the "end twin".
         *//*
         * Contents are swapped.  Link "de" after "de_list" and return "de_list".
         *//*
         *  Insert the new entry before any other in the list.  We
         *  actually do this by leaving the de_list pointer alone and
         *  swapping the contents of the definition entry.
         *//*  * * * * *  WE HAVE FOUND A TWIN
     *
     *  Link in the new twin chain entry into the list.
     *//*
         *  Check the next sibling for a twin value.
         *//*
         *  IF we are at the end of the list,
         *  THEN put the new entry at the end of the list.
         *       This is a new name in the current context.
         *       The value type is forced to be the same type.
         *//*
     *  Scan the list looking for a "twin" (same-named entry).
     *//*
     *  If the current level is empty, then just insert this one and quit.
     *//**
 *  Append a new entry into a sibling (or twin) list.
 *
 * @param[in]  de new definition
 * @returns usually, the input, but sometimes it is necessary to move
 *  the data, so returns the address of the incoming data regardless.
 *//*
     * Somewhere in the middle.  Fix up the de_twin and de_ptwin pointers
     * around the current entry.  If the current entry is actually last,
     * then fix up the de_etwin pointer from the twin list head.
     *//*
         * The list head now becomes the second "twin".
         * Adjust all the links *except* de_twin.
         *//*
     * Multiple entry list.  Check for list head.
     *//*
     * Check for single entry list.  I.e. point the single pointer to
     * this entry to the next, possibly NULL, entry.
     *//**
 *  Remove a new entry from a sibling (or twin) list.
 *
 * @param[in]  de  dead definition
 *//**
 * Append a new entry at the end of a sibling (or twin) list.
 * @param de  new definition
 *//*
         *  Unlink the last entry from the chain.  The next time this
         *  routine is called, the *FIRST* structure in this list will
         *  be returned.
         *//*
             *  When the loop ends, "res" will point to the last allocated
             *  structure instance.  That is the one we will return.
             *//*
         *  This is a post-loop test loop.  It will cycle one fewer times
         *  than there are 'def_ent_t' structs in the memory we just alloced.
         *//**
 * @file defLoad.c
 *
 *  This module loads the definitions, calls yyparse to decipher them,
 *  and then makes a fixup pass to point all children definitions to
 *  their parent definition.
 *
 * @addtogroup autogen
 * @{
 *//usr/include/asm-generic/ioctl.hIOCSIZE_SHIFT(_IOC_SIZESHIFT)IOCSIZE_MASK(_IOC_SIZEMASK << _IOC_SIZESHIFT)IOC_INOUT((_IOC_WRITE|_IOC_READ) << _IOC_DIRSHIFT)IOC_OUT(_IOC_READ << _IOC_DIRSHIFT)IOC_IN(_IOC_WRITE << _IOC_DIRSHIFT)_IOC_SIZE(nr)(((nr) >> _IOC_SIZESHIFT) & _IOC_SIZEMASK)_IOC_NR(nr)(((nr) >> _IOC_NRSHIFT) & _IOC_NRMASK)_IOC_TYPE(nr)(((nr) >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)_IOC_DIR(nr)(((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK)_IOWR_BAD(type,nr,size)_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))_IOW_BAD(type,nr,size)_IOC(_IOC_WRITE,(type),(nr),sizeof(size))_IOR_BAD(type,nr,size)_IOC(_IOC_READ,(type),(nr),sizeof(size))_IOWR(type,nr,size)_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))_IOW(type,nr,size)_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))_IOR(type,nr,size)_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))_IO(type,nr)_IOC(_IOC_NONE,(type),(nr),0)_IOC_TYPECHECK(t)(sizeof(t))_IOC(dir,type,nr,size)(((dir) << _IOC_DIRSHIFT) | ((type) << _IOC_TYPESHIFT) | ((nr) << _IOC_NRSHIFT) | ((size) << _IOC_SIZESHIFT))_IOC_READ_IOC_WRITE_IOC_NONE0U_IOC_DIRSHIFT(_IOC_SIZESHIFT+_IOC_SIZEBITS)_IOC_SIZESHIFT(_IOC_TYPESHIFT+_IOC_TYPEBITS)_IOC_TYPESHIFT(_IOC_NRSHIFT+_IOC_NRBITS)_IOC_NRSHIFT_IOC_DIRMASK((1 << _IOC_DIRBITS)-1)_IOC_SIZEMASK((1 << _IOC_SIZEBITS)-1)_IOC_TYPEMASK((1 << _IOC_TYPEBITS)-1)_IOC_NRMASK((1 << _IOC_NRBITS)-1)_IOC_DIRBITS_IOC_SIZEBITS_IOC_TYPEBITS_IOC_NRBITS_ASM_GENERIC_IOCTL_H/* _ASM_GENERIC_IOCTL_H *//* ...and for the drivers/sound files... *//* used to decode ioctl numbers.. *//*
 * Used to create numbers.
 *
 * NOTE: _IOW means userland is writing and kernel is reading. _IOR
 * means userland is reading and kernel is writing.
 *//*
 * Direction bits, which any architecture can choose to override
 * before including this file.
 *
 * NOTE: _IOC_WRITE means userland is writing and kernel is
 * reading. _IOC_READ means userland is reading and kernel is writing.
 *//*
 * Let any architecture override either of the following before
 * including this file.
 *//*
 * The following is for compatibility across the various Linux
 * platforms.  The generic ioctl numbering scheme doesn't really enforce
 * a type field.  De facto, however, the top 8 bits of the lower 16
 * bits are indeed used as a type field, so we might just as well make
 * this explicit here.  Please be sure to use the decoding macros
 * below from now on.
 *//* ioctl command encoding: 32 bits total, command in lower 16 bits,
 * size of the parameter structure in the lower 14 bits of the
 * upper 16 bits.
 * Encoding the size of the parameter structure in the ioctl request
 * is useful for catching programs compiled with old versions
 * and to avoid overwriting user space outside the user buffer area.
 * The highest 2 bits are reserved for indicating the ``access mode''.
 * NOTE: This limits the max parameter size to 16kB -1 !
 *//* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note *//usr/include/asm-generic/usr/include/x86_64-linux-gnu/asm/ioctl.h<asm-generic/ioctl.h>/usr/include/x86_64-linux-gnu/asm/usr/include/linux/ioctl.h<asm/ioctl.h>_LINUX_IOCTL_H/* _LINUX_IOCTL_H *//usr/include/linux/usr/include/asm-generic/ioctls.h<linux/ioctl.h>TIOCSER_TEMT0x01TIOCPKT_IOCTLTIOCPKT_DOSTOPTIOCPKT_NOSTOPTIOCPKT_STARTTIOCPKT_STOPTIOCPKT_FLUSHWRITETIOCPKT_FLUSHREADTIOCPKT_DATAFIOQSIZE0x5460TIOCGICOUNT0x545DTIOCMIWAIT0x545CTIOCSERSETMULTI0x545BTIOCSERGETMULTI0x545ATIOCSERGETLSR0x5459TIOCSERGSTRUCT0x5458TIOCSLCKTRMIOS0x5457TIOCGLCKTRMIOS0x5456TIOCSERSWILD0x5455TIOCSERGWILD0x5454TIOCSERCONFIG0x5453FIOASYNC0x5452FIOCLEX0x5451FIONCLEX0x5450TIOCSISO7816_IOWR('T', 0x43, struct serial_iso7816)TIOCGISO7816_IOR('T', 0x42, struct serial_iso7816)TIOCGPTPEER_IO('T', 0x41)TIOCGEXCL_IOR('T', 0x40, int)TIOCGPTLCK_IOR('T', 0x39, int)TIOCGPKT_IOR('T', 0x38, int)TIOCVHANGUP0x5437TIOCSIG_IOW('T', 0x36, int)TCSETXW0x5435TCSETXF0x5434TCSETX0x5433TCGETX0x5432TIOCGDEV_IOR('T', 0x32, unsigned int)TIOCSPTLCK_IOW('T', 0x31, int)TIOCGPTN_IOR('T', 0x30, unsigned int)TIOCSRS4850x542FTIOCGRS4850x542ETCSETSF2_IOW('T', 0x2D, struct termios2)TCSETSW2_IOW('T', 0x2C, struct termios2)TCSETS2_IOW('T', 0x2B, struct termios2)TCGETS2_IOR('T', 0x2A, struct termios2)TIOCGSID0x5429TIOCCBRK0x5428TIOCSBRK0x5427TCSBRKP0x5425TIOCGETD0x5424TIOCSETD0x5423TIOCNOTTY0x5422FIONBIO0x5421TIOCPKT0x5420TIOCSSERIAL0x541FTIOCGSERIAL0x541ETIOCCONS0x541DTIOCLINUX0x541CTIOCINQFIONREAD0x541BTIOCSSOFTCAR0x541ATIOCGSOFTCAR0x5419TIOCMSET0x5418TIOCMBIC0x5417TIOCMBIS0x5416TIOCMGET0x5415TIOCSWINSZ0x5414TIOCGWINSZ0x5413TIOCSTI0x5412TIOCOUTQ0x5411TIOCSPGRP0x5410TIOCGPGRP0x540FTIOCSCTTY0x540ETIOCNXCL0x540DTIOCEXCL0x540CTCFLSH0x540BTCXONC0x540ATCSBRK0x5409TCSETAF0x5408TCSETAW0x5407TCSETA0x5406TCGETA0x5405TCSETSF0x5404TCSETSW0x5403TCSETS0x5402TCGETS0x5401__ASM_GENERIC_IOCTLS_H/* __ASM_GENERIC_IOCTLS_H *//* Transmitter physically empty *//* Used for packet mode *//*
 * Some arches already define FIOQSIZE due to a historical
 * conflict with a Hayes modem-specific ioctl value.
 *//* read serial port __inline__ interrupt counts *//* wait for a change on serial input line(s) *//* Set multiport config *//* Get multiport config  *//* Get line status register *//* For debugging only *//* Safely open the slave *//* Get exclusive mode state *//* Get Pty lock state *//* Get packet mode state *//* pty: generate signal *//* SYS5 TCGETX compatibility *//* Get primary device node of /dev/console *//* Lock/unlock Pty *//* Get Pty Number (of pty-mux device) *//* Return the session ID of FD *//* BSD compatibility *//* Needed for POSIX tcsendbreak() *//* 0x54 is just a magic number to make these relatively unique ('T') *//*
 * These are the most common definitions for tty ioctl numbers.
 * Most of them do not use the recommended _IOC(), but there is
 * probably some source code out there hardcoding the number,
 * so we might as well use them for all new platforms.
 *
 * The architectures that use different values here typically
 * try to be compatible with some Unix variants for the same
 * architecture.
 *//usr/include/x86_64-linux-gnu/asm/ioctls.h<asm-generic/ioctls.h>/usr/include/x86_64-linux-gnu/bits/ioctls.h<asm/ioctls.h>SIOCPROTOPRIVATE0x89E0SIOCDEVPRIVATE0x89F0SIOCDELDLCI0x8981SIOCADDDLCI0x8980SIOCSIFMAP0x8971SIOCGIFMAP0x8970SIOCSRARP0x8962SIOCGRARP0x8961SIOCDRARP0x8960SIOCSARP0x8955SIOCGARP0x8954SIOCDARP0x8953SIOCSIFTXQLEN0x8943SIOCGIFTXQLEN0x8942SIOCSIFBR0x8941SIOCGIFBR0x8940SIOCGIFCOUNT0x8938SIOCSIFHWBROADCAST0x8937SIOCDIFADDR0x8936SIOCGIFPFLAGS0x8935SIOCSIFPFLAGS0x8934SIOGIFINDEXSIOCGIFINDEX0x8933SIOCDELMULTI0x8932SIOCADDMULTI0x8931SIOCSIFSLAVE0x8930SIOCGIFSLAVE0x8929SIOCGIFHWADDR0x8927SIOCSIFENCAP0x8926SIOCGIFENCAP0x8925SIOCSIFHWADDR0x8924SIOCSIFNAME0x8923SIOCSIFMTU0x8922SIOCGIFMTU0x8921SIOCSIFMEM0x8920SIOCGIFMEM0x891fSIOCSIFMETRIC0x891eSIOCGIFMETRIC0x891dSIOCSIFNETMASK0x891cSIOCGIFNETMASK0x891bSIOCSIFBRDADDR0x891aSIOCGIFBRDADDR0x8919SIOCSIFDSTADDR0x8918SIOCGIFDSTADDR0x8917SIOCSIFADDR0x8916SIOCGIFADDR0x8915SIOCSIFFLAGS0x8914SIOCGIFFLAGS0x8913SIOCGIFCONF0x8912SIOCSIFLINK0x8911SIOCGIFNAME0x8910SIOCRTMSG0x890DSIOCDELRT0x890CSIOCADDRT0x890B_SYS_IOCTL_H/* to 89EF *//*
 *	These 16 ioctl calls are protocol private
 *//* to 89FF *//* These 16 ioctls are available to devices via the do_ioctl() device
   vector.  Each device should include this file and redefine these
   names as their own. Because these are device dependent it is a good
   idea _NOT_ to issue them to random objects and hope.  *//* Device private ioctl calls.  *//* Delete DLCI device		*//* Create new DLCI device	*//* DLCI configuration calls *//* Set device parameters	*//* Get device parameters	*//* Driver configuration calls *//* set RARP table entry		*//* get RARP table entry		*//* delete RARP table entry	*//* RARP cache control calls. *//* set ARP table entry		*//* get ARP table entry		*//* delete ARP table entry	*//*  0x8950 - 0x8952  * obsolete calls, don't re-use *//* ARP cache control calls. *//* Set the tx queue length 	*//* Get the tx queue length	*//* Set bridging options 	*//* Bridging support		*//* get number of devices *//* set hardware broadcast addr	*//* delete PA address		*//* set/get extended flags set	*//* misprint compatibility :-)	*//* name -> if_index mapping	*//* Multicast address lists	*//* Driver slaving support	*//* Get hardware address		*//* get/set encapsulations       *//* set hardware address 	*//* set interface name		*//* set MTU size			*//* get MTU size			*//* set memory address (BSD)	*//* get memory address (BSD)	*//* set metric			*//* get metric			*//* set network PA mask		*//* get network PA mask		*//* set broadcast PA address	*//* get broadcast PA address	*//* set remote PA address	*//* get remote PA address	*//* set PA address		*//* get PA address		*//* set flags			*//* get flags			*//* get iface list		*//* set iface channel		*//* get iface name		*//* Socket configuration controls. *//* call to routing system	*//* delete routing table entry	*//* add routing table entry	*//* Routing table calls.  *//* Use the definitions from the kernel header files.  *//* Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/bits/ioctl-types.htermiowinsizeunsigned char[8]NCCc_ccc_linec_lflagc_cflagc_oflagc_iflagws_ypixelws_xpixelws_colws_rowN_HCIN_SYNC_PPPN_HDLCN_SMSBLOCKN_IRDAN_PROFIBUS_FDLN_R3964N_MASCN_6PACKN_X25N_AX25N_STRIPN_PPPN_MOUSEN_SLIPN_TTYTIOCM_RITIOCM_RNGTIOCM_CDTIOCM_CARTIOCM_DSR0x0800x040TIOCM_CTS0x020TIOCM_SR0x010TIOCM_ST0x008TIOCM_RTS0x004TIOCM_DTR0x002TIOCM_LE0x001/* Bluetooth HCI UART  *//* synchronous PPP  *//* synchronous HDLC  *//* SMS block mode  *//* Linux IR  *//* Profibus  *//* Simatic R3964 module  *//* Mobitex module  *//* X.25 async  *//* line disciplines *//* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below *//* modem lines *//* control characters *//* line discipline *//* local mode flags *//* control mode flags *//* output mode flags *//* input mode flags *//* Get definition of constants for use with `ioctl'.  *//* Structure types for pre-termios terminal ioctls.  Linux version.
   Copyright (C) 1996-2022 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   <https://www.gnu.org/licenses/>.  *//usr/include/x86_64-linux-gnu/sys/ttydefaults.hCFLUSHCDISCARDCRPRNTCREPRINTCBRKCEOLCEOTCEOFCTRL('r')CWERASECTRL('w')CTRL('o')CLNEXTCTRL('v')CSTOPCTRL('s')CSTARTCTRL('q')CDSUSPCTRL('y')CTIMECSUSPCTRL('z')CQUIT034CMINCKILLCTRL('u')CSTATUS_POSIX_VDISABLECINTRCTRL('c')CERASE0177CTRL('d')CTRL(x)(x&037)TTYDEF_SPEED(B9600)TTYDEF_CFLAG(CREAD | CS7 | PARENB | HUPCL)TTYDEF_LFLAG(ECHO | ICANON | ISIG | IEXTEN | ECHOE|ECHOKE|ECHOCTL)TTYDEF_OFLAG(OPOST | ONLCR | XTABS)TTYDEF_IFLAG(BRKINT | ISTRIP | ICRNL | IMAXBEL | IXON | IXANY)_SYS_TTYDEFAULTS_H_TTYDEFCHARS/*
 * #define TTYDEFCHARS to include an array of default control characters.
 *//* !_SYS_TTYDEFAULTS_H_ *//* PROTECTED INCLUSION ENDS HERE *//* compat *//* FS, ^\ *//* XXX avoid _POSIX_VDISABLE *//*
 * Control Character Defaults
 *//*
 * Defaults on "first" open.
 *//*
 * System wide defaults for terminal state.  Linux version.
 *//*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ttydefaults.h	8.4 (Berkeley) 1/21/94
 *//usr/include/x86_64-linux-gnu/sys/ioctl.h<sys/ttydefaults.h><bits/ioctl-types.h><bits/ioctls.h>ioctl/* sys/ioctl.h *//* Perform the I/O control operation specified by REQUEST on FD.
   One argument may follow; its presence and type depend on REQUEST.
   Return value depends on REQUEST.  Usually -1 indicates error.  *//* On a Unix system, the system <sys/ioctl.h> probably defines some of
   the symbols we define in <sys/ttydefaults.h> (usually with the same
   values).  The code to generate <bits/ioctls.h> has omitted these
   symbols to avoid the conflict, but a Unix program expects <sys/ioctl.h>
   to define them, so we must include <sys/ttydefaults.h> here.  *//* Define some types used by `ioctl' requests.  *//* Get the list of `ioctl' requests and related constants.  *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/fmemopen.c<sys/ioctl.h>fmem_cookie_t *fmem_cookie_s *cookiefmemc_get_buf_addr_t *gbaFMEMC_GET_BUF_ADDRfmemc_get_buf_addr_t_IOC_READ|_IOC_WRITE2U|1U('m')(FMEMC_GET_BUF_ADDR)(_IOC_TYPECHECK(fmemc_get_buf_addr_t))((sizeof(fmemc_get_buf_addr_t)))3221225472279043221253376322125337720971523223350529const cookie_fp_map_tconst cookie_fp_map_t *pmapmctbuf_bytes_t *FMEMC_GBUF_LEAVE_OWNERSHIPFLAG_BIT(allocated)18446744073709551551(unsigned long)~FLAG_BIT(allocated)pFMCmode_bits_t *sizeof(fmem_cookie_t)ENOMEMfixed_sizeFLAG_BIT(fixed_size)appendFLAG_BIT(append)FLAG_BIT(truncate)FLAG_BIT(append) | FLAG_BIT(truncate)(FLAG_BIT(append) | FLAG_BIT(truncate))cookie_read_function_t *pRdreadFLAG_BIT(read)cookie_write_function_t *pWrFLAG_BIT(write)iofcookie_seek_function_t *__off64_t *cookie_close_function_t *sizeof(*map)cookie_fp_map_t *fmem_alloc_buffmem_config_user_bufbinaryFLAG_BIT(binary)fmem_closefmem_seeknew_posSEEK_CURSEEK_ENDseek_oopsfmem_writeadd_nul_charnext_posfmem_readfmem_extendnsno_spaceENOSPCfmem_getmode'a'FLAG_BIT(write) | FLAG_BIT(append)FLAG_BIT(write) | FLAG_BIT(truncate)FLAG_BIT(read) | FLAG_BIT(write)98cookie_fp_map_tfmem_cookie_tfmem_cookie_sbuf_bytes_tmode_bits_tfmem_flags_eBIT_ID_readBIT_ID_writeBIT_ID_appendBIT_ID_binaryBIT_ID_createBIT_ID_truncateBIT_ID_allocatedBIT_ID_fixed_sizeBIT_CTseek_ret_toff64_t *seek_off_tFMEMC_GBUF_TAKE_OWNERSHIPfmemctl_tFMEMC_INVALIDpg_sizeeofbuf_sizeownmap_alloc_ctmap_ctFLAG_BIT(n)(1 << BIT_ID_ ## n)_Prop__Prop_(n,s)BIT_ID_ ## n,PROP_TABLE_Prop_( read, "Read from buffer" ) _Prop_( write, "Write to buffer" ) _Prop_( append, "Append to buffer okay" ) _Prop_( binary, "byte data - not string" ) _Prop_( create, "allocate the string" ) _Prop_( truncate, "start writing at start" ) _Prop_( allocated, "we allocated the buffer" ) _Prop_( fixed_size, "writes do not append" )IOCTL_FMEMC_GET_BUF_ADDR_IOWR('m', FMEMC_GET_BUF_ADDR, fmemc_get_buf_addr_t)defined(HAVE_FOPENCOOKIE)defined(HAVE_LIBIO_H)defined(HAVE_FUNOPEN)NEED_COOKIE_FUNCTION_TYPEDEFSTEST_FMEMOPENHAVE_FOPENCOOKIE"writes do not append""we allocated the buffer""start writing at start"create"allocate the string""byte data - not string""Append to buffer okay""Write to buffer""Read from buffer"/* ENABLE_FMEMOPEN *//*
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of fmemopen.c *//*
                 *  fmemopen didn't create this FILE *, so it is invalid.
                 *//*
         *  It is not any of the IOCTL commands we know about.
         *//*=export_func ag_fmemioctl
 *
 *  what:  perform an ioctl on a FILE * descriptor
 *
 *  arg: + FILE * + fp      + file pointer  +
 *  arg: + int   + req     + ioctl command +
 *  arg: + ...   + varargs + arguments for command +
 *
 *  ret-type:  int
 *  ret-desc:  zero on success, otherwise error in errno
 *
 *  err:  errno is set to @code{EINVAL} or @code{ENOSPC}.
 *
 *  doc:
 *
 *  The file pointer passed in must have been returned by ag_fmemopen.
=*//* "fclose" set it to "EINVAL". *//*
         *  Not appending and not truncating.  We must be reading.
         *  We also have no user supplied buffer.  Nonsense.
         *//*
         *  We only need page size if we might extend an allocation.
         *//*
     *  Two more mode bits that do not come from the mode string:
     *  a negative size implies fixed size buffer and a NULL
     *  buffer pointer means we must allocate (and free) it.
     *//*=export_func ag_fmemopen
 *
 *  what:  Open a stream to a string
 *
 *  arg: + void *  + buf  + buffer to use for i/o +
 *  arg: + ssize_t + len  + size of the buffer +
 *  arg: + char *  + mode + mode string, a la fopen(3C) +
 *
 *  ret-type:  FILE *
 *  ret-desc:  a stdio FILE * pointer
 *
 *  err:  NULL is returned and errno is set to @code{EINVAL} or @code{ENOSPC}.
 *
 *  doc:
 *
 *  This function requires underlying @var{libc} functionality:
 *  either @code{fopencookie(3GNU)} or @code{funopen(3BSD)}.
 *
 *  If @var{buf} is @code{NULL}, then a buffer is allocated.  The initial
 *  allocation is @var{len} bytes.  If @var{len} is less than zero, then the
 *  buffer will be reallocated as more space is needed.  Any allocated
 *  memory is @code{free()}-ed when @code{fclose(3C)} is called.
 *
 *  If @code{buf} is not @code{NULL}, then @code{len} must not be zero.
 *  It may still be less than zero to indicate that the buffer may
 *  be reallocated.
 *
 *  The mode string is interpreted as follows.  If the first character of
 *  the mode is:
 *
 *  @table @code
 *  @item a
 *  Then the string is opened in "append" mode.  In binary mode, "appending"
 *  will begin from the end of the initial buffer.  Otherwise, appending will
 *  start at the first NUL character in the initial buffer (or the end of the
 *  buffer if there is no NUL character).  Do not use fixed size buffers
 *  (negative @var{len} lengths) in append mode.
 *
 *  @item w
 *  Then the string is opened in "write" mode.  Any initial buffer is presumed
 *  to be empty.
 *
 *  @item r
 *  Then the string is opened in "read" mode.
 *  @end table
 *
 *  @noindent
 *  If it is not one of these three, the open fails and @code{errno} is
 *  set to @code{EINVAL}.  These initial characters may be followed by:
 *
 *  @table @code
 *  @item +
 *  The buffer is marked as updatable and both reading and writing is enabled.
 *
 *  @item b
 *  The I/O is marked as "binary" and a trailing NUL will not be inserted
 *  into the buffer.  Without this mode flag, one will be inserted after the
 *  @code{EOF}, if it fits.  It will fit if the buffer is extensible (the
 *  provided @var{len} was negative).  This mode flag has no effect if
 *  the buffer is opened in read-only mode.
 *
 *  @item x
 *  This is ignored.
 *  @end table
 *
 *  @noindent
 *  Any other letters following the inital 'a', 'w' or 'r' will cause an error.
=*//*
     *  We've allocated the buffer.  The end of file and next entry
     *  are both zero.
     *//*
     *  Unallocated file space is set to NULs.  Emulate that.
     *//*
     *  We must allocate the buffer.  If "len" is zero, set it to page size.
     *//**
 * Allocate an initial buffer for fmem.
 *//*
     *  text mode - NUL terminate buffer, if it fits.
     *//*
         * append or read text mode -- find the end of the buffer
         * (the first NUL character)
         *//*
         *  "write" mode
         *//*  Figure out where our "next byte" and EOF are.
     *  Truncated files start at the beginning.
     *//*
     *  User allocated buffer.  User responsible for disposal.
     *//**
 * Configure the user supplied buffer.
 *//**
 * Free up the memory associated with an fmem file.
 * If the user is managing the space, then the allocated bit is set.
 *//* errno is set *//*
     *  BSD interface:  offset passed by value, returned as retval.
     *//*
     *  GNU interface:  offset passed and returned by address.
     *//**
 * Handle file system callback to set a new current position
 *//*
             *  There is space for this NUL.  The "add_nul_char" is not part of
             *  the "sz" that was added to "next_ix".
             *//*
     *  Check for new high water mark and remember it.  Add a NUL if
     *  we do that and if we have a new high water mark.
     *//*
                 *  Never add the NUL for a truncated write.  "sz" may be
                 *  unchanged or limited here.
                 *//* no space at all.  errno is set. *//*
                 *  We could not extend the memory.  Try to write some data.
                 *  Fail if we are either at the end or not writing data.
                 *//*
     *  Only add a NUL character if:
     *
     *  * we are not in binary mode
     *  * there are data to write
     *  * the last character to write is not already NUL
     *//*
     *  In append mode, always seek to the end before writing.
     *//**
 * Handle file system callback to write data to our string
 *//**
 * Handle file system callback to read data from our string.
 *//*
     *  Unallocated file space is set to zeros.  Emulate that.
     *//*
         *  Previously, this was a user supplied buffer.  We now move to one
         *  of our own.  The user is responsible for the earlier memory.
         *//*
     *  We can expand the buffer only if we are in append mode.
     *//**
 * Extend the space associated with an fmem file.
 *//*
     *  If someone wants to supply a "wxxbxbbxbb+" mode string, I don't care.
     *//**
 * Convert a mode string into mode bits.
 *//* size of a memory page.
                                   Future architectures allow it to vary
                                   by memory region. *//* End Of File *//* Current position *//* Full size of buffer *//* NEED_COOKIE_FUNCTION_TYPEDEFS *//**
 * @file fmemopen.c
 *
 * Copyright (C) 2004-2014 by Bruce Korb.  All rights reserved.
 *
 * This code was inspired from software written by
 *   Hanno Mueller, kontakt@hanno.de
 * and completely rewritten by Bruce Korb, bkorb@gnu.org
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */pBufpRes/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/pseudo-fsm.hpm_invalid_transitionconst char[169]char[169]169PmFsmErr_offconst size_t[5]unsigned long[5]const size_t[8]unsigned long[8]t_pm_transitionpm_transitionte_pm_transPM_TR_INIT_MARKERPM_TR_INVALIDPM_TR_NOOPPM_TR_SKIP_ED_MODEPM_TR_TEMPL_MARKERPM_TR_TEMPL_SCHEMEPM_TR_TEMPL_SUFFIXte_pm_eventPM_EV_ED_MODEPM_EV_MARKERPM_EV_END_PSEUDOPM_EV_AUTOGENPM_EV_TEMPLATEPM_EV_SUFFIXPM_EV_SCHEMEPM_EV_INVALIDte_pm_statePM_ST_INITPM_ST_ST_MARKPM_ST_AGENPM_ST_TEMPLPM_ST_END_MARKPM_ST_INVALIDPM_ST_DONEaszPmEvents155162aszPmStates107zPmStrings** OUT-OF-RANGE ** FSM Error:  in state %d (%s), event %d (%s) is invalid
 invalid init st_mark agen templ end_mark -*- marker end_pseudo autogen template suffix scheme"** OUT-OF-RANGE **\0"
/*    19 */ "FSM Error:  in state %d (%s), event %d (%s) is invalid\n\0"
/*    75 */ "invalid\0"
/*    83 */ "init\0"
/*    88 */ "st_mark\0"
/*    96 */ "agen\0"
/*   101 */ "templ\0"
/*   107 */ "end_mark\0"
/*   116 */ "-*-\0"
/*   120 */ "marker\0"
/*   127 */ "end_pseudo\0"
/*   138 */ "autogen\0"
/*   146 */ "template\0"
/*   155 */ "suffix\0"
/*   162 */ "scheme"const t_pm_transitionconst t_pm_transition[7]pm_transition[7]PM_EVENT_CTconst t_pm_transition[5][7]pm_transition[5][7]PM_STATE_CTpm_trans_tablePM_STATE_NAME(s)( (((unsigned)(s)) >= 5) ? zPmStrings : zPmStrings + aszPmStates[s])PM_EVT_NAME(t)( (((unsigned)(t)) >= 8) ? zPmStrings : zPmStrings + aszPmEvents[t])PmStInit_offPmEvInvalid_offPM_TRANSITION_CTAUTOFSM_PSEUDO_FSM_H_GUARD/*
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of pseudo-fsm.h *//* AUTOFSM_PSEUDO_FSM_H_GUARD *//* DEFINE_FSM *//*   162 *//*   155 *//*   146 *//*   138 *//*   107 *//*   101 *//* EVT:  SCHEME *//* EVT:  SUFFIX *//* EVT:  TEMPLATE *//* EVT:  END_PSEUDO *//* EVT:  MARKER *//* EVT:  -*- *//* STATE 4:  PM_ST_END_MARK *//* STATE 3:  PM_ST_TEMPL *//* STATE 2:  PM_ST_AGEN *//* STATE 1:  PM_ST_ST_MARK *//* STATE 0:  PM_ST_INIT *//*
 *  This file enumerates the states and transition events for a FSM.
 *
 *  te_pm_state
 *      The available states.  FSS_INIT is always defined to be zero
 *      and FSS_INVALID and FSS_DONE are always made the last entries.
 *
 *  te_pm_event
 *      The transition events.  These enumerate the event values used
 *      to select the next state from the current state.
 *      PM_EV_INVALID is always defined at the end.
 *//*   -*- buffer-read-only: t -*- vi: set ro:
 *
 *  DO NOT EDIT THIS FILE   (pseudo-fsm.h)
 *
 *  It has been AutoGen-ed
 *  From the definitions    pseudo.def
 *  and the template file   fsm
 *
 *  Automated Finite State Machine
 *
 *  Copyright (C) 1992-2015 Bruce Korb - all rights reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name ``Bruce Korb'' nor the name of any other
 *    contributor may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * AutoFSM IS PROVIDED BY Bruce Korb ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bruce Korb OR ANY OTHER CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/loadPseudo.c"pseudo-fsm.h"pzBadnessfsm_statefsm_tknnxt_stateconst t_pm_transition(*)[7]pm_transition(*)[7]const t_pm_transition *pm_transition *7683pzNL75417432739574627620756676387587760372387659abort_loadaprf(PSEUDO_MAC_ERR_FMT, fname, tpl_line, pzBadness)aprf((ag_text_strtable+7499), fname, tpl_line, pzBadness)7499copy_mark33554432sizeof(st_mac_mark)14841next_pm_tokenline_startskipWhiteSpace*texttext[ AG_MARK_LEN ]text[ 8 ]text[ TPL_MARK_LEN ]1455668878336aprf(NEXT_PM_TOKEN_INVALID, fnm)aprf((ag_text_strtable+6664), fnm)6664handle_hash_line3682len + HANDLE_HASH_SHELL_LEN + 1len + 6 + 1"set shell"nmbuf"prog shell"server_args[0]"shell name"ret_ctptextfnmX_OK3704pOSpzSfxFmtpzResultspnout_spec_t **out_spec **ppOSList2072SELECT_SUFFIX& DESC(SELECT_SUFFIX)& (autogenOptions.pOptDesc[INDEX_OPT_SELECT_SUFFIX])sizeof(*pOS)"Output Specification"aprf(DO_SUFFIX_BAD_CHARS, pz)aprf((ag_text_strtable+2036), pz)pOS->os_file_fmt"suffix format"pOS->os_sfx[0]sfx_lenstr_length2036186912390do_scheme_exprpCM(mac_func_t)~0BAD_MARKERBAD_MARKER(t){ pzBadness = t; goto abort_load; }/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/loadPseudo.c *//*
             *  IF the end macro seems to end with the start macro and
             *  it is exactly twice as long as the start macro, then
             *  presume that someone ran the two markers together.
             *//*
         *  There are only so many "PM_TR_<state-name>_<token-name>"
         *  transitions that are legal.  See which one we got.
         *  It is legal to alter "nxt_state" while processing these.
         *//**
 *  Using a finite state machine, scan over the tokens that make up the
 *  "pseudo macro" at the start of every template.
 *
 *  @param[in,out]  text    text of template
 *  @param[in]      fname   name of template file
 *  @returns the address of the byte following the pseudo macro
 *//**
 *  Some sort of marker is under the scan pointer.  Copy it for as long
 *  as we find punctuation characters.
 *//*
     *  Otherwise, it is just junk.
     *//*
     *  IF it is some other punctuation,
     *  THEN it must be a start/end marker.
     *//*
     *  Alphanumerics and underscore are already handled.  Thus, it must be
     *  a punctuation character that may introduce a suffix:  '.' '-' '_'
     *//*
     *  Handle emacs mode markers and scheme expressions only once we've
     *  gotten past "init" state.
     *//*
     *  IF the token starts with an alphanumeric,
     *  THEN it must be "autogen5" or "template" or a suffix specification
     *//*
     *  After the end marker has been found,
     *  anything else is really the start of the data.
     *//* in case we return *//*
             *  IF we are done with the macro markers,
             *  THEN we skip white space only thru the first new line.
             *//*
     *  At the start of processing in this function, we can never be at
     *  the "start of a line".  A '#' type comment before the initial
     *  start macro marker is illegal.  Otherwise, our scan pointer is
     *  after some valid token, which won't be the start of a line, either.
     *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  next_pm_token
 *
 *  Skiping leading white space, figure out what sort of token is under
 *  the scan pointer (text).
 *//*
         *  If we find the executable, then change the configured shell and
         *  the SHELL environment variable to this executable.
         *//*
     *  If the comment starts with "#!/", then see if it names
     *  an executable.  If it does, it is specifying a shell to use.
     *//*
         *  IF the suffix does not start with punctuation,
         *  THEN we will insert a '.' of our own.
         *//*
             *  IF the scheme replacement text fits in the space, don't
             *  mess with allocating another string.
             *//*
     *  IF the suffix contains its own formatting construct,
     *  THEN split it off from the suffix and set the formatting ptr.
     *  ELSE supply a default.
     *//* NULL, from memset *//*
     *  Allocate Output Spec and link into the global list.  Copy all the
     *  "spanned" text, including any '=' character, scheme expression or
     *  file name format string.
     *//*
     *  If fname is NULL, then we are called by --select-suffix.
     *  Otherwise, the suffix construct is saved only for the main template,
     *  and only when the --select-suffix option was not specified.
     *//*
     *  Skip over the suffix construct
     *//*
     *  The following is the complete list of POSIX required-to-be-legal
     *  file name characters.  These are the only characters we allow to
     *  appear in a suffix.  We do, however, add '=' and '%' because we
     *  also allow a format specification to follow the suffix,
     *  separated by an '=' character.
     *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  do_suffix
 *
 *  Process a suffix specification
 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  do_scheme_expr
 *
 *  Process a scheme specification
 *//**
 * @file loadPseudo.c
 *
 *  Find the start and end macro markers.  In btween we must find the
 *  "autogen" and "template" keywords, followed by any suffix specs.
 *
 *  This module processes the "pseudo" macro.
 *
 * @addtogroup autogen
 * @{
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/opts.c"fserr %d (%s) performing '%s' on %s\n"fserr_fmtfserr %d (%s) performing '%s' on %s
"autogen fatal error:\n"die_leaderautogen fatal error:
"autogen usage error:\n"er_leaderautogen usage error:
doOptSelect_SuffixdoOptTraceconst char *const[7]char *[7]namesOPTPROC_EMIT_LIMITOPTST_RESETconst char[3234]char[3234]32343153316131753188319832113223doOptTimeoutconst struct <unnamed>const struct <unnamed>[1]const struct <unnamed> *emit_ranges3600doOptLoop_Limitconst struct <unnamed>[2]167772160x1000000doOptShelldoOptLib_TemplatedoOptOverride_TpldoUsageOptex_codeconst uint16_t10064AO_EXIT_REQ_USAGEinit_proc_trmaxrminOPTIONS_STRUCT_VERSIONOPTPROC_ERRSTOPOPTPROC_SHORTOPTOPTPROC_LONGOPTOPTPROC_NO_REQ_OPTOPTPROC_NEGATIONS151OPTPROC_ENVIRON407( OPTPROC_BASE
    + OPTPROC_ERRSTOP
    + OPTPROC_SHORTOPT
    + OPTPROC_LONGOPT
    + OPTPROC_NO_REQ_OPT
    + OPTPROC_NEGATIONS
    + OPTPROC_ENVIRON )273428932713124const char *const[3]char *[3]274229403011tOptDesc[35]opt_desc[35]tOptionXlateProc *NO_EQUIVALENTautogen_full_usageautogen_short_usageconst opt_arg_union_tconst opt_arg_union_t[35]union <unnamed>[35]const opt_arg_union_t *void *constvoid *const[35]void *[35]void *const */usr/share/autogenoriginal_autogen_cookiespOptionsoriginal_autogen_defaultsLOOP_LIMIT_DFT_ARGTRACE_DFT_ARGapzHomeList28852891optDescOPARG_TYPE_STRINGOPARG_TYPE_NUMERICOPARG_TYPE_ENUMERATION2097408INPUT_SELECT_FLAGSconst int *8745152TEMPL_DIRS_FLAGS9559839944384OVERRIDE_TPL_FLAGS100510351048108671088646710889667112992LIB_TEMPLATE_FLAGS1061110811216400DEFINITIONS_FLAGS113411611173118840984128SHELL_FLAGS119112251231NO_FMEMOPEN_FLAGS1237126312754099EQUATE_FLAGS128713201327OUT_HANDLING_FLAGS1338BASE_NAME_FLAGS1390143114414100SOURCE_TIME_FLAGS145114821494WRITABLE_FLAGS1509154315521565DEBUG_TPL_FLAGS15694102204802051216797728LOOP_LIMIT_FLAGS163916641675TIMEOUT_FLAGS168617271735410381928224TRACE_FLAGS1743176717734104TRACE_OUT_FLAGS1779180918194105524544SHOW_DEFS_FLAGSSHOW_DEFS_DESC18644106USED_DEFINES_FLAGS18741900191367CORE_FLAGS192619621967PROCESSING_FLAGS197213125408SKIP_SUFFIX_FLAGSconst int[2]207421052117SELECT_SUFFIX_FLAGS212921562170DEFINE_FLAGS218422152222UNDEFINE_FLAGS222922612270DEP_TRACK_FLAGS69920MAKE_DEP_FLAGS233223582367AUTOOPTS_OPTS_FLAGS2376824352RESET_FLAGSAOUSE_RESET_OPTION2559258311869632131072200704200960VER_FLAGSAOUSE_VERSION25152551OPTST_IMMOPTST_NO_INIT131328AOUSE_HELP24112455MORE_HELP_FLAGSAOUSE_MORE_HELP24602505AOUSE_USAGE25962624OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)OPTST_ARG_OPTIONAL69888AOUSE_SAVE_OPTS26302669OPTST_DISABLE_IMM266240AOUSE_LOAD_OPTS267927112721const int[]int[]aSkip_SuffixCantListautogen_opt_strsautogen (GNU AutoGen) 5.18.7
Copyright (C) 1992-2015 Bruce Korb, all rights reserved.
This is free software. It is licensed for use, modification and
redistribution under the terms of the GNU General Public License,
version 3 or later <http://gnu.org/licenses/gpl.html>
 autogen is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option)
any later version.

autogen is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along
with this program.  If not, see <http://www.gnu.org/licenses/>.
 The following options select definitions, templates and scheme functions
to use: Search for templates in DIR TEMPL_DIRS templ-dirs Use TPL-FILE for the template OVERRIDE_TPL override-tpl Load AutoGen macros from TPL-FILE (deprecated) LIB_TEMPLATE lib-template Read definitions from FILE DEFINITIONS no-definitions no name or path name of shell to use SHELL shell Do not use in-mem streams NO_FMEMOPEN no-fmemopen characters considered equivalent EQUATE equate _-^ The following options modify how output is handled: Specify NAME as the base name for output BASE_NAME base-name set mod times to latest source SOURCE_TIME no-source-time Allow output files to be writable WRITABLE not-writable not The following options are often useful while debugging new templates: Limit on increment loops LOOP_LIMIT loop-limit Limit server shell operations to SECONDS TIMEOUT timeout tracing level of detail TRACE trace tracing output file or filter TRACE_OUT trace-out Show the definition tree SHOW_DEFS show-defs Show the definitions used USED_DEFINES used-defines Leave a core dump on a failure exit CORE core These options can be used to control what gets processed in the
definitions files and template files: Skip the file with this SUFFIX SKIP_SUFFIX skip-suffix specify this output suffix SELECT_SUFFIX select-suffix name to add to definition list DEFINE define definition list removal pattern UNDEFINE undefine This option is used to automate dependency tracking: emit make dependency file MAKE_DEP make-dep help, version and option handling: display extended usage information and exit help extended usage information passed thru pager more-help output version information and exit version reset an option's state reset-option abbreviated usage to stdout usage save the option state to a config file save-opts load options from a config file LOAD_OPTS no-load-opts AUTOGEN autogen (GNU AutoGen) - The Automated Program Generator - Ver. 5.18.7
Usage:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [ <def-file> ]
 $HOME . .autogenrc autogen-users@lists.sourceforge.net AutoGen creates text files from templates using external definitions.
 AutoGen is a tool designed for generating program files that contain
repetitive text with varied substitutions.
 autogen (GNU AutoGen) 5.18.7 nothing debug-message server-shell templates block-macros expressions everything"autogen (GNU AutoGen) 5.18.7\n"
            "Copyright (C) 1992-2015 Bruce Korb, all rights reserved.\n"
            "This is free software. It is licensed for use, modification and\n"
            "redistribution under the terms of the GNU General Public License,\n"
            "version 3 or later <http://gnu.org/licenses/gpl.html>\n\0"
/*   271 */ "autogen is free software: you can redistribute it and/or modify it under\n"
            "the terms of the GNU General Public License as published by the Free\n"
            "Software Foundation, either version 3 of the License, or (at your option)\n"
            "any later version.\n\n"
            "autogen is distributed in the hope that it will be useful, but WITHOUT ANY\n"
            "WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n"
            "FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n"
            "details.\n\n"
            "You should have received a copy of the GNU General Public License along\n"
            "with this program.  If not, see <http://www.gnu.org/licenses/>.\n\0"
/*   874 */ "The following options select definitions, templates and scheme functions\n"
            "to use:\0"
/*   955 */ "Search for templates in DIR\0"
/*   983 */ "TEMPL_DIRS\0"
/*   994 */ "templ-dirs\0"
/*  1005 */ "Use TPL-FILE for the template\0"
/*  1035 */ "OVERRIDE_TPL\0"
/*  1048 */ "override-tpl\0"
/*  1061 */ "Load AutoGen macros from TPL-FILE (deprecated)\0"
/*  1108 */ "LIB_TEMPLATE\0"
/*  1121 */ "lib-template\0"
/*  1134 */ "Read definitions from FILE\0"
/*  1161 */ "DEFINITIONS\0"
/*  1173 */ "no-definitions\0"
/*  1188 */ "no\0"
/*  1191 */ "name or path name of shell to use\0"
/*  1225 */ "SHELL\0"
/*  1231 */ "shell\0"
/*  1237 */ "Do not use in-mem streams\0"
/*  1263 */ "NO_FMEMOPEN\0"
/*  1275 */ "no-fmemopen\0"
/*  1287 */ "characters considered equivalent\0"
/*  1320 */ "EQUATE\0"
/*  1327 */ "equate\0"
/*  1334 */ "_-^\0"
/*  1338 */ "The following options modify how output is handled:\0"
/*  1390 */ "Specify NAME as the base name for output\0"
/*  1431 */ "BASE_NAME\0"
/*  1441 */ "base-name\0"
/*  1451 */ "set mod times to latest source\0"
/*  1482 */ "SOURCE_TIME\0"
/*  1494 */ "no-source-time\0"
/*  1509 */ "Allow output files to be writable\0"
/*  1543 */ "WRITABLE\0"
/*  1552 */ "not-writable\0"
/*  1565 */ "not\0"
/*  1569 */ "The following options are often useful while debugging new templates:\0"
/*  1639 */ "Limit on increment loops\0"
/*  1664 */ "LOOP_LIMIT\0"
/*  1675 */ "loop-limit\0"
/*  1686 */ "Limit server shell operations to SECONDS\0"
/*  1727 */ "TIMEOUT\0"
/*  1735 */ "timeout\0"
/*  1743 */ "tracing level of detail\0"
/*  1767 */ "TRACE\0"
/*  1773 */ "trace\0"
/*  1779 */ "tracing output file or filter\0"
/*  1809 */ "TRACE_OUT\0"
/*  1819 */ "trace-out\0"
/*  1829 */ "Show the definition tree\0"
/*  1854 */ "SHOW_DEFS\0"
/*  1864 */ "show-defs\0"
/*  1874 */ "Show the definitions used\0"
/*  1900 */ "USED_DEFINES\0"
/*  1913 */ "used-defines\0"
/*  1926 */ "Leave a core dump on a failure exit\0"
/*  1962 */ "CORE\0"
/*  1967 */ "core\0"
/*  1972 */ "These options can be used to control what gets processed in the\n"
            "definitions files and template files:\0"
/*  2074 */ "Skip the file with this SUFFIX\0"
/*  2105 */ "SKIP_SUFFIX\0"
/*  2117 */ "skip-suffix\0"
/*  2129 */ "specify this output suffix\0"
/*  2156 */ "SELECT_SUFFIX\0"
/*  2170 */ "select-suffix\0"
/*  2184 */ "name to add to definition list\0"
/*  2215 */ "DEFINE\0"
/*  2222 */ "define\0"
/*  2229 */ "definition list removal pattern\0"
/*  2261 */ "UNDEFINE\0"
/*  2270 */ "undefine\0"
/*  2279 */ "This option is used to automate dependency tracking:\0"
/*  2332 */ "emit make dependency file\0"
/*  2358 */ "MAKE_DEP\0"
/*  2367 */ "make-dep\0"
/*  2376 */ "help, version and option handling:\0"
/*  2411 */ "display extended usage information and exit\0"
/*  2455 */ "help\0"
/*  2460 */ "extended usage information passed thru pager\0"
/*  2505 */ "more-help\0"
/*  2515 */ "output version information and exit\0"
/*  2551 */ "version\0"
/*  2559 */ "reset an option's state\0"
/*  2583 */ "reset-option\0"
/*  2596 */ "abbreviated usage to stdout\0"
/*  2624 */ "usage\0"
/*  2630 */ "save the option state to a config file\0"
/*  2669 */ "save-opts\0"
/*  2679 */ "load options from a config file\0"
/*  2711 */ "LOAD_OPTS\0"
/*  2721 */ "no-load-opts\0"
/*  2734 */ "AUTOGEN\0"
/*  2742 */ "autogen (GNU AutoGen) - The Automated Program Generator - Ver. 5.18.7\n"
            "Usage:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... [ <def-file> ]\n\0"
/*  2885 */ "$HOME\0"
/*  2891 */ ".\0"
/*  2893 */ ".autogenrc\0"
/*  2904 */ "autogen-users@lists.sourceforge.net\0"
/*  2940 */ "AutoGen creates text files from templates using external definitions.\n\0"
/*  3011 */ "AutoGen is a tool designed for generating program files that contain\n"
            "repetitive text with varied substitutions.\n\0"
/*  3124 */ "autogen (GNU AutoGen) 5.18.7\0"
/*  3153 */ "nothing\0"
/*  3161 */ "debug-message\0"
/*  3175 */ "server-shell\0"
/*  3188 */ "templates\0"
/*  3198 */ "block-macros\0"
/*  3211 */ "expressions\0"
/*  3223 */ "everything"autogen_packager_info(NULL)translate_option_stringsOPTPROC_BASEOPTPROC_NONEzFullVersion(autogen_opt_strs+3124)zDetail(autogen_opt_strs+3011)zExplain(autogen_opt_strs+2940)zBugsAddr(autogen_opt_strs+2904)zRcName(autogen_opt_strs+2893)zUsageTitle(autogen_opt_strs+2742)zPROGNAME(autogen_opt_strs+2734)VER_PROCLOAD_OPTS_name(NO_LOAD_OPTS_name + 3)LOAD_OPTS_pfx(autogen_opt_strs+1188)NO_LOAD_OPTS_name(autogen_opt_strs+2721)LOAD_OPTS_NAME(autogen_opt_strs+2711)LOAD_OPTS_DESC(autogen_opt_strs+2679)SAVE_OPTS_name(autogen_opt_strs+2669)SAVE_OPTS_DESC(autogen_opt_strs+2630)USAGE_name(autogen_opt_strs+2624)USAGE_DESC(autogen_opt_strs+2596)(OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)|OPTST_NO_INIT)RESET_name(autogen_opt_strs+2583)RESET_DESC(autogen_opt_strs+2559)VER_name(autogen_opt_strs+2551)VER_DESC(autogen_opt_strs+2515)(OPTST_SET_ARGTYPE(OPARG_TYPE_STRING) | OPTST_ARG_OPTIONAL | OPTST_IMM | OPTST_NO_INIT)(OPTST_IMM | OPTST_NO_INIT)MORE_HELP_name(autogen_opt_strs+2505)MORE_HELP_DESC(autogen_opt_strs+2460)HELP_name(autogen_opt_strs+2455)HELP_DESC(autogen_opt_strs+2411)(OPTST_DOCUMENT | OPTST_NO_INIT)AUTOOPTS_OPTS_DESC(autogen_opt_strs+2376)(OPTST_DISABLED | OPTST_NO_INIT | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING) | OPTST_ARG_OPTIONAL)MAKE_DEP_name(autogen_opt_strs+2367)MAKE_DEP_NAME(autogen_opt_strs+2358)MAKE_DEP_DESC(autogen_opt_strs+2332)DEP_TRACK_DESC(autogen_opt_strs+2279)(OPTST_DISABLED | OPTST_NO_INIT | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))UNDEFINE_name(autogen_opt_strs+2270)UNDEFINE_NAME(autogen_opt_strs+2261)UNDEFINE_DESC(autogen_opt_strs+2229)(OPTST_DISABLED | OPTST_STACKED | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))DEFINE_name(autogen_opt_strs+2222)DEFINE_NAME(autogen_opt_strs+2215)DEFINE_DESC(autogen_opt_strs+2184)SELECT_SUFFIX_name(autogen_opt_strs+2170)SELECT_SUFFIX_NAME(autogen_opt_strs+2156)SELECT_SUFFIX_DESC(autogen_opt_strs+2129)(OPTST_DISABLED | OPTST_STACKED | OPTST_NO_INIT | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))SKIP_SUFFIX_name(autogen_opt_strs+2117)SKIP_SUFFIX_NAME(autogen_opt_strs+2105)SKIP_SUFFIX_DESC(autogen_opt_strs+2074)PROCESSING_DESC(autogen_opt_strs+1972)(OPTST_DISABLED)CORE_name(autogen_opt_strs+1967)CORE_NAME(autogen_opt_strs+1962)CORE_DESC(autogen_opt_strs+1926)(OPTST_DISABLED | OPTST_NO_INIT)USED_DEFINES_name(autogen_opt_strs+1913)USED_DEFINES_NAME(autogen_opt_strs+1900)USED_DEFINES_DESC(autogen_opt_strs+1874)SHOW_DEFS_name(autogen_opt_strs+1864)SHOW_DEFS_NAME(OPTST_OMITTED | OPTST_NO_INIT)(OPTST_DISABLED | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))TRACE_OUT_name(autogen_opt_strs+1819)TRACE_OUT_NAME(autogen_opt_strs+1809)TRACE_OUT_DESC(autogen_opt_strs+1779)(OPTST_DISABLED | OPTST_SET_ARGTYPE(OPARG_TYPE_ENUMERATION))((char const*)TRACE_NOTHING)TRACE_name(autogen_opt_strs+1773)TRACE_NAME(autogen_opt_strs+1767)TRACE_DESC(autogen_opt_strs+1743)(OPTST_DISABLED | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))TIMEOUT_name(autogen_opt_strs+1735)TIMEOUT_NAME(autogen_opt_strs+1727)TIMEOUT_DESC(autogen_opt_strs+1686)(OPTST_DISABLED | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC) | OPTST_SCALED_NUM)((char const*)256)LOOP_LIMIT_name(autogen_opt_strs+1675)LOOP_LIMIT_NAME(autogen_opt_strs+1664)LOOP_LIMIT_DESC(autogen_opt_strs+1639)DEBUG_TPL_DESC(autogen_opt_strs+1569)WRITABLE_name(NOT_WRITABLE_name + 4)NOT_WRITABLE_PFX(autogen_opt_strs+1565)NOT_WRITABLE_name(autogen_opt_strs+1552)WRITABLE_NAME(autogen_opt_strs+1543)WRITABLE_DESC(autogen_opt_strs+1509)SOURCE_TIME_name(NOT_SOURCE_TIME_name + 3)NOT_SOURCE_TIME_PFXNOT_SOURCE_TIME_name(autogen_opt_strs+1494)SOURCE_TIME_NAME(autogen_opt_strs+1482)SOURCE_TIME_DESC(autogen_opt_strs+1451)BASE_NAME_name(autogen_opt_strs+1441)BASE_NAME_NAME(autogen_opt_strs+1431)BASE_NAME_DESC(autogen_opt_strs+1390)OUT_HANDLING_DESC(autogen_opt_strs+1338)EQUATE_DFT_ARG(autogen_opt_strs+1334)EQUATE_name(autogen_opt_strs+1327)EQUATE_NAME(autogen_opt_strs+1320)EQUATE_DESC(autogen_opt_strs+1287)NO_FMEMOPEN_name(autogen_opt_strs+1275)NO_FMEMOPEN_NAME(autogen_opt_strs+1263)NO_FMEMOPEN_DESC(autogen_opt_strs+1237)SHELL_name(autogen_opt_strs+1231)SHELL_NAME(autogen_opt_strs+1225)SHELL_DESC(autogen_opt_strs+1191)(OPTST_INITENABLED | OPTST_NO_INIT | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))DEFINITIONS_name(NOT_DEFINITIONS_name + 3)NOT_DEFINITIONS_PFXNOT_DEFINITIONS_name(autogen_opt_strs+1173)DEFINITIONS_NAME(autogen_opt_strs+1161)DEFINITIONS_DESC(autogen_opt_strs+1134)(OPTST_DISABLED | OPTST_DEPRECATED | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))LIB_TEMPLATE_name(autogen_opt_strs+1121)LIB_TEMPLATE_NAME(autogen_opt_strs+1108)LIB_TEMPLATE_DESC(autogen_opt_strs+1061)OVERRIDE_TPL_name(autogen_opt_strs+1048)OVERRIDE_TPL_NAME(autogen_opt_strs+1035)OVERRIDE_TPL_DESC(autogen_opt_strs+1005)TEMPL_DIRS_name(autogen_opt_strs+994)TEMPL_DIRS_NAME(autogen_opt_strs+983)TEMPL_DIRS_DESC(autogen_opt_strs+955)INPUT_SELECT_DESC(autogen_opt_strs+874)zLicenseDescrip(autogen_opt_strs+271)zCopyright(autogen_opt_strs+0)OPTION_CODE_COMPILE__doxygen__HAVE_DLOPENHAVE_DLFCN_HHAVE_CTYPE_HNO_OPTIONAL_OPT_ARGSoptArgBucket_tWITH_PACKAGERWITH_PACKAGER_VERSIONWITH_PACKAGER_BUG_REPORTSoptionVendorOptionoptionUnstackArgoptionTimeValoptionTimeDateoptionStackArgoptionResetOptoptionNumericValoptionNestedValoptionBooleanVal/* opts.c ends here *//* user option count *//* full option count *//* index of default opt *//* '-#' option index *//* save option index *//* more-help option index *//*
     *  Indexes to special options
     *//* translation procedure *//* usage procedure *//* extensions/saved state  *//* address to send bugs to *//* current option index, current option *//* original argc + argv    *//**
 * The option definitions for autogen.  The one structure that
 * binds them all.
 *//* __doxygen__ *//** Packager information for autogen. *//**
 * Information about the person or institution that packaged autogen
 * for the current distribution.
 *//**
 * The directory containing the data associated with autogen.
 *//**
 * Print a file system error fatal error message and die.
 *
 * @param[in] exit_code  the value to call exit(3) with.
 * @param[in] op         the operation that failed.
 * @param[in] fname      the file name the operation was on.
 * @noreturn
 *//**
 * Print a fatal error message and die, var-arg style.
 *
 * @param[in] exit_code  the value to call exit(3) with
 * @param[in] fmt        the death rattle message
 * @param[in] ...        the list of arguments for the message
 * @noreturn
 *//**
 * Print a fatal error message and die, \a va_list style.
 *
 * @param[in] exit_code  the value to call exit(3) with
 * @param[in] fmt        the death rattle message
 * @param[in] ap         the argument list for the message
 * @noreturn
 *//**
 * Print a usage message with a format and a variable argument list.
 * vusage_message() is called to do the work.
 *
 * @param[in] fmt the message format string
 * @param[in] ... the argument list for the message
 * @noreturn
 *//**
 * Print a usage message with a format and va_list argument.
 * The optionUsage function is then invoked to print
 * the error usage text (somewhat abbreviated) and then exit.
 *
 * @param[in] fmt the message format string
 * @param[in] ap  the var-arg list.
 * @noreturn
 *//* extracted from optmain.tlib near line 1250 *//* extracted from opts.def, line 624 *//*
     * Be sure the flag-code[0] handles special values for the options pointer
     * viz. (poptions <= OPTPROC_EMIT_LIMIT) *and also* the special flag bit
     * ((poptdesc->fOptState & OPTST_RESET) != 0) telling the option to
     * reset its state.
     *//**
 * Code to handle the select-suffix option.
 * If you wish to override the suffix specifications in the template,
 * you can use one or more copies of this option.  See the suffix
 * specification in the @ref{pseudo macro} section of the info doc.
 * @param[in] pOptions the autogen options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 *//* protect AutoOpts client code from internal callbacks *//* extracted from optmain.tlib near line 945 *//**
 * Code to handle the trace option.
 * This option will cause AutoGen to display a trace of its template
 * processing.  There are six levels, each level including messages from
 * the previous levels:
 *
 * @table @samp
 * @item nothing
 * Does no tracing at all (default)
 *
 * @item debug-message
 * Print messages from the "DEBUG" AutoGen macro (@pxref{DEBUG}).
 *
 * @item server-shell
 * Traces all input and output to the server shell.  This includes a shell
 * "independent" initialization script about 30 lines long.  Its output is
 * discarded and not inserted into any template.
 *
 * @item templates
 * Traces the invocation of @code{DEFINE}d macros and @code{INCLUDE}s
 *
 * @item block-macros
 * Traces all block macros.  The above, plus @code{IF}, @code{FOR},
 * @code{CASE} and @code{WHILE}.
 *
 * @item expressions
 * Displays the results of expression evaluations.
 *
 * @item everything
 * Displays the invocation of every AutoGen macro, even @code{TEXT} macros
 * (i.e. the text outside of macro quotes).  Additionally, if you rebuild
 * the ``expr.ini'' file with debugging enabled, then all calls to
 * AutoGen defined scheme functions will also get logged:
 * @*
 * @example
 * cd $@{top_builddir@}/agen5
 * DEBUG_ENABLED=true bash bootstrap.dir expr.ini
 * make CFLAGS='-g -DDEBUG_ENABLED=1'
 * @end example
 *
 * Be aware that you cannot rebuild this source in this way without first
 * having installed the @code{autogen} executable in your search path.
 * Because of this, "expr.ini" is in the distributed source list, and
 * not in the dependencies.
 * @end table
 * @param[in] pOptions the autogen options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 *//* defined SHELL_ENABLED *//* ranges need not be ordered. *//**
 * Code to handle the timeout option, when SHELL_ENABLED is #define-d.
 * AutoGen works with a shell server process.  Most normal commands will
 * complete in less than 10 seconds.  If, however, your commands need more
 * time than this, use this option.
 *
 * The valid range is 0 to 3600 seconds (1 hour).
 * Zero will disable the server time limit.
 * @param[in] pOptions the autogen options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 *//**
 * Code to handle the loop-limit option.
 * This option prevents runaway loops.  For example, if you accidentally
 * specify, "FOR x (for-from 1) (for-to -1) (for-by 1)", it will take a
 * long time to finish.  If you do have more than 256 entries in tables,
 * you will need to specify a new limit with this option.
 * @param[in] pOptions the autogen options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 *//* extracted from opts.def, line 261 *//**
 * Code to handle the shell option, when SHELL_ENABLED is #define-d.
 * By default, when AutoGen is built, the configuration is probed for a
 * reasonable Bourne-like shell to use for shell script processing.  If
 * a particular template needs an alternate shell, it must be specified
 * with this option on the command line, with an environment variable
 * (@code{SHELL}) or in the configuration/initialization file.
 * @param[in] pOptions the autogen options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 *//* extracted from opts.def, line 211 *//**
 * Code to handle the lib-template option.
 * DEFINE macros are saved from this template file for use in processing
 * the main macro file.  Template text aside from the DEFINE macros is
 * is ignored.
 *
 * Do not use this.  Instead, use the INCLUDE macro in your template.
 * @param[in] pOptions the autogen options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 *//* extracted from opts.def, line 187 *//**
 * Code to handle the override-tpl option.
 * Definition files specify the standard template that is to be expanded.
 * This option will override that name and expand a different template.
 * @param[in] pOptions the autogen options data structure
 * @param[in,out] pOptDesc the option descriptor for this option.
 *//**
 * The callout function that invokes the optionUsage function.
 *
 * @param[in] opts the AutoOpts option description structure
 * @param[in] od   the descriptor for the "help" (usage) option.
 * @noreturn
 *//*
 *  Create the static procedure(s) declared above.
 *//* not defined __doxygen__ *//** Compiled-in initial values for autogen option cookies. *//* load-opts *//* save-opts *//* usage-opt *//* more-help *//* help *//* version *//* resettable *//* doc opt *//* --make-dep *//* --undefine *//* --define *//* --select-suffix *//* --skip-suffix *//* --core *//* --used-defines *//* --show-defs *//* --trace-out *//* --timeout *//* --writable *//* --source-time *//* --base-name *//* --no-fmemopen *//* --shell *//* --definitions *//* --lib-template *//* --override-tpl *//* --templ-dirs *//** Compiled-in initial values for autogen options. *//* extracted from optcode.tlib near line 364 *//** The full version string for autogen. *//** Extra detail explaining what autogen does. *//** Clarification/explanation of what autogen does. *//** The autogen program bug email address. *//** Directories to search for autogen config files. *//** autogen configuration file name. *//** Reference to the title line for autogen usage. *//** Reference to the upper cased version of autogen. *//* disablement strs *//* desc, NAME, name *//* option proc      *//* must/cannot opts *//* arg list/cookie  *//* last opt argumnt *//* opt state flags  *//* min, max, act ct *//* equivalenced to  *//* equiv idx value  *//* entry idx, value *//* equiv idx, value *//**
 *  Define the autogen Option Descriptions.
 * This is an array of OPTION_CT entries, one for each
 * option that the autogen program responds to.
 *//* def/not SHELL_ENABLED *//* not SHELL_ENABLED *//**
 *  Declare option callback procedures
 *//*
 *  Help/More_Help/Version option descriptions:
 *//** autoopts-opts option separation text *//**
 *  autoopts-opts option description:
 *//** Compiled in flag settings for the make-dep option *//** Name string for the make-dep option *//** Upper-cased name for the make-dep option *//** Descriptive text for the make-dep option *//**
 *  make-dep option description:
 *//** dep-track option separation text *//**
 *  dep-track option description:
 *//** Compiled in flag settings for the undefine option *//** Name string for the undefine option *//** Upper-cased name for the undefine option *//** Descriptive text for the undefine option *//**
 *  undefine option description:
 *//** Compiled in flag settings for the define option *//** Name string for the define option *//** Upper-cased name for the define option *//** Descriptive text for the define option *//**
 *  define option description:
 *//** Compiled in flag settings for the select-suffix option *//** Name string for the select-suffix option *//** Upper-cased name for the select-suffix option *//** Descriptive text for the select-suffix option *//**
 *  select-suffix option description:
 *//** Compiled in flag settings for the skip-suffix option *//** Other options that appear in conjunction with the skip-suffix option *//** Name string for the skip-suffix option *//** Upper-cased name for the skip-suffix option *//** Descriptive text for the skip-suffix option *//**
 *  skip-suffix option description with
 *  "Must also have options" and "Incompatible options":
 *//** processing option separation text *//**
 *  processing option description:
 *//* HAVE_SYS_RESOURCE_H *//* disable core *//** Compiled in flag settings for the core option *//** Name string for the core option *//** Upper-cased name for the core option *//** Descriptive text for the core option *//**
 *  core option description:
 *//** Compiled in flag settings for the used-defines option *//** Name string for the used-defines option *//** Upper-cased name for the used-defines option *//** Descriptive text for the used-defines option *//**
 *  used-defines option description:
 *//* DEBUG_ENABLED *//** Descriptive text for the show-defs option *//* disable show-defs *//** Compiled in flag settings for the show-defs option *//** Name string for the show-defs option *//** Upper-cased name for the show-defs option *//**
 *  show-defs option description:
 *//** Compiled in flag settings for the trace-out option *//** Name string for the trace-out option *//** Upper-cased name for the trace-out option *//** Descriptive text for the trace-out option *//**
 *  trace-out option description:
 *//** Compiled in flag settings for the trace option *//** The compiled in default value for the trace option argument *//** Name string for the trace option *//** Upper-cased name for the trace option *//** Descriptive text for the trace option *//**
 *  trace option description:
 *//* disable timeout *//** Compiled in flag settings for the timeout option *//** Name string for the timeout option *//** Upper-cased name for the timeout option *//** Descriptive text for the timeout option *//**
 *  timeout option description:
 *//** Compiled in flag settings for the loop-limit option *//** The compiled in default value for the loop-limit option argument *//** Name string for the loop-limit option *//** Upper-cased name for the loop-limit option *//** Descriptive text for the loop-limit option *//**
 *  loop-limit option description:
 *//** debug-tpl option separation text *//**
 *  debug-tpl option description:
 *//** Compiled in flag settings for the writable option *//** Name string for the writable option *//** disablement prefix for the writable option *//** disablement name for the writable option *//** Upper-cased name for the writable option *//** Descriptive text for the writable option *//**
 *  writable option description:
 *//** Compiled in flag settings for the source-time option *//** Name string for the source-time option *//** disablement prefix for the source-time option *//** disablement name for the source-time option *//** Upper-cased name for the source-time option *//** Descriptive text for the source-time option *//**
 *  source-time option description:
 *//** Compiled in flag settings for the base-name option *//** Name string for the base-name option *//** Upper-cased name for the base-name option *//** Descriptive text for the base-name option *//**
 *  base-name option description:
 *//** out-handling option separation text *//**
 *  out-handling option description:
 *//** Compiled in flag settings for the equate option *//** The compiled in default value for the equate option argument *//** Name string for the equate option *//** Upper-cased name for the equate option *//** Descriptive text for the equate option *//**
 *  equate option description:
 *//** Compiled in flag settings for the no-fmemopen option *//** Name string for the no-fmemopen option *//** Upper-cased name for the no-fmemopen option *//** Descriptive text for the no-fmemopen option *//**
 *  no-fmemopen option description:
 *//* disable shell *//** Compiled in flag settings for the shell option *//** Name string for the shell option *//** Upper-cased name for the shell option *//** Descriptive text for the shell option *//**
 *  shell option description:
 *//** Compiled in flag settings for the definitions option *//** Name string for the definitions option *//** disablement prefix for the definitions option *//** disablement name for the definitions option *//** Upper-cased name for the definitions option *//** Descriptive text for the definitions option *//**
 *  definitions option description:
 *//** Compiled in flag settings for the lib-template option *//** Name string for the lib-template option *//** Upper-cased name for the lib-template option *//** Descriptive text for the lib-template option *//**
 *  lib-template option description:
 *//** Compiled in flag settings for the override-tpl option *//** Name string for the override-tpl option *//** Upper-cased name for the override-tpl option *//** Descriptive text for the override-tpl option *//**
 *  override-tpl option description:
 *//** Compiled in flag settings for the templ-dirs option *//** Name string for the templ-dirs option *//** Upper-cased name for the templ-dirs option *//** Descriptive text for the templ-dirs option *//* TRANSLATORS: the option argument is a file name *//**
 *  templ-dirs option description:
 *//** input-select option separation text *//**
 *  input-select option description:
 *//*  3223 *//*  3211 *//*  3198 *//*  3188 *//*  3175 *//*  3161 *//*  3153 *//*  3124 *//*  3011 *//*  2940 *//*  2893 *//*  2891 *//*  2742 *//*  2734 *//*  2721 *//*  2711 *//*  2679 *//*  2669 *//*  2630 *//*  2624 *//*  2596 *//*  2583 *//*  2559 *//*  2551 *//*  2515 *//*  2505 *//*  2460 *//*  2455 *//*  2411 *//*  2376 *//*  2367 *//*  2358 *//*  2332 *//*  2270 *//*  2261 *//*  2229 *//*  2222 *//*  2215 *//*  2184 *//*  2170 *//*  2156 *//*  2129 *//*  2117 *//*  2105 *//*  2074 *//*  1972 *//*  1967 *//*  1926 *//*  1913 *//*  1900 *//*  1874 *//*  1864 *//*  1854 *//*  1829 *//*  1819 *//*  1809 *//*  1779 *//*  1773 *//*  1767 *//*  1743 *//*  1735 *//*  1727 *//*  1686 *//*  1675 *//*  1664 *//*  1639 *//*  1569 *//*  1565 *//*  1552 *//*  1543 *//*  1509 *//*  1494 *//*  1482 *//*  1451 *//*  1441 *//*  1431 *//*  1390 *//*  1338 *//*  1327 *//*  1320 *//*  1287 *//*  1275 *//*  1263 *//*  1237 *//*  1231 *//*  1225 *//*  1191 *//*  1188 *//*  1173 *//*  1161 *//*  1134 *//*  1121 *//*  1108 *//*  1061 *//*  1048 *//*  1035 *//*  1005 *//*   994 *//*   983 *//*   955 *//*   874 *//*   271 *//**
 *  static const strings for autogen options
 *//*
 *  global included definitions
 *//** \file opts.c
 *  \addtogroup autogen
 *  @{
 *//*   -*- buffer-read-only: t -*- vi: set ro:
 *
 *  DO NOT EDIT THIS FILE   (opts.c)
 *
 *  It has been AutoGen-ed
 *  From the definitions    opts.def
 *  and the template file   options
 *
 * Generated from AutoOpts 41:1:16 templates.
 *
 *  AutoOpts is a copyrighted work.  This source file is not encumbered
 *  by AutoOpts licensing, but is provided under the licensing terms chosen
 *  by the autogen author or copyright holder.  AutoOpts is
 *  licensed under the terms of the LGPL.  The redistributable library
 *  (``libopts'') is licensed under the terms of either the LGPL or, at the
 *  users discretion, the BSD license.  See the AutoOpts and/or libopts sources
 *  for details.
 *
 * The autogen program is copyrighted and licensed
 * under the following terms:
 *
 *  Copyright (C) 1992-2015 Bruce Korb, all rights reserved.
 *  This is free software. It is licensed for use, modification and
 *  redistribution under the terms of the GNU General Public License,
 *  version 3 or later <http://gnu.org/licenses/gpl.html>
 *
 *  autogen is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  autogen is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program.  If not, see <http://www.gnu.org/licenses/>.
 *//home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/scribble.c"could not allocate %u bytes of scribble space"could not allocate %u bytes of scribble spacechar[46]scrib_buf_t *scrib_buf_s *sbsize+1(ssize_t)sizeof(void *)-8const ssize_tunsigned char[1]new_scribble_blockmin_size + hdr_sz0x2000U81914294959104scrib_buf_t **scrib_buf_s **&(res->sb_size)const ssize_t *hdr_szscrib_buf_tscrib_buf_ssb_bufsb_offsb_sizesb_next(scrib_buf_t *)NULL((scrib_buf_t *)NULL)((scrib_buf_t *)NULL)->sb_buf&(((scrib_buf_t *)NULL)->sb_buf[0])(&(((scrib_buf_t *)NULL)->sb_buf[0]))(unsigned char *)NULL((unsigned char *)NULL)(&(((scrib_buf_t *)NULL)->sb_buf[0])) - ((unsigned char *)NULL)next_bufbufsROUND_SCRIBBLE(_v,_sz)(((_v) + ((_sz) - 1)) & ~((_sz) - 1))/**
 * get some scribble space, but exit on failure.
 *
 * @param size thesize required.
 * @returns the allocated chunk.
 */// allow for NUL byte & round to word boundary/**
 * Get some scribble space.  Allocates a new scribble buffer, if needed.
 * The allocation gets incremented by one and then rounded to a multiple
 * of sizeof(void *).
 *
 * @param size thesize required.
 * @returns the allocated chunk.
 *//*
     *  The "sb_size" field is read-only.  Override this during allocation.
     *//*
     * Allocate and link into list.  Advance pointer to next entry.
     *//**
 * allocate a new scribble block.  Multiple of 8K bytes, but has at least
 * \a min_size bytes of data space.
 *
 * @param min_size  minimum size required for current allocation
 * @returns a pointer to the new buffer
 *//**
 * Free the space in the scribble buffers.
 * The scribble buffer allocations are *not* freed.
 *//**
 * De-initialize scribble space.  Frees all the allocated space.
 *//**
 * Initialize scribble space.  This ensures that the library module globals
 * are ready to start.
 */min_size/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/tpLoad.c(tpl->td_scan)const unload_proc_p_t *tpl->td_filemap_info4834find_file(fname, tpl_file, sfx_list, referrer)aprf(CANNOT_FMT, errno, (ag_text_strtable+4774), fname, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+4774), fname, strerror((*__errno_location ())))4774aprf(CANNOT_FMT, errno, (ag_text_strtable+4817), fname, strerror(errno))aprf((ag_text_strtable+798), (*__errno_location ()), (ag_text_strtable+4817), fname, strerror((*__errno_location ())))4817map_info.txt_dataaprf(LOAD_TPL_CANNOT_OPEN, tpl_file)aprf((ag_text_strtable+4788), tpl_file)4788sv_macdigest_tplmac_ctalloc_sz-16~0x0F(size_t)(~0x0F)"main template"VOIDP(res)((void *)(uintptr_t)(res))res->td_size"resize template"load_macs"templ file"7687e_mac4986minfocnt_macrosno_suffixfree_menm_len"find file name"(int)AG_PATH_MAX"referring_tpl"dirlistc_dir3027fmt_len3029sfxlfind_file_doneexpand_dir*dir_ppaprf(LOAD_FILE_SHORT_NAME, res)aprf((ag_text_strtable+4950), res)4950name_buf"find dir name"read_okay(pT->td_scan)/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/tpLoad.c *//**
 *  This gets called when all is well at the end.
 *  The supplied template and all named templates are unloaded.
 *
 *  @param[in] tpl  the last template standing
 *//*
         * "select" functions get remapped, depending on the alias used for
         * the selection.  See the "mac_func_t" enumeration in functions.h.
         *//**
 * Deallocate anything related to a template.
 * This includes the pointer passed in and any macros that have an
 * unload procedure associated with it.
 *
 *  @param[in] tpl  the template to unload
 *//*
     *  Process the leading pseudo-macro.  The template proper
     *  starts immediately after it.
     *//*
     *  Make sure the specified file is a regular file.
     *  Make sure the output time stamp is at least as recent.
     *//*
     *  Find the template file somewhere
     *//**
 *  Starting with the current directory, search the directory
 *  list trying to find the base template file name.
 *//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *//* must fit *//*
     *  Initialize the values:
     *//*
     *  Count the number of macros in the template.  Compute
     *  the output data size as a function of the number of macros
     *  and the size of the template data.  These may get reduced
     *  by comments.
     *//**
 * Load a template from mapped memory.  Load up the pseudo macro,
 * count the macros, allocate the data, and parse all the macros.
 *
 * @param[in] minfo  information about the mapped memory.
 * @param[in] fname  the full path input file name.
 *
 * @returns the digested data
 *//*
     *  We cannot reallocate a smaller array because
     *  the entries are all linked together and
     *  realloc-ing it may cause it to move.
     *//*
         *  IF there are empty macro slots,
         *  THEN pack the text
         *//*
         *  Make sure all of the input string was scanned.
         *//**
 *  Load the macro array and file name.
 *  @param[in,out]  tpl     the template to load
 *  @param[in]      fname   the source file name of the template
 *  @param[in]      pzN     someting
 *  @param[in]      data    the template text
 *//**
 *  Count the macros in a template.
 *  We need to allocate the right number of pointers.
 *//*
             *  IF we've exhausted the search list,
             *  THEN see if we're done, else go through search dir list.
             *
             *  We try one more thing if there is a referrer.
             *  If the searched-for file is a full path, "ct" will
             *  start at -1 and we will leave the loop here and now.
             *//*
             *  IF the file does not already have a suffix,
             *  THEN try the ones that are okay for this file.
             */// fail-return/*
                 *  IF one of our template paths starts with '$', then expand it
                 *  and replace it now and forever (the rest of this run, anyway).
                 *//*
             *  c_dir is always FIND_FILE_CURDIR the first time through
             *  and is never that value after that.
             *//*
         *  IF the file name starts with a directory separator,
         *  then we only search once, looking for the exact file name.
         *//*
         *  Search each directory in our directory search list for the file.
         *  We always force two copies of this option, so we know it exists.
         *  Later entries are more recently added and are searched first.
         *  We start the "dirlist" pointing to the real last entry.
         *//*
     *  The referrer is useful only if it includes a directory name.
     *  If not NULL, referring_tpl becomes an allocated directory name.
     *//*
     *  Not a complete file name.  If there is not already
     *  a suffix for the file name, then append ".tpl".
     *  Check for immediate access once again.
     *//*
         *  in_name now points to the name the file system can use.
         *  It must _not_ point to res_name because we will likely
         *  rewrite that value using this pointer!
         *//*
     *  Expand leading environment variables.
     *  We will not mess with embedded ones.
     *//**
 *  Search for a file.
 *
 *  Starting with the current directory, search the directory list trying to
 *  find the base template file name.  If there is a referring template (a
 *  template with an "INCLUDE" macro), then try that, too, before giving up.
 *
 *  @param[in]  in_name    the file name we are looking for.
 *  @param[out] res_name   where we stash the file name we found.
 *  @param[in]  sfx_list   a list of suffixes to try, if \a in_name has none.
 *  @param[in]  referring_tpl  file name of the template with a INCLUDE macro.
 *
 *  @returns  \a SUCCESS when \a res_name is valid
 *  @returns  \a FAILURE when the file is not found.
 *//* save computed name for later *//*
         * The name expanded to "empty", so substitute curdir.
         *//**
 * Expand a directory name that starts with '$'.
 *
 * @param[in,out] dir_pp pointer to pointer to directory name
 * @returns the resulting pointer
 *//**
 * the name is a regular file with read access.
 * @param[in] fname  file name to check
 * @returns \a true when the named file exists and is a regular file
 * @returns \a false otherwise.
 *//**
 * Return the template structure matching the name passed in.
 *//**
 * @file tpLoad.c
 *
 *  This module will load a template and return a template structure.
 *
 * @addtogroup autogen
 * @{
 */dir_pp/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/tpParse.ctpl_nest_lvlmacro_t **macro_desc **nxt_macfind_macropzMarkpzMacEndfind_mac_startpzCopyfind_mac_endpzFuncpzNextMarkpzEndMark313331503114func_codeconst fn_name_type_t *fn_name_type *pNTpzFuncName*pzFuncNamepzFuncName[pNT->cmpLen]DEBUG_DEC(l)/**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/tpParse.c *//*
     *  We reached the end of the input string.
     *  Return a NULL scanning pointer and a pointer to the end.
     *//*
         *  IF the called function returns a NULL next macro pointer,
         *  THEN some block has completed.  The returned scanning pointer
         *       will be non-NULL.
         *//**
 * Parse the template.
 * @param[out]    mac     array of macro descriptors to fill in
 * @param[in,out] p_scan  pointer to string scanning address
 *//*
     *  IF the end macro mark was preceded by a backslash, then we remove
     *  trailing white space from there to the end of the line.
     *//*
         *  Strip white space from the macro
         *//*
     *  Count the lines in the macro text and advance the
     *  text pointer to after the marker.
     *//*
     *  Find the macro code and the end of the macro invocation
     *//*
     *  IF no more macro marks are found, THEN we are done...
     *//* may be NULL, if there are no more macros *//*
     *  There is some text here.  Make a text macro entry.
     *//*
     *  Back up over a preceding backslash.  It is a flag to indicate the
     *  removal of the end of line white space.
     *//*
     *  Find the end.  (We must.)  If the thing is empty, treat as a comment,
     *  but warn about it.
     *//*
     *  Set our pointers to the start of the macro text
     *//*
     *  "Unknown" means we have to check again before we
     *  know whether to assign it to "FTYP_INVOKE" or "FTYP_COND".
     *  That depends on whether or not we find a named template
     *  at template instantiation time.
     *//*
         *  Names are allowed to contain colons, but not end with them.
         *//*
     *  Save the name for later lookup
     *//*
             *  Advance the scanner past the macro name.
             *  The name is encoded in the "fType".
             *//*
             *  Make sure we matched to the end of the token.
             *//*
             *  For strings that start with a punctuation, we
             *  do not need to test for the end of token
             *  We will not strip off the marker and the load function
             *  will figure out what to do with the code.
             *//*
     *  IF the name starts with a punctuation, then it is some sort of
     *  alias.  Find the function in the alias portion of the table.
     *//*
 *  Return the enumerated function type corresponding
 *  to a name pointed to by the input argument.
 *//**
 * @file tpParse.c
 *
 *  This module will load a template and return a template structure.
 *
 * @addtogroup autogen
 * @{
 */ppmppzMark/home/dhr33ti/Desktop/courses/hss/codeQL_assignment/autogen-5.18.7/agen5/tpProcess.copen_outputout_file6779null_open1385SKIP_SUFFIX& DESC(SKIP_SUFFIX)& (autogenOptions.pOptDesc[INDEX_OPT_SKIP_SUFFIX])pst747aprf(OPEN_OUTPUT_BAD_FMT, spec->os_file_fmt, pst, spec->os_sfx)aprf((ag_text_strtable+6849), spec->os_file_fmt, pst, spec->os_sfx)68497051ospec7203sizeof(out_root)~FPF_FREE1940os->os_file_fmtdo_stdout_tpl1916199420292003AG_SCM_STRLEN(res)scm_c_string_length(res)1968trace_macrofc15399(size_t)(pe - pz)const hdlr_proc_p_t */**
 * @}
 *
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of agen5/tpProcess.c *//*
         *  Now formulate the output file name in the buffer
         *  provided as the input argument.
         *//*
         *  We allow users to specify a suffix with '-' and '_', but when
         *  stripping a suffix from the "base name", we do not recognize 'em.
         *//*
     *  Remove any suffixes in the last file name
     *//*
     *  IF we are to skip the current suffix,
     *  we will redirect the output to /dev/null and
     *  perform all the work.  There may be side effects.
     *//**
 *  Figure out what to use as the base name of the output file.
 *  If an argument is not provided, we use the base name of
 *  the definitions file.
 *//*
     *  Do not deallocate the root entry.  It is not allocated!!
     *//*
     *  Do not deallocate statically allocated names
     *//*
             *  The putative start time is one second earlier than the
             *  earliest output file time, regardless of when that is.
             *//*
         *  IF we are told to purge the file OR the file is an AutoGen temp
         *  file, then get rid of the output.
         *//*
     *  Only stdout and /dev/null are marked, "NOUNLINK"
     *//*
             *  On failure (or unknown jump type), we quit the program, too.
             *//* discard output *//*
             *  We got here by a long jump.  Close/purge the open files.
             *//* "problem" means "drop current output". *//*
             *  We got here by a long jump.  Close/purge the open files
             *  and go on to the next output.
             *//* keep output *//*
             *  Set the output file name buffer.
             *  It may get switched inside open_output.
             *//*
         *  HOW was that we got here?
         *//*
         * We cannot be in Scheme processing.  We've either just started
         * or we've made a long jump from our own code.  If we've made a
         * long jump, we've printed a message that is sufficient and we
         * don't need to print any scheme expressions.
         *//*
     *  IF th m  )    