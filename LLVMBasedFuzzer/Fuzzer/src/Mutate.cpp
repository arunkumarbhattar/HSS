/*
* NOTE: You should feel free to manipulate any content in this .cpp file
*/

#include <cstdlib>
#include <iostream>
#include <sys/stat.h>
#include <fstream>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <time.h>

#include <cstring>
#include <cstdio>

#include "Mutate.h"
#include "Utils.h"
#include <cassert>

std::vector<std::string> SeedInputs;
enum MutationType{
    ReplaceBytesWithRandomValues = 0,
    SwapAdjacentBytes,
    CycleThroughAllValuesForEachByte,
    RemoveARandomByte,
    InsertARandomByte
};

MutationType CurrMutationType;
/*
 * map<RunIndex, map<MutationType, CovLinesDiscovered>> MutationTypeToCovGrowthSoFar
 * map<RunIndex, NumOfCovLines> RunCoverity;
 */
/*
 * MutationTypeToCovLinesSoFar <MutationType, long CovLinesByThisTechnique> where CovLinesByThisTechnique is Coverity lines
 * discovered by this technique so far.
 *  MutationTypeToCallCountSoFar <MutationType, long CallCountSoFar> where CallCountSoFar is the number of times this technique
 *  has been used so far
 * Serves as an excellent input to determine which Mutation technique to explore based on growth/count metric
 */
//MAP 1
std::map<MutationType, long> MutationTypeToCovLinesSoFar;
//MAP 2
std::map<MutationType, long> MutationTypeToCallCountSoFar;

/*
 * MutationCoverity < long RunIndex, MutationType> --> Just provides information on which runIndex used which Mutation
 * Technique
 */
// MAP 3
std::map<long , MutationType> MutationCoverity;

/*
 * RunCoverity <long RunIndex long TotalNoOfLinesOfCoverity>
 * --> Just provides information on how many total coverity lines were discovered
 * at that Run
 */
// MAP 4
std::map<long, long> RunCoverity;

/*
 * 1.) REPLACE BYTES WITH RANDOM VALUES
 * This function accepts an
 * a.) Input string
 * b.) Byte Indexes to replace (Indexes of bytes that are going to be replaced)
 * c.) No Of Bytes we are gonna replace
 *
 * So basically this function accepts a string of bytes and replaced bytes at certain indexes with a particular Byte
 */
void StrMutateReplaceBytesWithRandom(char* IpByteArray, long SizeOfIpByteArray)
{
    long RandArraySz = (rand()%(SizeOfIpByteArray-1));

    // Array that holds random byte indexes to replace with random values
    int randArray[RandArraySz];
    for(long i=0;i<RandArraySz;i++)
    {
        // Insert Random Values which are NON terminators
        char RandomIndex = (rand()%(SizeOfIpByteArray-2));
        randArray[i]= RandomIndex;
    }
    long NoOfBytesToReplace = RandArraySz;
    for(long ByteIndex = 0 ; ByteIndex < NoOfBytesToReplace; ByteIndex++)
    {
        long i = randArray[ByteIndex];
        while ((IpByteArray[i] == '\0' || IpByteArray[i] == '\n' || IpByteArray[i] == '\t'))
            IpByteArray[i] = rand() % (255);
    }
    return;
}

/*
 * 2.) SWAP ADJACENT BYTES
 *
 */
void StrMutateSwapAdjacentBytes(char* IpStr, long IpLen)
{
    // Generate a random number which will serve to index (i)
    // To allow us to swap bytes at location i and i+1
    char* IpStrCpy = (char*)malloc(IpLen*sizeof(char));
    strcpy(IpStrCpy, IpStr);
    long RandomIndex = 0;
    if (IpStr[IpLen-1] == '\0' || IpStr[IpLen-1] == '\n' || IpStr[IpLen-1] == '\t')
        RandomIndex = rand() % (IpLen-3);
    else
        RandomIndex = rand() % (IpLen-2);
    char temp = IpStrCpy[RandomIndex];
    IpStrCpy[RandomIndex] = IpStrCpy[RandomIndex+1];
    // Now we swap bytes at RandomIndex and RandomIndex + 1
    IpStrCpy[RandomIndex+1] = temp;
    strcpy(IpStr, IpStrCpy);
    return;
}

/* Use: Calling this once will increment all the bytes of the
 * of the byte array by one.
 * To increment all values of bytearray by more than one, call this
 * Function multiple times.
 * 3.) CYCLE THROUGH ALL VALUES FOR EACH BYTE
 */

void StrMutateCycleAllBytesByOneStep(char* IpStr, long IpLen)
{
    long IpStrLen = IpLen;
    if (IpStr[IpStrLen-1] == '\0' || IpStr[IpStrLen-1] == '\n' || IpStr[IpStrLen-1] == '\t')
        IpStrLen = IpStrLen -1;
    for (long i = 0 ; i < IpStrLen; i++)
    {   char val = 1;
        IpStr[i] = IpStr[i] + val;
    }
}

/*
 * 4.) REMOVE A RANDOM BYTE FROM A RANDOM LOCATION
 *
 */
void StrMutateRemoveARandomByte(char* IpStr)
{
    long IpStrLen = strlen(IpStr);
    long RandomIndex = 0;
    // If the string is NULL terminated --> then you should not disturb the NULL at the end
    if ((IpStr[IpStrLen-1] == '\0' || IpStr[IpStrLen-1] == '\n' || IpStr[IpStrLen-1] == '\t'))
    {
        RandomIndex = rand() % (IpStrLen-3);
    }
    else
        RandomIndex = rand() % (IpStrLen-2);
    memmove(&IpStr[RandomIndex], &IpStr[RandomIndex+1], IpStrLen - RandomIndex - 1);
}

/*
 * 5.) INSERT A RANDOM BYTE AT THE END
 */

char* StrMutateAddARandomByte(char* IpStr)
{
    /*
     * for sake of simplicity, we shall add the randomly generated byte to the last
     */
    /*
     * If input string is NULL terminated
     */
    long IpStrLen = strlen(IpStr);

    if (IpStr[IpStrLen-1] == '\0' || IpStr[IpStrLen-1] == '\n' || IpStr[IpStrLen-1] == '\t')
    {
        char* MutatedStr = (char*)malloc((IpStrLen+1)*sizeof(char));
        strncpy(MutatedStr, IpStr, IpStrLen);
        char* RandomChar = (char*)malloc(sizeof(char));
        //Inserted character must never be NULLterminator
        while((*RandomChar == '\0' || *RandomChar == '\n' || *RandomChar == '\t'))
            *RandomChar = (char)(rand() % (255));
        // Shorten the IpStrLen so that Insertion
        MutatedStr[IpStrLen-1] = *RandomChar;
        // Following which NULL-Terminate it.
        MutatedStr[IpStrLen] = IpStr[IpStrLen-1];
        return MutatedStr;
    }

    char* MutatedStr = (char*)malloc((IpStrLen+1)*sizeof(char));
    strncpy(MutatedStr, IpStr, IpStrLen);
    char* RandomChar = (char*)malloc(sizeof(char));
    //Inserted character must never be NULLterminator
    while((*RandomChar == '\0' || *RandomChar == '\n' || *RandomChar == '\t'))
        *RandomChar = (char)(rand() % (255));
    MutatedStr[IpStrLen] = *RandomChar;

    return MutatedStr;
}
/*
 * ReturnBestMutation
 * --> This function returns the best mutation based on highest CovGrowth factor
 * --> CovGrowth factor is (Coverity Lines added by this mutation/ Number of Times this mutation has been used)
 */

MutationType ReturnBestMutationTechnique(void)
{
    // Step1 : Fetch Most recent RunIndex
    using pair_type = decltype(RunCoverity)::value_type;
    auto MostRecentRunIndex = std::max_element(
            std::begin(RunCoverity), std::end(RunCoverity),
            [] (const pair_type & p1, const pair_type & p2) {
                return p1.first < p2.first;
            });
    // If Most Recent Index run is 0, it means its the first Run, return with SwapBytes
    if (MostRecentRunIndex->first == 0)
        return MutationType::SwapAdjacentBytes;

    // Step 2: Use this RunIndex to fetch NumberOfCoverity lines and the Number of times each mutation technique has been used
    MutationType BestMutationTechnique = (MutationType)(rand() % 5);
    static const MutationType All[] = {ReplaceBytesWithRandomValues, SwapAdjacentBytes,
                                       CycleThroughAllValuesForEachByte, RemoveARandomByte,InsertARandomByte };
    double MaxCovGrowth = 0;
    // Compute find the mutation technique with the maxCovGrowth
    for ( const auto e : All )
    {
        if (MutationTypeToCallCountSoFar[e] == 0)
            continue;
        double CurrentMutationTechniqueCovGrowth = MutationTypeToCovLinesSoFar[e]/MutationTypeToCallCountSoFar[e];
        if (CurrentMutationTechniqueCovGrowth > MaxCovGrowth)
        {
            MaxCovGrowth = CurrentMutationTechniqueCovGrowth;
            BestMutationTechnique = e;
        }
    }
    return BestMutationTechnique;
}
/************************************************/
/* 		Implement your select input algorithm 	*/
/************************************************/

std::string selectInput() {
  std::string Seed; 
  
  /*
  *select the seed and mutation, here the code randomly choose a seed and mutation
  */
  unsigned long LastElementIndex = 0;
  if (SeedInputs.size() != 0)
    LastElementIndex = SeedInputs.size()-1;
  Seed = SeedInputs[LastElementIndex];
  if (SeedInputs.size() > 0)
    SeedInputs.pop_back();
  return Seed;
}

/*********************************************/
/* 		Implement your mutation algorithms	 */
/*********************************************/
 
const char *alpha = "abcdefghijklmnopqrstuvwxyz\n\0";

/*
*mutate gives a naive implementation of mutations, you should implement your method here
*/
std::string mutate(std::string Origin) {
  if (Origin.length() <= 0) return Origin;
  /* The fuzzer will start by mutating the seed values based on the mutation youâ€™ve selected on
   * the command line.....................................................................
   *
   * If user does not specify Mutation strategy, its probably because he is fuzzing a binary without raw source.
   * In such cases,
   * You will decide which mutation strategy or strategies to use to perform the mutation.
   * You are expected to include a mechanism that will choose the best strategy for the
   * input program based on the coverage feedback.
   */

  // Fetch the Best Mutation technique -->
  MutationType MutationTechniqueWeWillCurrentlyUse;
  long Strlen = Origin.size();
    MutationTechniqueWeWillCurrentlyUse = ReturnBestMutationTechnique();
    switch(MutationTechniqueWeWillCurrentlyUse)
    {
        case MutationType::ReplaceBytesWithRandomValues:
        {
            /*
             * We are gonna call ->StrMutateReplaceBytesWithRandom function
             */
            //std::cout<<"Mutatating "<<Origin<<"with Technique 1"<<std::endl;
            CurrMutationType = MutationType::ReplaceBytesWithRandomValues;
            StrMutateReplaceBytesWithRandom(const_cast<char*>(Origin.c_str()), Strlen);
            break;
        }
        case MutationType::CycleThroughAllValuesForEachByte:
        {
            /*
             * We are gonna call --> StrMutateCycleAllBytesByOneStep
             * Each call to this funciton will increment all bytes by 1.
             * Hence we are gonna call this in a loop random number of times
             */
            //std::cout<<"Mutatating "<<Origin<<"with Technique 2"<<std::endl;
            CurrMutationType = MutationType::CycleThroughAllValuesForEachByte;
            int NoOfCycles = rand()%10;
            while(NoOfCycles--)
                StrMutateCycleAllBytesByOneStep(const_cast<char*>(Origin.c_str()), Strlen);
            break;
        }
        case MutationType::SwapAdjacentBytes:
        {
            //std::cout<<"Mutatating "<<Origin<<"with Technique 3"<<std::endl;
            CurrMutationType = MutationType::SwapAdjacentBytes;
            // This would only swap some random two bytes together
            StrMutateSwapAdjacentBytes(const_cast<char*>(Origin.c_str()), Strlen);
            break;
        }
        case MutationType::InsertARandomByte:
        {
            //std::cout<<"Mutatating "<<Origin<<"with Technique 4"<<std::endl;
            CurrMutationType = MutationType::InsertARandomByte;
            StrMutateAddARandomByte(const_cast<char*>(Origin.c_str()));
            break;
        }
        case MutationType::RemoveARandomByte:
        {
            //std::cout<<"Mutatating "<<Origin<<"with Technique 5"<<std::endl;
            CurrMutationType = MutationType::RemoveARandomByte;
            StrMutateRemoveARandomByte(const_cast<char*>(Origin.c_str()));
            break;
        }
        default:
            assert(false && "Oh Snap!, unknown MutationType Returned");
    }
  return Origin;
}

/*********************************************/
/* 		Implement your feedback algorithm	 */
/*********************************************/

void feedBack(std::string &Target, std::string &Mutated) {
  /*
  * Target here is a string of output .cov file name, you can find the information from it to determine if the mutated string is interesting
  * Code below adds a mutated string to seed with 70% probability, you should modify this to implement your algorithm
  */

  /*
   * Right out of the bat, read the .cov file and Find store entire contents into a string
   */
    std::cout<<"Mutated String is: "<<Mutated<<std::endl;
    std::fstream CovFile;
    std::string CovFileTotalContentStr;
    CovFile.open(Target, std::ios::in);
    if (CovFile.is_open()){
        std::string CovFileLineStr;
        while(getline(CovFile, CovFileLineStr)){
            CovFileTotalContentStr = CovFileTotalContentStr + CovFileLineStr;
        }
        CovFile.close();
    }
    // The length of "CovFileTotalContentStr" serves as a good metric to track cov file growth
    long CurrCovFileSize = strlen(CovFileTotalContentStr.c_str());
    // Now fetch the latest RunIndex and increment by one
    using pair_type = decltype(RunCoverity)::value_type;
    auto MaxVal = std::max_element(
            std::begin(RunCoverity), std::end(RunCoverity),
            [] (const pair_type & p1, const pair_type & p2) {
                return p1.first < p2.first;
            });
    // This has the latest RunIndex Value
    auto MostRecentRunIndex = MaxVal->first;
    auto MostRecentCovSize = MaxVal->second;
    auto CurrentRunIndex = MostRecentRunIndex + 1;
    //Step 1: Update the CurrentRunIndex and CovFileSize into the RunCoverity map.
    RunCoverity.insert(std::pair<long,long>(CurrentRunIndex, CurrCovFileSize));

    //Step 2: Compute and update the MutationTypeToCovLinesSoFar and MutationTypeToCovLinesSoFar maps
    double CurrentRunCovGrowth = CurrCovFileSize - MostRecentCovSize;
    // If there is any growth in Coverity, add this seed to the seed vector ( so that it can be further explored)
    SeedInputs.push_back(Mutated);
    auto TotalCovLinesOfMutationType = MutationTypeToCovLinesSoFar[CurrMutationType] + CurrentRunCovGrowth;
    // Insert the total number of Coverity lines discovered by this mutation type
    MutationTypeToCovLinesSoFar.insert(std::pair<MutationType, double>(CurrMutationType, TotalCovLinesOfMutationType));
    // Increment the Number of times this mutation has been used
    MutationTypeToCallCountSoFar[CurrMutationType]++;
    // We will use the above two maps to make a judgement on which Mutation technique to use when the user does not
    // specify.

    // Update the RunIndex with the Current Mutation Type
    MutationCoverity.insert(std::pair<long, MutationType>(CurrentRunIndex, CurrMutationType));

}

/*****************************************************************/
//helper functions 

int readSeedInputs(std::string &SeedInputDir) {
  DIR *Directory;
  struct dirent *Ent;
  if ((Directory = opendir(SeedInputDir.c_str())) != NULL) {
    while ((Ent = readdir(Directory)) != NULL) {
      if (!(Ent->d_type == DT_REG))
        continue;
      std::string Path = SeedInputDir + "/" + std::string(Ent->d_name);
      std::string Line = readOneFile(Path);
      SeedInputs.push_back(Line);
    }
    closedir(Directory);
    return 0;
  } else {
    return 1;
  }
}

int Freq = 1000;
int Count = 0;

bool test(std::string &Target, std::string &Input, std::string &OutDir) {
  // Clean up old coverage file before running 
  std::string CoveragePath = Target + ".cov";
  std::remove(CoveragePath.c_str());

  Count++;
  int ReturnCode = runTarget(Target, Input);
  switch (ReturnCode) {
  case 0:
    if (Count % Freq == 0)
      storePassingInput(Input, OutDir);
    return true;
  case 256:
    fprintf(stderr, "%d crashes found\n", failureCount);
    storeCrashingInput(Input, OutDir);
    return false;
  case 127:
    fprintf(stderr, "%s not found\n", Target.c_str());
    exit(1);
  default:
    fprintf(stderr, "Invalid exit code %d\n", ReturnCode);
    exit(1);
  }
}

void storeSeed(std::string &OutDir, int randomSeed) {
  std::string Path = OutDir + "/randomSeed.txt";
  std::fstream File(Path, std::fstream::out | std::ios_base::trunc);
  File << std::to_string(randomSeed);
  File.close();
}

// ./fuzzer [exe file] [seed input dir] [output dir] [frequency] [random seed] 
int main(int argc, char **argv) { 
  if (argc < 4) { 
    printf("usage %s [exe file] [seed input dir] [output dir]\n", argv[0]);
    return 1;
  }

  struct stat Buffer;
  if (stat(argv[1], &Buffer)) {
    fprintf(stderr, "%s not found\n", argv[1]);
    return 1;
  }

  if (stat(argv[2], &Buffer)) {
    fprintf(stderr, "%s not found\n", argv[2]);
    return 1;
  }

  if (stat(argv[3], &Buffer)) {
    fprintf(stderr, "%s not found\n", argv[3]);
    return 1;
  }

  if (argc == 5) {
    Freq = strtol(argv[4], NULL, 10);
  }

  int randomSeed = (int)time(NULL);
  if (argc > 5) {
    randomSeed = strtol(argv[5], NULL, 10);
  }
  srand(randomSeed);

  std::string Target(argv[1]);
  std::string SeedInputDir(argv[2]);
  std::string OutDir(argv[3]);
  
  storeSeed(OutDir, randomSeed);
  
  initialize(OutDir);

  if (readSeedInputs(SeedInputDir)) {
    fprintf(stderr, "Cannot read seed input directory\n");
    return 1;
  }

  while (true) {
      std::string SC = selectInput();
      auto Mutant = mutate(SC);
      test(Target, Mutant, OutDir);
      feedBack(Target, Mutant);
  }
  return 0;
}
