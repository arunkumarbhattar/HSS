/*
* NOTE: You should feel free to manipulate any content in this .cpp file
*/

#include <cstdlib>
#include <iostream>
#include <sys/stat.h>
#include <fstream>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <time.h>

#include <cstring>
#include <cstdio>

#include "Mutate.h"
#include "Utils.h"
#include <cassert>

std::vector<std::string> SeedInputs;
long MostRecentCovSize = 0;
long MostRecentRunIndex = 0;

enum MutationType{
    ReplaceBytesWithRandom = 0,
    SwapAdjacentBytes,
    CycleThroughAllValues,
    InsertARandomByte,
    RemoveARandomByte
};
static const MutationType All[] = {ReplaceBytesWithRandom, SwapAdjacentBytes,
                                   CycleThroughAllValues, RemoveARandomByte,InsertARandomByte };
MutationType CurrMutationType;
/*
 * map<RunIndex, map<MutationType, CovLinesDiscovered>> MutationTypeToCovGrowthSoFar
 * map<RunIndex, NumOfCovLines> RunCoverity;
 */
/*
 * MutationTypeToCovLinesSoFar <MutationType, long CovLinesByThisTechnique> where CovLinesByThisTechnique is Coverity lines
 * discovered by this technique so far.
 *  MutationTypeToCallCountSoFar <MutationType, long CallCountSoFar> where CallCountSoFar is the number of times this technique
 *  has been used so far
 * Serves as an excellent input to determine which Mutation technique to explore based on growth/count metric
 */
//MAP 1
std::map<MutationType, long> MutationTypeToCovLinesSoFar;
//MAP 2
std::map<MutationType, long> MutationTypeToCallCountSoFar;
// MAP 3
std::map<MutationType, double> MutationTypeToPriority;

/*
 * MutationCoverity < long RunIndex, MutationType> --> Just provides information on which runIndex used which Mutation
 * Technique
 */
// MAP 3
std::map<long , MutationType> MutationCoverity;

/*
 * RunCoverity <long RunIndex long TotalNoOfLinesOfCoverity>
 * --> Just provides information on how many total coverity lines were discovered
 * at that Run
 */
// MAP 4
std::map<long, long> RunCoverity;

/*
 * 1.) REPLACE BYTES WITH RANDOM VALUES
 * This function accepts an
 * a.) Input string
 * b.) Byte Indexes to replace (Indexes of bytes that are going to be replaced)
 * c.) No Of Bytes we are gonna replace
 *
 * So basically this function accepts a string of bytes and replaced bytes at certain indexes with a particular Byte
 */
/*
 * 5.) INSERT A RANDOM BYTE AT THE END
 */

char* StrMutateAddARandomByte(char* IpStr)
{
    /*
     * for sake of simplicity, we shall add the randomly generated byte to the last
     */
    /*
     * If input string is NULL terminated
     */
    long IpStrLen = strlen(IpStr);

    if (IpStr != 0 && IpStr[IpStrLen-1] == '\0' || IpStr[IpStrLen-1] == '\n' || IpStr[IpStrLen-1] == '\t')
    {
        char* MutatedStr = (char*)malloc((IpStrLen+1)*sizeof(char));
        strncpy(MutatedStr, IpStr, IpStrLen);
        char* RandomChar = (char*)malloc(sizeof(char));
        //Inserted character must never be NULLterminator
        *RandomChar = (char)(33 + ( std::rand() % ( 126 - 33 + 1 ) ));
        while((*RandomChar == '\0' || *RandomChar == '\n' || *RandomChar == '\t'))
            *RandomChar = (char)(33 + ( std::rand() % ( 126 - 33 + 1 ) ));
        // Shorten the IpStrLen so that Insertion
        MutatedStr[IpStrLen] = *RandomChar;
        // Following which NULL-Terminate it.
        MutatedStr[IpStrLen+1] = '\0';
        return MutatedStr;
    }

    char* MutatedStr = (char*)malloc((IpStrLen+1)*sizeof(char));
    strncpy(MutatedStr, IpStr, IpStrLen);
    char* RandomChar = (char*)malloc(sizeof(char));
    //Inserted character must never be NULLterminator
    *RandomChar = (char)(33 + ( std::rand() % ( 126 - 33 + 1 ) ));
    while((*RandomChar == '\0' || *RandomChar == '\n' || *RandomChar == '\t'))
        *RandomChar = (char)(33 + ( std::rand() % ( 126 - 33 + 1 ) ));
    MutatedStr[IpStrLen] = *RandomChar;
    MutatedStr[IpStrLen+1] = '\0';
    return MutatedStr;
}

char* StrMutateReplaceBytesWithRandom(char* IpByteArray, long SizeOfIpByteArray)
{
    if (SizeOfIpByteArray == 0)
        return StrMutateAddARandomByte(IpByteArray);
    long RandArraySz = (rand()%(SizeOfIpByteArray-1));

    // Array that holds random byte indexes to replace with random values
    int randArray[RandArraySz];
    for(long i=0;i<RandArraySz;i++)
    {
        // Insert Random Values which are NON terminators
        char RandomIndex = (rand()%(SizeOfIpByteArray-2));
        randArray[i]= RandomIndex;
    }
    long NoOfBytesToReplace = RandArraySz;
    for(long ByteIndex = 0 ; ByteIndex < NoOfBytesToReplace; ByteIndex++)
    {
        long i = randArray[ByteIndex];
        char* RandomChar = (char*)malloc(sizeof(char));
        while((*RandomChar == '\0' || *RandomChar == '\n' || *RandomChar == '\t'))
            *RandomChar =  33 + ( std::rand() % ( 126 - 33 + 1 ) );
        if ((IpByteArray[i] != '\0' || IpByteArray[i] != '\n' || IpByteArray[i] != '\t'))
            IpByteArray[i] = *RandomChar;
    }
    return IpByteArray;
}

/*
 * 2.) SWAP ADJACENT BYTES
 *
 */
char* StrMutateSwapAdjacentBytes(char* IpStr, long IpLen)
{
    // Generate a random number which will serve to index (i)
    // To allow us to swap bytes at location i and i+1
    if (IpLen <= 2)
        return StrMutateAddARandomByte(IpStr);
    long RandomIndex = 0;
    if (IpStr[IpLen-1] == '\0' || IpStr[IpLen-1] == '\n' || IpStr[IpLen-1] == '\t')
        RandomIndex = rand() % (IpLen-3);
    else
        RandomIndex = rand() % (IpLen-2);
    char temp = IpStr[RandomIndex];
    IpStr[RandomIndex] = IpStr[RandomIndex+1];
    // Now we swap bytes at RandomIndex and RandomIndex + 1
    IpStr[RandomIndex+1] = temp;
    return IpStr;
}

/* Use: Calling this once will increment all the bytes of the
 * of the byte array by one.
 * To increment all values of bytearray by more than one, call this
 * Function multiple times.
 * 3.) CYCLE THROUGH ALL VALUES FOR EACH BYTE
 */

char* StrMutateCycleAllBytesByOneStep(char* IpStr, long IpLen)
{
    long IpStrLen = IpLen;
    if (IpStr[IpStrLen-1] == '\0' || IpStr[IpStrLen-1] == '\n' || IpStr[IpStrLen-1] == '\t')
        IpStrLen = IpStrLen -1;
    for (long i = 0 ; i < IpStrLen; i++)
    {   char val = 1;
        if (IpStr[i] + val != '\0')
            IpStr[i] = IpStr[i] + val;
    }
    return IpStr;
}

/*
 * 4.) REMOVE A RANDOM BYTE FROM A RANDOM LOCATION
 *
 */
char* StrMutateRemoveARandomByte(char* IpStr)
{
    long IpStrLen = strlen(IpStr);
    if (IpStrLen<=2)
        return StrMutateAddARandomByte(IpStr);
    long RandomIndex = 0;
    // If the string is NULL terminated --> then you should not disturb the NULL at the end
    if ((IpStr[IpStrLen-1] == '\0' || IpStr[IpStrLen-1] == '\n' || IpStr[IpStrLen-1] == '\t'))
    {
        RandomIndex = rand() % (IpStrLen-3);
    }
    else
        RandomIndex = rand() % (IpStrLen-2);
    memmove(&IpStr[RandomIndex], &IpStr[RandomIndex+1], IpStrLen - RandomIndex - 1);
    // Add Null Terminator
    IpStr[IpStrLen-1] = '\0';
//    IpStr[IpStrLen-1] = 'j';
    return IpStr;
}


/*
 * ReturnBestMutation
 * --> This function returns the best mutation based on highest CovGrowth factor
 * --> CovGrowth factor is (Coverity Lines added by this mutation/ Number of Times this mutation has been used)
 */

std::string MutationTypeEnumToStr(MutationType T)
{
    switch(T)
    {
        case MutationType::ReplaceBytesWithRandom:
            return "ReplaceBytesWithRandom";
        case MutationType::SwapAdjacentBytes:
            return "SwapAdjacentBytes";
        case MutationType::RemoveARandomByte:
            return "RemoveARandomByte";
        case MutationType::InsertARandomByte:
            return "InsertARandomByte";
        case MutationType::CycleThroughAllValues:
            return "CycleThroughAllValues";
    }
    return "";
}
MutationType ReturnBestMutationTechnique(std::string Origin)
{
    std::cout<<"Origin Length is "<<Origin.length()<<std::endl;
    // Step1 : Fetch Most recent RunIndex
    using pair_type = decltype(RunCoverity)::value_type;
    auto MostRecentRunIndex = std::max_element(
            std::begin(RunCoverity), std::end(RunCoverity),
            [] (const pair_type & p1, const pair_type & p2) {
                return p1.first < p2.first;
            });
    // If Most Recent Index run is 0, it means its the first Run, return with SwapBytes
    if (MostRecentRunIndex->first == 0)
    {
        return MutationType::SwapAdjacentBytes;
    }

    // Step 2: Use this RunIndex to fetch NumberOfCoverity lines and the Number of times each mutation technique has been used
    MutationType BestMutationTechnique = (MutationType)(rand() % 5);
    double MaxCovGrowth = 0;
    // Compute find the mutation technique with the maxCovGrowth
    for ( const auto e : All )
    {
        if (MutationTypeToCallCountSoFar[e] == 0)
            MutationTypeToCallCountSoFar[e] = 1;
        double CurrentMutationTechniqueCovGrowth = ((double)MutationTypeToCovLinesSoFar[e]/(double)MutationTypeToCallCountSoFar[e]);
        CurrentMutationTechniqueCovGrowth = CurrentMutationTechniqueCovGrowth*MutationTypeToPriority[e];
        if (CurrentMutationTechniqueCovGrowth > MaxCovGrowth)
        {
            MaxCovGrowth = CurrentMutationTechniqueCovGrowth;
            BestMutationTechnique = e;
        }
    }
    std::cout<<"Returning Technique  "<<MutationTypeEnumToStr(BestMutationTechnique) <<std::endl;
    return BestMutationTechnique;
}
/************************************************/
/* 		Implement your select input algorithm 	*/
/************************************************/

std::string selectInput() {
  std::string Seed; 
  
  /*
  *select the seed and mutation, here the code randomly choose a seed and mutation
  */
  unsigned long LastElementIndex = 0;
  if (SeedInputs.size() != 0)
    LastElementIndex = SeedInputs.size()-1;
  if (Seed.length() == 0)
      Seed = rand();
  Seed = SeedInputs[LastElementIndex];
  if (SeedInputs.size() > 0)
    SeedInputs.pop_back();
  return Seed;
}

/*********************************************/
/* 		Implement your mutation algorithms	 */
/*********************************************/
 
const char *alpha = "abcdefghijklmnopqrstuvwxyz\n\0";

/*
*mutate gives a naive implementation of mutations, you should implement your method here
*/
std::string mutate(std::string Origin) {
  if (Origin.length() <= 0) return Origin;
  /* The fuzzer will start by mutating the seed values based on the mutation you’ve selected on
   * the command line.....................................................................
   *
   * If user does not specify Mutation strategy, its probably because he is fuzzing a binary without raw source.
   * In such cases,
   * You will decide which mutation strategy or strategies to use to perform the mutation.
   * You are expected to include a mechanism that will choose the best strategy for the
   * input program based on the coverage feedback.
   */

  // Fetch the Best Mutation technique -->
  MutationType MutationTechniqueWeWillCurrentlyUse;
  long Strlen = Origin.size();
    MutationTechniqueWeWillCurrentlyUse = ReturnBestMutationTechnique(Origin);
    switch(MutationTechniqueWeWillCurrentlyUse)
    {
        case MutationType::ReplaceBytesWithRandom:
        {
            /*
             * We are gonna call ->StrMutateReplaceBytesWithRandom function
             */
            CurrMutationType = MutationType::ReplaceBytesWithRandom;
            //std::cout<<"Mutatating "<<Origin<<" with Technique ReplaceBytesWithRandom"<<std::endl;
            CurrMutationType = MutationType::ReplaceBytesWithRandom;
            std::strcpy(const_cast<char *>(Origin.c_str()), StrMutateReplaceBytesWithRandom(const_cast<char*>(Origin.c_str()), Strlen));
            break;
        }
        case MutationType::CycleThroughAllValues:
        {
            /*
             * We are gonna call --> StrMutateCycleAllBytesByOneStep
             * Each call to this funciton will increment all bytes by 1.
             * Hence we are gonna call this in a loop random number of times
             */
            //std::cout<<"Mutatating "<<Origin<<" with Technique CycleThroughAllValues"<<std::endl;
            CurrMutationType = MutationType::CycleThroughAllValues;
            Origin = StrMutateCycleAllBytesByOneStep(const_cast<char*>(Origin.c_str()), Strlen);
            break;
        }
        case MutationType::SwapAdjacentBytes:
        {
            //std::cout<<"Mutatating "<<Origin<<" with Technique SwapAdjacentBytes"<<std::endl;
            CurrMutationType = MutationType::SwapAdjacentBytes;
            // This would only swap some random two bytes together
            StrMutateSwapAdjacentBytes(const_cast<char*>(Origin.c_str()), Strlen);
            break;
        }
        case MutationType::InsertARandomByte:
        {
            //std::cout<<"Mutatating "<<Origin<<" with Technique InsertARandomByte"<<std::endl;
            CurrMutationType = MutationType::InsertARandomByte;
            Origin = StrMutateAddARandomByte(const_cast<char*>(Origin.c_str()));
            break;
        }
        case MutationType::RemoveARandomByte:
        {
            //std::cout<<"Mutatating "<<Origin<<" with Technique RemoveARandomByte"<<std::endl;
            CurrMutationType = MutationType::RemoveARandomByte;
            Origin =  StrMutateRemoveARandomByte(const_cast<char*>(Origin.c_str()));
            break;
        }
        default:
            assert(false && "Oh Snap!, unknown MutationType Returned");
    }
  return Origin;
}

/*********************************************/
/* 		Implement your feedback algorithm	 */
/*********************************************/

void feedBack(std::string &Target, std::string &Mutated) {
    std::fstream CovFile;
    std::string CovFileTotalContentStr;
    CovFile.open(Target, std::ios::in);
    if (CovFile.is_open()){
        std::string CovFileLineStr;
        while(getline(CovFile, CovFileLineStr)){
            CovFileTotalContentStr = CovFileTotalContentStr + CovFileLineStr;
        }
        CovFile.close();
    }
    // The length of "CovFileTotalContentStr" serves as a good metric to track cov file growth
    long CurrCovFileSize = strlen(CovFileTotalContentStr.c_str());
    // Now fetch the latest RunIndex and increment by one
    using pair_type = decltype(RunCoverity)::value_type;
//    auto MaxVal = std::max_element(
//            std::begin(RunCoverity), std::end(RunCoverity),
//            [] (const pair_type & p1, const pair_type & p2) {
//                return p1.first < p2.first;
//            });
//    // This has the latest RunIndex Value
//    auto MostRecentRunIndex = MaxVal->first;
//    auto MostRecentCovSize = MaxVal->second;
    auto CurrentRunIndex = MostRecentRunIndex + 1;

    //Step 1: Update the CurrentRunIndex and CovFileSize into the RunCoverity map.
    RunCoverity.insert(std::pair<long,long>(CurrentRunIndex, CurrCovFileSize));

    //Step 2: Compute and update the MutationTypeToCovLinesSoFar and MutationTypeToCovLinesSoFar maps
    double CurrentRunCovGrowth = CurrCovFileSize - MostRecentCovSize;
    // If there is any growth in Coverity, add this seed to the seed vector ( so that it can be further explored)
    SeedInputs.push_back(Mutated);
    // Insert the total number of Coverity lines discovered by this mutation type
    if (CurrentRunCovGrowth)
        std::cout<<"Growth Discovered: "<< CurrentRunCovGrowth <<std::endl;
    if (CurrMutationType == MutationType::InsertARandomByte)
    {
        std::cout<<"Inserting discovered: "<< CurrentRunCovGrowth <<std::endl;
        MutationTypeToCovLinesSoFar[CurrMutationType] = MutationTypeToCovLinesSoFar[CurrMutationType] + (CurrentRunCovGrowth*100);
    }
    // Increment the Number of times this mutation has been used
    MutationTypeToCallCountSoFar[CurrMutationType] = MutationTypeToCallCountSoFar[CurrMutationType] + 1;
    // We will use the above two maps to make a judgement on which Mutation technique to use when the user does not
    // specify.

    // Update the RunIndex with the Current Mutation Type
    MutationCoverity.insert(std::pair<long, MutationType>(CurrentRunIndex, CurrMutationType));
    MostRecentRunIndex = CurrentRunIndex;
    MostRecentCovSize = CurrCovFileSize;
}

/*****************************************************************/
//helper functions 

int readSeedInputs(std::string &SeedInputDir) {
  DIR *Directory;
  struct dirent *Ent;
  if ((Directory = opendir(SeedInputDir.c_str())) != NULL) {
    while ((Ent = readdir(Directory)) != NULL) {
      if (!(Ent->d_type == DT_REG))
        continue;
      std::string Path = SeedInputDir + "/" + std::string(Ent->d_name);
      std::string Line = readOneFile(Path);
      SeedInputs.push_back(Line);
    }
    closedir(Directory);
    return 0;
  } else {
    return 1;
  }
}

int Freq = 1000;
int Count = 0;

bool test(std::string &Target, std::string &Input, std::string &OutDir) {
  // Clean up old coverage file before running 
  std::string CoveragePath = Target + ".cov";
  std::remove(CoveragePath.c_str());

  Count++;
  int ReturnCode = runTarget(Target, Input);
  switch (ReturnCode) {
  case 0:
    if (Count % Freq == 0)
      storePassingInput(Input, OutDir);
    return true;
  case 256:
    fprintf(stderr, "%d crashes found\n", failureCount);
    storeCrashingInput(Input, OutDir);
    return false;
  case 127:
    fprintf(stderr, "%s not found\n", Target.c_str());
    exit(1);
  default:
    fprintf(stderr, "Invalid exit code %d\n", ReturnCode);
    exit(1);
  }
}

void storeSeed(std::string &OutDir, int randomSeed) {
  std::string Path = OutDir + "/randomSeed.txt";
  std::fstream File(Path, std::fstream::out | std::ios_base::trunc);
  File << std::to_string(randomSeed);
  File.close();
}

// ./fuzzer [exe file] [seed input dir] [output dir] [frequency] [random seed] 
int main(int argc, char **argv) { 
  if (argc < 4) { 
    printf("usage %s [exe file] [seed input dir] [output dir]\n", argv[0]);
    return 1;
  }

  struct stat Buffer;
  if (stat(argv[1], &Buffer)) {
    fprintf(stderr, "%s not found\n", argv[1]);
    return 1;
  }

  if (stat(argv[2], &Buffer)) {
    fprintf(stderr, "%s not found\n", argv[2]);
    return 1;
  }

  if (stat(argv[3], &Buffer)) {
    fprintf(stderr, "%s not found\n", argv[3]);
    return 1;
  }

  if (argc == 5) {
    Freq = strtol(argv[4], NULL, 10);
  }

  int randomSeed = (int)time(NULL);
  if (argc > 5) {
    randomSeed = strtol(argv[5], NULL, 10);
  }
  srand(randomSeed);

  std::string Target(argv[1]);
  std::string SeedInputDir(argv[2]);
  std::string OutDir(argv[3]);
  
  storeSeed(OutDir, randomSeed);
  
  initialize(OutDir);

  if (readSeedInputs(SeedInputDir)) {
    fprintf(stderr, "Cannot read seed input directory\n");
    return 1;
  }

  for (auto e: All)
  {
      MutationTypeToCovLinesSoFar[e] = 1;
      switch (e)
      {
          case MutationType::CycleThroughAllValues:
          case MutationType::SwapAdjacentBytes:
              MutationTypeToPriority[e] = 2;
              break;
          case MutationType::InsertARandomByte:
              MutationTypeToPriority[e] = 6;
              break;
          case MutationType::RemoveARandomByte:
              MutationTypeToPriority[e] = 1;
              break;
          case MutationType::ReplaceBytesWithRandom:
              MutationTypeToPriority[e] = 2;
                break;
      }
  }

  while (true) {
      std::string SC = selectInput();
      auto Mutant = mutate(SC);
      test(Target, Mutant, OutDir);
      feedBack(Target, Mutant);
  }
  return 0;
}
